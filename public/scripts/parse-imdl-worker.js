(()=>{"use strict";const t=!1;function e(e,i){if(t&&("boolean"!=typeof e&&(e=e()),!e))throw"string"!=typeof(i=i??"Programmer Error")&&(i=i()),new Error(`Assert: ${i}`)}function i(t,e){return t-e}function s(t,e){return t!==e?t<e?-1:1:0}function n(t,e){return t===e?0:t<e?-1:1}function r(t,e,i){return void 0===e?void 0===i?0:-1:void 0===i?1:t(e,i)}function o(t,e){return r(s,t,e)}function a(t){const e=parseInt(t,16);return Number.isNaN(e)?0:e}function c(t,e,i=!0){const s=t.charCodeAt(e);return s>=(i?48:49)&&s<=57||s>=97&&s<=102}function l(t,e,i){if(0===i)return!1;if(!c(t,e,!1))return!1;for(let s=1;s<i;s++)if(!c(t,e+s))return!1;return!0}var h,d,u,f,g,p,m,x,_,y,v,P,A,I,S,w,C,T,F,k,M,b,E,R,D,X,z,N,O,Y,B,V,L,U,Z,q;!function(t){t.getLocalId=function(t){if(g(t))return 0;const e=t.length,i=e>12?e-10:2;return a(t.slice(i))},t.getBriefcaseId=function(t){if(g(t))return 0;const e=t.length;return e<=12?0:a(t.slice(2,e-10))},t.fromJSON=function(e){return"string"==typeof e?t.fromString(e):t.invalid},t.fromString=function(e){if("string"!=typeof e)return t.invalid;if(t.isId64(e))return e;const s=(e=e.toLowerCase().trim()).length;if(s<2||"0"!==e[0]||"x"!==e[1])return t.invalid;let n=0,r=0,o=2;return s>12&&(o=s-10,r=a(e.slice(2,o))),n=a(e.slice(o)),i(n,r)};const e=["0000000000","000000000","00000000","0000000","000000","00000","0000","000","00","0",""];function i(i,s){if("number"!=typeof i||"number"!=typeof s)return t.invalid;if(0===(i=Math.floor(i)))return t.invalid;s=Math.floor(s);const n=i.toString(16);return`0x${0===s?n:s.toString(16)+(e[n.length]+n)}`}t.fromLocalAndBriefcaseIds=i;const s=[48,120,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48];function n(t){return t+(t<10?48:87)}function r(t,e,i){let s=0;for(let r=e;r<i;r++)s=(s|(n=t.charCodeAt(r))-(n>=87?87:48)<<(i-r-1<<2))>>>0;var n;return s}function o(e,i){if(0==(e>>>0)+4294967296*(255&i))return t.invalid;const r=s;let o=2;for(let t=7;t>=0;t--){const e=t<<2,s=(i&15<<e)>>>e;(o>2||0!==s)&&(r[o++]=n(s))}for(let t=7;t>=0;t--){const i=t<<2,s=(e&15<<i)>>>i;(o>2||0!==s)&&(r[o++]=n(s))}return r.length!==o&&(r.length=o),String.fromCharCode(...s)}function c(t){if(g(t))return 0;const e=t.length;return r(t,e>10?e-8:2,e)}function h(t){const e=t.length;return e<=10||g(t)?0:r(t,2,e-8)}function*d(t){if("string"==typeof t)yield t;else for(const e of t)yield e}function u(t){return 18===t.length&&t.startsWith("0xffffff")}function f(e){return t.invalid!==e&&t.isId64(e)}function g(e){return t.invalid===e}t.fromUint32Pair=o,t.fromUint32PairObject=function(t){return o(t.lower,t.upper)},t.isValidUint32Pair=function(t,e){return 0!==t||!!(255&e)},t.getUint32Pair=function(t,e){return e||(e={lower:0,upper:0}),e.lower=c(t),e.upper=h(t),e},t.getLowerUint32=c,t.getUpperUint32=h,t.toIdSet=function(t,e=!1){if(t instanceof Set)return e?new Set(t):t;const i=new Set;return"string"==typeof t?i.add(t):Array.isArray(t)&&t.forEach((t=>{"string"==typeof t&&i.add(t)})),i},t.iterator=d,t.iterable=function(t){return{[Symbol.iterator]:()=>d(t)}},t.getFirst=function(e){return"string"==typeof e?e:(Array.isArray(e)?e[0]:e.values().next().value)??t.invalid},t.sizeOf=function(t){return"string"==typeof t?1:Array.isArray(t)?t.length:t.size},t.has=function(t,e){return"string"==typeof t?t===e:Array.isArray(t)?-1!==t.indexOf(e):t.has(e)},t.invalid="0",t.isTransient=u,t.isTransientId64=function(t){return f(t)&&u(t)},t.isId64=function(t){const e=t.length;if(0===e||18<e)return!1;if("0"!==t[0])return!1;if(1===e)return!0;if(2===e||"x"!==t[1])return!1;let i=2;if(e>12){if(i=e-10,!l(t,2,i-2))return!1;for(let s=i;s<e&&48===t.charCodeAt(s);s++)i++;if(i>=e)return!1}return l(t,i,e-i)},t.isValid=function(e){return t.invalid!==e},t.isValidId64=f,t.isInvalid=g,t.Uint32Set=class{constructor(t){this._map=new Map,void 0!==t&&this.addIds(t)}equals(t){if(this===t)return!0;if(this.size!==t.size)return!1;for(const[e,i]of this._map){const s=t._map.get(e);if(!s||i.size!==s.size)return!1;for(const t of i)if(!s.has(t))return!1}return!0}clear(){this._map.clear()}addId(e){this.add(t.getLowerUint32(e),t.getUpperUint32(e))}addIds(e){for(const i of t.iterable(e))this.addId(i)}hasId(e){return this.has(t.getLowerUint32(e),t.getUpperUint32(e))}add(t,e){let i=this._map.get(e);void 0===i&&(i=new Set,this._map.set(e,i)),i.add(t)}deleteId(e){this.delete(t.getLowerUint32(e),t.getUpperUint32(e))}deleteIds(e){for(const i of t.iterable(e))this.deleteId(i)}delete(t,e){const i=this._map.get(e);void 0!==i&&i.delete(t)}has(t,e){const i=this._map.get(e);return void 0!==i&&i.has(t)}hasPair(t){return this.has(t.lower,t.upper)}get isEmpty(){return 0===this._map.size}get size(){let t=0;for(const e of this._map)t+=e[1].size;return t}toId64Array(){const e=[];for(const i of this._map)for(const s of i[1])e.push(t.fromUint32Pair(s,i[0]));return e}toId64Set(){const e=new Set;for(const i of this._map)for(const s of i[1])e.add(t.fromUint32Pair(s,i[0]));return e}forEach(t){for(const e of this._map)for(const i of e[1])t(i,e[0])}},t.Uint32Map=class{constructor(){this._map=new Map}clear(){this._map.clear()}getById(e){return this.get(t.getLowerUint32(e),t.getUpperUint32(e))}setById(e,i){this.set(t.getLowerUint32(e),t.getUpperUint32(e),i)}set(t,e,i){let s=this._map.get(e);void 0===s&&(s=new Map,this._map.set(e,s)),s.set(t,i)}get(t,e){const i=this._map.get(e);return void 0!==i?i.get(t):void 0}get isEmpty(){return 0===this._map.size}get size(){let t=0;for(const e of this._map)t+=e[1].size;return t}forEach(t){for(const e of this._map)for(const i of e[1])t(i[0],e[0],i[1])}}}(h||(h={})),function(t){const e=new RegExp("^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$");function i(t){return e.test(t)}t.empty="00000000-0000-0000-0000-000000000000",t.isGuid=i,t.isV4Guid=function(t){return/^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-4[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$/.test(t)},t.createValue=function(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,(t=>{const e=16*Math.random()|0;return("x"===t?e:3&e|8).toString(16)}))},t.normalize=function(t){const e=t.toLowerCase().trim();if(i(e))return e;const s=e.replace(/-/g,""),n=/^([0-9a-f]{8})([0-9a-f]{4})([0-9a-f]{4})([0-9a-f]{4})([0-9a-f]{12})$/;return n.test(s)?s.replace(n,((t,e,i,s,n,r)=>`${e}-${i}-${s}-${n}-${r}`)):t}}(d||(d={})),function(t){function i(t,e){return t.length!==e.length?t.length<e.length?-1:1:t!==e?t<e?-1:1:0}function*s(t){const e=t[Symbol.iterator]();let i,s=e.next();for(;!s.done;){const t=s.value;s=e.next(),t!==i&&(i=t,yield t)}}function*n(t,s){const n=t[Symbol.iterator](),r=s[Symbol.iterator]();let o,a=n.next(),c=r.next();for(;!a.done||!c.done;){const t=a.done?void 0:a.value,s=c.done?void 0:c.value;if(e(void 0!==t||void 0!==s),void 0===t&&void 0===s)break;let l;if(void 0===t)e(void 0!==s),l=s,c=r.next();else if(void 0===s)l=t,a=n.next();else{const e=i(t,s);e<=0?(l=t,a=n.next(),0===e&&(c=r.next())):(l=s,c=r.next())}o!==l&&(o=l,yield l)}}function*r(t,e){const s=t[Symbol.iterator](),n=e[Symbol.iterator]();let r,o=s.next(),a=n.next();for(;!o.done&&!a.done;){const t=o.value;if(o=s.next(),t===r)continue;r=t;let e=a.value,c=i(t,e);for(;c>0;){if(a=n.next(),a.done)return;e=a.value,c=i(t,e)}0===c&&(yield t)}}function*o(t,e){const s=t[Symbol.iterator](),n=e[Symbol.iterator]();let r,o=s.next(),a=n.next();for(;!o.done;){const t=o.value;if(o=s.next(),t===r)continue;if(a.done){yield r=t;continue}let e=a.value,c=i(t,e);for(;c>0&&!a.done;)a=n.next(),a.done?yield r=t:(e=a.value,c=i(t,e));c<0&&(yield r=t)}}t.compare=i,t.sortArray=function(t){return t.sort(((t,e)=>i(t,e))),t},t.areEqualSets=function(t,e){const n=s(t),r=s(e);let o=n.next(),a=r.next();for(;!o.done&&!a.done;){if(0!==i(o.value,a.value))return!1;o=n.next(),a=r.next()}return!(!o.done||!a.done)},t.isEmptySet=function(t){return"string"==typeof t?""===t:!0===t[Symbol.iterator]().next().done},t.unique=function(t){return{[Symbol.iterator]:()=>s(t)}},t.uniqueIterator=s,t.union=function(t,e){return{[Symbol.iterator]:()=>n(t,e)}},t.intersection=function(t,e){return{[Symbol.iterator]:()=>r(t,e)}},t.difference=function(t,e){return{[Symbol.iterator]:()=>o(t,e)}},t.unionIterator=n,t.intersectionIterator=r,t.differenceIterator=o}(u||(u={})),function(t){function i(t){return t>=48&&t<=57||t>=65&&t<=70}function s(t,i){e(i>0);const s=`+${t.toString()}`;return i<=1?s:`${s}*${i.toString(16).toUpperCase()}`}function n(t){const e="string"==typeof t?[t]:Array.from(t);return u.sortArray(e),r(e)}function r(t){return o(t)}function o(t){if("string"==typeof t)return t;let e="";const i=new a,n=new a;let r=0;const o=new a,c=new a;for(const a of t){if(!h.isValidId64(a))continue;o.setFromId(a),c.setFromDifference(o,i);const t=i.compare(o);if(0!==t){if(t>0)throw new Error("CompressedId64Set.compressArray requires a sorted array as input");i.copyFrom(o),0===r?(n.copyFrom(c),r=1):c.equals(n)?++r:(e+=s(n,r),n.copyFrom(c),r=1)}}return 0<r&&(e+=s(n,r)),e}t.compressSet=function(t){return n(t)},t.sortAndCompress=n,t.compressArray=r,t.compressIds=o;class a{static assertUint32(t){e(t>=0),e(t<a._base),e(Math.floor(t)===t)}assertConstraints(){a.assertUint32(this.lower),a.assertUint32(this.upper)}constructor(t=0,e=0){this.lower=t,this.upper=e,this.assertConstraints()}compare(t){const e=this.upper-t.upper;return 0===e?this.lower-t.lower:e}equals(t){return 0===this.compare(t)}isLessThan(t){return this.compare(t)<0}isGreaterThan(t){return this.compare(t)>0}get isZero(){return 0===this.lower&&0===this.upper}setFromDifference(t,i){e(!i.isGreaterThan(t)),this.lower=t.lower-i.lower,this.upper=t.upper-i.upper,this.lower<0&&(this.lower+=a._base,this.upper-=1)}add(t){let e=t.lower,i=t.upper;e+this.lower>=a._base&&(e-=a._base,i+=1),this.lower+=e,this.upper+=i,this.assertConstraints()}setFromId(t){h.getUint32Pair(t,this)}copyFrom(t){this.lower=t.lower,this.upper=t.upper}toString(){if(0===this.upper)return this.lower.toString(16).toUpperCase();const t=this.upper.toString(16),i=this.lower.toString(16).padStart(8,"0");return e(8===i.length),`${t}${i}`.toUpperCase()}toId64String(){return h.fromUint32Pair(this.lower,this.upper)}}function*c(t){if(0===t.length)return;if("+"!==t[0])throw new Error("Invalid CompressedId64Set");let s=1;const n=new a;function r(){let e=0,n=0;for(;s<t.length&&n<8;){++n;const r=t.charCodeAt(s);if(!i(r))break;e<<=4,e|=r>=65?r-65+10:r-48,e>>>=0,++s}return e}function o(n){let o=0,a=0;const c=s,l=r(),h=s-c;if(e(h<=8),8===h&&s+1<t.length&&i(t.charCodeAt(s+1))){const t=s,i=r(),n=s-t;e(n>0&&n<=8);const c=8-n;a=l>>>4*c,o=(i|l-(a<<4*c>>>0)<<4*n>>>0)>>>0}else o=l;n.lower=o,n.upper=a}const c=new a;for(;s<t.length;){let e=1;if(o(c),c.isZero)throw new Error("Invalid CompressedId64Set");if(s<t.length)switch(t[s++]){case"*":if(e=r(),0===e)throw new Error("Invalid CompressedId64Set");if(s!==t.length&&"+"!==t[s++])return;break;case"+":break;default:throw new Error("Invalid CompressedId64Set")}for(let t=0;t<e;t++)n.add(c),yield n.toId64String()}}function l(t){return{[Symbol.iterator]:()=>c(t)}}a._base=4294967296,t.iterator=c,t.iterable=l,t.decompressSet=function(t,e){const i=e??new Set;for(const e of l(t))i.add(e);return i},t.decompressArray=function(t,e){const i=e??[];for(const e of l(t))i.push(e);return i}}(f||(f={})),Symbol.iterator;class W{constructor(t=0,e){this._radians=t,this._degrees=e}clone(){return new W(this._radians,this._degrees)}freeze(){return Object.freeze(this)}static createDegrees(t){return new W(W.degreesToRadians(t),t)}static createRadians(t){return new W(t)}static createSmallAngle(){return new W(Q.smallAngleRadians)}static createInterpolate(t,e,i){return new W(Q.interpolate(t.radians,e,i.radians))}cloneScaled(t){return new W(this.radians*t)}setRadians(t){this._radians=t,this._degrees=void 0}setDegrees(t){this._radians=W.degreesToRadians(t),this._degrees=t}static create360(){return new W(2*Math.PI,360)}static createAtan2(t,e){return new W(Math.atan2(t,e))}setFrom(t){this._radians=t._radians,this._degrees=t._degrees}setFromJSON(t,e){this._radians=e||0,t&&("number"==typeof t?this.setDegrees(t):"number"==typeof t.degrees?this.setDegrees(t.degrees):"number"==typeof t._degrees?this.setDegrees(t._degrees):"number"==typeof t.radians?this.setRadians(t.radians):"number"==typeof t._radians&&this.setRadians(t._radians))}static fromJSON(t,e){const i=new W;return i.setFromJSON(t,e),i}toJSON(){return this.degrees}toJSONRadians(){return{radians:this.radians}}get radians(){return this._radians}get degrees(){return void 0!==this._degrees?this._degrees:W.radiansToDegrees(this._radians)}static degreesToRadians(t){return t*Math.PI/180}static radiansToDegrees(t){if(t<0)return-W.radiansToDegrees(-t);const e=Math.PI;return t<=.25*e?180/e*t:t<.75*e?90+(t-.5*e)/e*180:t<=1.25*e?180+(t-e)/e*180:t<=1.75*e?270+(t-1.5*e)/e*180:360+(t-2*e)/e*180}cos(){return Math.cos(this._radians)}sin(){return Math.sin(this._radians)}tan(){return Math.tan(this._radians)}static isFullCircleRadians(t){return Math.abs(t)>=Q.fullCircleRadiansMinusSmallAngle}static isHalfCircleRadians(t){return Math.abs(Math.abs(t)-Math.PI)<=Q.smallAngleRadians}get isFullCircle(){return W.isFullCircleRadians(this._radians)}get isHalfCircle(){return W.isHalfCircleRadians(this._radians)}static adjustDegrees0To360(t){if(t>=0){const e=360;return t<e?t:t-Math.floor(t/e)*e}return t<0?360-W.adjustDegrees0To360(-t):0}static adjustDegreesSigned180(t){if(Math.abs(t)<=180)return t;if(t>=0){const e=360;return t-(1+Math.floor((t-180)/e))*e}return t<0?-W.adjustDegreesSigned180(-t):0}static adjustRadians0To2Pi(t){if(t>=0){const e=2*Math.PI;return t<e?t:t-Math.floor(t/e)*e}return t<0?2*Math.PI-W.adjustRadians0To2Pi(-t):0}static adjustRadians0ToLessThan2Pi(t){return W.isAlmostEqualRadiansAllowPeriodShift(t,0)&&(t=0),this.adjustRadians0To2Pi(t)}static adjustRadiansMinusPiPlusPi(t){if(Math.abs(t)<=Math.PI)return t;if(t>=0){const e=2*Math.PI;return t-(1+Math.floor((t-Math.PI)/e))*e}return t<0?-W.adjustRadiansMinusPiPlusPi(-t):0}static zero(){return new W(0)}get isExactZero(){return 0===this.radians}get isAlmostZero(){return Math.abs(this.radians)<Q.smallAngleRadians}get isAlmostNorthOrSouthPole(){return W.isHalfCircleRadians(2*this.radians)}static createDegreesAdjustPositive(t){return W.createDegrees(W.adjustDegrees0To360(t))}static createDegreesAdjustSigned180(t){return W.createDegrees(W.adjustDegreesSigned180(t))}static isAlmostEqualRadiansAllowPeriodShift(t,e,i=Q.smallAngleRadians){const s=Math.abs(t-e);if(s<=i)return!0;const n=2*Math.PI;if(Math.abs(s-n)<=i)return!0;const r=s-Math.round(s/n)*n;return Math.abs(r)<=i}isMagnitudeLessThanOrEqual(t){return Math.abs(this.radians)<=Math.abs(t.radians)}isAlmostEqualAllowPeriodShift(t,e=Q.smallAngleRadians){return W.isAlmostEqualRadiansAllowPeriodShift(this._radians,t._radians,e)}static isAlmostEqualRadiansNoPeriodShift(t,e,i=Q.smallAngleRadians){return Math.abs(t-e)<i}isAlmostEqualNoPeriodShift(t,e=Q.smallAngleRadians){return W.isAlmostEqualRadiansNoPeriodShift(this._radians,t._radians,e)}isAlmostEqual(t,e=Q.smallAngleRadians){return this.isAlmostEqualNoPeriodShift(t,e)}static isPerpendicularDotSet(t,e,i){return t>Q.smallMetricDistanceSquared&&e>Q.smallMetricDistanceSquared&&i*i<=Q.smallAngleRadiansSquared*t*e}static trigValuesToHalfAngleTrigValues(t,e){const i=Q.hypotenuseXY(t,e);if(i<Q.smallMetricDistance)return{c:1,s:0,radians:0};{let s,n=0;const r=t/i,o=e/i;return r>=0?(s=Math.sqrt(.5*(1+r)),n=o/(2*s)):(n=o>0?Math.sqrt(.5*(1-r)):-Math.sqrt(.5*(1-r)),s=o/(2*n)),{c:s,s:n,radians:Math.atan2(n,s)}}}static cleanupTrigValue(t,e=Q.smallFloatingPoint){const i=Math.abs(t);if(i<=e)return 0;let s=Math.abs(i-.5);return s<=e?t<0?-.5:.5:(s=Math.abs(i-1),s<=e?t<0?-1:1:t)}static dotProductsToHalfAngleTrigValues(t,e,i,s=!0){const n=t-e,r=2*i;return s&&Math.abs(r)<Q.smallAngleRadians*(Math.abs(t)+Math.abs(e))?{c:1,s:0,radians:0}:W.trigValuesToHalfAngleTrigValues(n,r)}static radiansBetweenVectorsXYZ(t,e,i,s,n,r){const o=t*s+e*n+i*r;return Math.atan2(Q.crossProductMagnitude(t,e,i,s,n,r),o)}static orientedRadiansBetweenVectorsXYZ(t,e,i,s,n,r,o,a,c,l=!1){const h=t*s+e*n+i*r,d=e*r-i*n,u=i*s-t*r,f=t*n-e*s,g=o*d+a*u+c*f,p=Q.hypotenuseXYZ(d,u,f);return g<0?l?Math.PI+Math.atan2(p,-h):-Math.atan2(p,h):Math.atan2(p,h)}addMultipleOf2PiInPlace(t){void 0!==this._degrees?(this._degrees+=360*t,this._radians=W.degreesToRadians(this._degrees)):this._radians+=t*W.pi2Radians}}W.piOver12Radians=.26179938779914946,W.piOver4Radians=.7853981633974483,W.piOver2Radians=1.5707963267948966,W.piRadians=3.141592653589793,W.pi3Over2Radians=4.71238898038469,W.pi2Radians=6.283185307179586,W.degreesPerRadian=45/W.piOver4Radians,W.radiansPerDegree=W.piOver4Radians/45;class G{set(t=0,e=0){this.x=t,this.y=e}setZero(){this.x=0,this.y=0}constructor(t=0,e=0){this.x=t,this.y=e}setFrom(t){t?(this.x=t.x,this.y=t.y):(this.x=0,this.y=0)}freeze(){return Object.freeze(this)}isAlmostEqual(t,e){return Q.isSameCoordinate(this.x,t.x,e)&&Q.isSameCoordinate(this.y,t.y,e)}isAlmostEqualXY(t,e,i){return Q.isSameCoordinate(this.x,t,i)&&Q.isSameCoordinate(this.y,e,i)}toJSON(){return[this.x,this.y]}toJSONXY(){return{x:this.x,y:this.y}}setFromJSON(t){Array.isArray(t)?this.set(t[0]||0,t[1]||0):t?this.set(t.x||0,t.y||0):this.set(0,0)}distance(t){const e=t.x-this.x,i=t.y-this.y;return Math.sqrt(e*e+i*i)}distanceSquared(t){const e=t.x-this.x,i=t.y-this.y;return e*e+i*i}maxDiff(t){return Math.max(Math.abs(this.x-t.x),Math.abs(this.y-t.y))}at(t){return t<.5?this.x:this.y}setAt(t,e){t<.5?this.x=e:this.y=e}indexOfMaxAbs(){let t=0;const e=Math.abs(this.x);return Math.abs(this.y)>e&&(t=1),t}get isAlmostZero(){return Q.isSmallMetricDistance(this.x)&&Q.isSmallMetricDistance(this.y)}get isZero(){return 0===this.x&&0===this.y}maxAbs(){return Math.max(Math.abs(this.x),Math.abs(this.y))}magnitude(){return Math.sqrt(this.x*this.x+this.y*this.y)}magnitudeSquared(){return this.x*this.x+this.y*this.y}isExactEqual(t){return this.x===t.x&&this.y===t.y}isAlmostEqualMetric(t,e=Q.smallMetricDistance){return this.maxDiff(t)<=e}vectorTo(t,e){return J.create(t.x-this.x,t.y-this.y,e)}unitVectorTo(t,e){return this.vectorTo(t,e).normalize(e)}static crossProductToPoints(t,e,i){return Q.crossProductXYXY(e.x-t.x,e.y-t.y,i.x-t.x,i.y-t.y)}}class H extends G{constructor(t=0,e=0){super(t,e)}clone(t){return H.create(this.x,this.y,t)}static create(t=0,e=0,i){return i?(i.x=t,i.y=e,i):new H(t,e)}static fromJSON(t){const e=new H;return e.setFromJSON(t),e}static createFrom(t,e){return t?H.create(t.x,t.y,e):H.create(0,0,e)}static createZero(t){return H.create(0,0,t)}addForwardLeft(t,e,i,s){const n=i.x,r=i.y;return H.create(this.x+t*n-e*r,this.y+t*r+e*n,s)}forwardLeftInterpolate(t,e,i){const s=i.x-this.x,n=i.y-this.y;return H.create(this.x+t*s-e*n,this.y+t*n+e*s)}interpolate(t,e,i){if(t<=.5)return H.create(this.x+t*(e.x-this.x),this.y+t*(e.y-this.y),i);const s=t-1;return H.create(e.x+s*(e.x-this.x),e.y+s*(e.y-this.y),i)}interpolateXY(t,e,i,s){return H.create(Q.interpolate(this.x,t,i.x),Q.interpolate(this.y,e,i.y),s)}minus(t,e){return H.create(this.x-t.x,this.y-t.y,e)}plus(t,e){return H.create(this.x+t.x,this.y+t.y,e)}plusXY(t=0,e=0,i){return H.create(this.x+t,this.y+e,i)}plusScaled(t,e,i){return H.create(this.x+t.x*e,this.y+t.y*e,i)}plus2Scaled(t,e,i,s,n){return H.create(this.x+t.x*e+i.x*s,this.y+t.y*e+i.y*s,n)}plus3Scaled(t,e,i,s,n,r,o){return H.create(this.x+t.x*e+i.x*s+n.x*r,this.y+t.y*e+i.y*s+n.y*r,o)}scaleInPlace(t){this.x*=t,this.y*=t}dotVectorsToTargets(t,e){return(t.x-this.x)*(e.x-this.x)+(t.y-this.y)*(e.y-this.y)}crossProductToPoints(t,e){const i=t.x-this.x,s=t.y-this.y,n=e.x-this.x;return i*(e.y-this.y)-s*n}fractionOfProjectionToLine(t,e,i=0){const s=t.distanceSquared(e);return s<Q.smallMetricDistanceSquared?i:t.dotVectorsToTargets(e,this)/s}}class J extends G{constructor(t=0,e=0){super(t,e)}clone(t){return J.create(this.x,this.y,t)}static create(t=0,e=0,i){return i?(i.x=t,i.y=e,i):new J(t,e)}static unitX(t=1){return new J(t,0)}static unitY(t=1){return new J(0,t)}static createZero(t){return J.create(0,0,t)}static createFrom(t,e){return t instanceof Float64Array?t.length>=2?J.create(t[0],t[1]):t.length>=1?J.create(t[0],0):J.create(0,0):J.create(t.x,t.y,e)}static fromJSON(t){const e=new J;return e.setFromJSON(t),e}static createPolar(t,e){return J.create(t*e.cos(),t*e.sin())}static createStartEnd(t,e,i){return J.create(e.x-t.x,e.y-t.y,i)}static createOffsetBisector(t,e,i){let s=t.plus(e);if(s=s.normalize(),s){const e=s.dotProduct(t);return s.scale(i,s),s.safeDivideOrNull(e)}}safeDivideOrNull(t,e){if(0!==t)return this.scale(1/t,e)}normalize(t){const e=Q.correctSmallFraction(this.magnitude());return t=t||new J,this.safeDivideOrNull(e,t)}fractionOfProjectionToVector(t,e){const i=t.magnitudeSquared();return i<Q.smallMetricDistanceSquared?e||0:this.dotProduct(t)/i}negate(t){return(t=t||new J).x=-this.x,t.y=-this.y,t}rotate90CCWXY(t){t=t||new J;const e=this.x,i=this.y;return t.x=-i,t.y=e,t}rotate90CWXY(t){t=t||new J;const e=this.x,i=this.y;return t.x=i,t.y=-e,t}unitPerpendicularXY(t){t=t||new J;const e=this.x,i=this.y;t.x=-i,t.y=e;const s=e*e+i*i;if(0!==s){const e=1/Math.sqrt(s);t.x*=e,t.y*=e}return t}rotateXY(t,e){const i=t.sin(),s=t.cos(),n=this.x,r=this.y;return(e=e||new J).x=n*s-r*i,e.y=n*i+r*s,e}interpolate(t,e,i){if(i=i||new J,t<=.5)i.x=this.x+t*(e.x-this.x),i.y=this.y+t*(e.y-this.y);else{const s=t-1;i.x=e.x+s*(e.x-this.x),i.y=e.y+s*(e.y-this.y)}return i}plus(t,e){return(e=e||new J).x=this.x+t.x,e.y=this.y+t.y,e}minus(t,e){return(e=e||new J).x=this.x-t.x,e.y=this.y-t.y,e}plusScaled(t,e,i){return(i=i||new J).x=this.x+t.x*e,i.y=this.y+t.y*e,i}plus2Scaled(t,e,i,s,n){return(n=n||new J).x=this.x+t.x*e+i.x*s,n.y=this.y+t.y*e+i.y*s,n}plus3Scaled(t,e,i,s,n,r,o){return(o=o||new J).x=this.x+t.x*e+i.x*s+n.x*r,o.y=this.y+t.y*e+i.y*s+n.y*r,o}scale(t,e){return(e=e||new J).x=this.x*t,e.y=this.y*t,e}scaleToLength(t,e){const i=Q.correctSmallFraction(this.magnitude());if(0!==i)return this.scale(t/i,e)}dotProduct(t){return this.x*t.x+this.y*t.y}dotProductStartEnd(t,e){return this.x*(e.x-t.x)+this.y*(e.y-t.y)}crossProduct(t){return this.x*t.y-this.y*t.x}radiansTo(t){return Math.atan2(this.crossProduct(t),this.dotProduct(t))}angleTo(t){return W.createRadians(this.radiansTo(t))}isParallelTo(t,e=!1,i=!1,s){const n=s?.radianSquaredTol??Q.smallAngleRadiansSquared,r=s?.distanceSquaredTol??Q.smallMetricDistanceSquared,o=this.magnitudeSquared(),a=t.magnitudeSquared();if(o<r||a<r)return i;if(this.dotProduct(t)<0&&!e)return!1;const c=this.crossProduct(t);return c*c<=n*o*a}isPerpendicularTo(t,e=!1,i){const s=i?.radianSquaredTol??Q.smallAngleRadiansSquared,n=i?.distanceSquaredTol??Q.smallMetricDistanceSquared,r=this.magnitudeSquared(),o=t.magnitudeSquared();if(r<n||o<n)return e;const a=this.dotProduct(t);return a*a<=s*r*o}}!function(t){t[t.XYZ=0]="XYZ",t[t.YZX=1]="YZX",t[t.ZXY=2]="ZXY",t[t.XZY=4]="XZY",t[t.YXZ=5]="YXZ",t[t.ZYX=6]="ZYX"}(g||(g={})),function(t){t[t.X=0]="X",t[t.Y=1]="Y",t[t.Z=2]="Z"}(p||(p={})),function(t){t[t.Top=1]="Top",t[t.Bottom=2]="Bottom",t[t.Left=3]="Left",t[t.Right=4]="Right",t[t.Front=5]="Front",t[t.Back=6]="Back",t[t.Iso=7]="Iso",t[t.RightIso=8]="RightIso"}(m||(m={})),function(t){t[t.Unit=0]="Unit",t[t.LongestRangeDirection=1]="LongestRangeDirection",t[t.NonUniformRangeContainment=2]="NonUniformRangeContainment"}(x||(x={})),function(t){t[t.Unknown=0]="Unknown",t[t.OnPolygonVertex=1]="OnPolygonVertex",t[t.OnPolygonEdgeInterior=2]="OnPolygonEdgeInterior",t[t.InsidePolygon=3]="InsidePolygon",t[t.InsidePolygonProjectsToVertex=4]="InsidePolygonProjectsToVertex",t[t.InsidePolygonProjectsToEdgeInterior=5]="InsidePolygonProjectsToEdgeInterior",t[t.OutsidePolygon=6]="OutsidePolygon",t[t.OutsidePolygonProjectsToVertex=7]="OutsidePolygonProjectsToVertex",t[t.OutsidePolygonProjectsToEdgeInterior=8]="OutsidePolygonProjectsToEdgeInterior"}(_||(_={}));class Q{static isLargeCoordinateResult(t){return t>=this.largeCoordinateResult||t<=-this.largeCoordinateResult}static isHugeCoordinate(t){return Q.isLargeCoordinateResult(t)}static isOdd(t){return!(1&~t)}static correctSmallMetricDistance(t,e=0){return void 0===t||Math.abs(t)<=Q.smallMetricDistance?e:t}static correctSmallFraction(t,e=0){return void 0===t||Math.abs(t)<=Q.smallFraction?e:t}static inverseMetricDistance(t){return Math.abs(t)<=Q.smallMetricDistance?void 0:1/t}static inverseMetricDistanceSquared(t){return Math.abs(t)<=Q.smallMetricDistanceSquared?void 0:1/t}static isSameCoordinate(t,e,i=Q.smallMetricDistance){let s=t-e;return s<0&&(s=-s),s<=i}static isSameCoordinateWithToleranceFactor(t,e,i){return Q.isSameCoordinate(t,e,i*Q.smallMetricDistance)}static isSameCoordinateXY(t,e,i,s,n=Q.smallMetricDistance){let r=i-t;return r<0&&(r=-r),!(r>n)&&(r=s-e,r<0&&(r=-r),r<=n)}static isSameCoordinateSquared(t,e,i=Q.smallMetricDistance){return Math.abs(Math.sqrt(t)-Math.sqrt(e))<=i}static isSamePoint3d(t,e,i=Q.smallMetricDistance){return t.distance(e)<=i}static isSameXYZ(t,e,i=Q.smallMetricDistance){return t.distance(e)<=i}static isSamePoint3dXY(t,e,i=Q.smallMetricDistance){return t.distanceXY(e)<=i}static isSameVector3d(t,e,i=Q.smallMetricDistance){return t.distance(e)<=i}static isSamePoint2d(t,e,i=Q.smallMetricDistance){return t.distance(e)<=i}static isSameVector2d(t,e,i=Q.smallMetricDistance){return t.distance(e)<=i}static lexicalXYLessThan(t,e){return t.x<e.x?-1:t.x>e.x?1:t.y<e.y?-1:t.y>e.y?1:0}static lexicalYXLessThan(t,e){return t.y<e.y?-1:t.y>e.y?1:t.x<e.x?-1:t.x>e.x?1:0}static lexicalXYZLessThan(t,e){return t.x<e.x?-1:t.x>e.x?1:t.y<e.y?-1:t.y>e.y?1:t.z<e.z?-1:t.z>e.z?1:0}static isSmallRelative(t){return Math.abs(t)<=Q.smallFraction}static isSmallAngleRadians(t){return Math.abs(t)<=Q.smallAngleRadians}static isSmallAngleRadiansSquared(t){return Math.abs(t)<=Q.smallAngleRadiansSquared}static isAlmostEqualOptional(t,e,i){if(void 0!==t&&void 0!==e){if(Math.abs(t-e)>i)return!1}else if(void 0!==t||void 0!==e)return!1;return!0}static isAlmostEqualNumber(t,e,i=Q.smallAngleRadians){const s=1+Math.abs(t)+Math.abs(e);return Math.abs(t-e)<=i*s}static isAlmostEqualEitherNumber(t,e,i,s=Q.smallAngleRadians){return this.isAlmostEqualNumber(t,e,s)||this.isAlmostEqualNumber(t,i,s)}static isAlmostEqualXAndY(t,e,i=Q.smallAngleRadians){const s=i*(1+Math.abs(t.x)+Math.abs(e.x)+Math.abs(t.y)+Math.abs(e.y));return Math.abs(t.x-e.x)<=s&&Math.abs(t.y-e.y)<=s}static isDistanceWithinTol(t,e=Q.smallMetricDistance){return Math.abs(t)<=e}static isSmallMetricDistance(t){return Math.abs(t)<=Q.smallMetricDistance}static isSmallMetricDistanceSquared(t){return Math.abs(t)<=Q.smallMetricDistanceSquared}static cyclic3dAxis(t){if(t>=0)return t<3?t:t<6?t-3:t%3;const e=t+3;return e>=0?e:2-(-t-1)%3}static axisIndexToRightHandedAxisOrder(t){return 0===t?g.XYZ:1===t?g.YZX:2===t?g.ZXY:Q.axisIndexToRightHandedAxisOrder(Q.cyclic3dAxis(t))}static maxXYZ(t,e,i){let s=t;return e>s&&(s=e),i>s&&(s=i),s}static minXYZ(t,e,i){let s=t;return e<s&&(s=e),i<s&&(s=i),s}static maxXY(t,e){let i=t;return e>i&&(i=e),i}static minXY(t,e){let i=t;return e<i&&(i=e),i}static maxAbsXYZ(t,e,i){return Q.maxXYZ(Math.abs(t),Math.abs(e),Math.abs(i))}static maxAbsXY(t,e){return Q.maxXY(Math.abs(t),Math.abs(e))}static maxAbsDiff(t,e,i){return Math.max(Math.abs(t-e),Math.abs(t-i))}static split3WaySign(t,e,i,s){return t<0?e:t>0?s:i}static split3Way01(t,e=Q.smallMetricDistance){return t>e?1:t<-e?-1:0}static square(t){return t*t}static hypotenuseXY(t,e){return Math.sqrt(t*t+e*e)}static hypotenuseSquaredXY(t,e){return t*t+e*e}static hypotenuseXYZ(t,e,i){return Math.sqrt(t*t+e*e+i*i)}static hypotenuseSquaredXYZ(t,e,i){return t*t+e*e+i*i}static hypotenuseXYZW(t,e,i,s){return Math.sqrt(t*t+e*e+i*i+s*s)}static hypotenuseSquaredXYZW(t,e,i,s){return t*t+e*e+i*i+s*s}static distanceXYXY(t,e,i,s){return Q.hypotenuseXY(i-t,s-e)}static distanceXYZXYZ(t,e,i,s,n,r){return Q.hypotenuseXYZ(s-t,n-e,r-i)}static tripleProduct(t,e,i,s,n,r,o,a,c){return t*(n*c-r*a)+e*(r*o-s*c)+i*(s*a-n*o)}static determinant4x4(t,e,i,s,n,r,o,a,c,l,h,d,u,f,g,p){return t*this.tripleProduct(r,o,a,l,h,d,f,g,p)-n*this.tripleProduct(e,i,s,l,h,d,f,g,p)+c*this.tripleProduct(e,i,s,r,o,a,f,g,p)-u*this.tripleProduct(e,i,s,r,o,a,l,h,d)}static tripleProductXYW(t,e,i,s,n,r){return Q.tripleProduct(t.x,i.x,n.x,t.y,i.y,n.y,e,s,r)}static tripleProductPoint4dXYW(t,e,i){return Q.tripleProduct(t.x,e.x,i.x,t.y,e.y,i.y,t.w,e.w,i.w)}static crossProductXYXY(t,e,i,s){return t*s-e*i}static crossProductXYZXYZ(t,e,i,s,n,r,o){return $.create(e*r-i*n,i*s-t*r,t*n-e*s,o)}static crossProductMagnitude(t,e,i,s,n,r){return Q.hypotenuseXYZ(e*r-i*n,i*s-t*r,t*n-e*s)}static dotProductXYXY(t,e,i,s){return t*i+e*s}static dotProductXYZXYZ(t,e,i,s,n,r){return t*s+e*n+i*r}static meanCurvatureOfRadii(t,e){return.5*(this.safeDivideFraction(1,t,0)+this.safeDivideFraction(1,e,0))}static curvatureMagnitude(t,e,i,s,n,r){let o=e*r-i*n,a=o*o;o=i*s-t*r,a+=o*o,o=t*n-e*s,a+=o*o;const c=Math.sqrt(a),l=Math.sqrt(t*t+e*e+i*i),h=l*l*l;return h>Q.smallAngleRadians*c?c/h:0}static clampToStartEnd(t,e,i){return e>i?Q.clampToStartEnd(t,i,e):t<e?e:i<t?i:t}static clamp(t,e,i){return Math.max(e,Math.min(i,t))}static resolveNumber(t,e=0){return void 0!==t?t:e}static resolveValue(t,e){return void 0!==t?t:e}static resolveToUndefined(t,e){return t===e?void 0:t}static interpolate(t,e,i){return e<=.5?t+e*(i-t):i-(1-e)*(i-t)}static interpolateByte(t,e,i,s){return t=t>>>s&255,i=i>>>s&255,(255&Math.floor(t+e*(i-t)))<<s}static interpolateColor(t,e,i){return e=Q.clamp(e,0,1),this.interpolateByte(t,e,i,0)|this.interpolateByte(t,e,i,8)|this.interpolateByte(t,e,i,16)|this.interpolateByte(t,e,i,24)}static axisOrderToAxis(t,e){const i=t<=g.ZXY?t+e:t-g.XZY-e;return Q.cyclic3dAxis(i)}static modulo(t,e){if(e<=0)return 0===e?t:-Q.modulo(-t,-e);if(t>=0){if(t<e)return t;if(t<2*e)return t-e}else if((t+=e)>0)return t;return t-Math.floor(t/e)*e}static defined01(t){return void 0===t?0:1}static conditionalDivideFraction(t,e){if(0!==e)return Math.abs(e)*Q.largeFractionResult>=Math.abs(t)?t/e:void 0}static safeDivideFraction(t,e,i){const s=Q.conditionalDivideFraction(t,e);return void 0!==s?s:i}static conditionalDivideCoordinate(t,e,i=Q.largeCoordinateResult){if(0!==e)return Math.abs(e*i)>=Math.abs(t)?t/e:void 0}static solveTrigForm(t,e,i){const s=e*e+i*i;let n;if(s>0){const r=1/s,o=1-t*t*r;if(o<-Q.smallMetricDistanceSquared)return n;const a=-t*r,c=a*e,l=a*i;if(o<=Q.smallMetricDistanceSquared)n=[J.create(c,l)];else{const t=Math.sqrt(o*r);n=[J.create(c-t*i,l+t*e),J.create(c+t*i,l-t*e)]}}return n}static inverseInterpolate(t,e,i,s,n=0,r){const o=Q.conditionalDivideFraction(n-e,s-e);return void 0!==o?Q.interpolate(t,o,i):r}static inverseInterpolate01(t,e,i=0){return Q.conditionalDivideFraction(i-t,e-t)}static isNumberArray(t,e=0){if(Array.isArray(t)&&t.length>=e){let e;for(e of t)if(!Number.isFinite(e))return!1;return!0}return!1}static isArrayOfNumberArray(t,e,i=0){if(Array.isArray(t)&&t.length>=e){let e;for(e of t)if(!Q.isNumberArray(e,i))return!1;return!0}return!1}static stepCount(t,e,i=1,s=101){if(t<=0)return i;if(t>=(e=Math.abs(e)))return i;const n=Math.floor((e+.999999*t)/t);return n<i?i:n>s?s:n}static isIn01(t,e=!0){return!e||t>=0&&t<=1}static isIn01WithTolerance(t,e){return t+(e=Math.abs(e))>=0&&t-e<=1}static restrictToInterval(t,e,i){return e<=i?t<e?e:t>i?i:t:t<i?i:t>e?e:t}static equalStringNoCase(t,e){return t.toUpperCase()===e.toUpperCase()}static exactEqualNumberArrays(t,e){if(Array.isArray(t)&&0===t.length&&(t=void 0),Array.isArray(e)&&0===e.length&&(e=void 0),void 0===t&&void 0===e)return!0;if(Array.isArray(t)&&Array.isArray(e)){if(t.length!==e.length)return!1;for(let i=0;i<t.length;i++)if(t[i]!==e[i])return!1;return!0}return!1}static almostEqualArrays(t,e,i){if(Array.isArray(t)&&0===t.length&&(t=void 0),Array.isArray(e)&&0===e.length&&(e=void 0),void 0===t&&void 0===e)return!0;if(Array.isArray(t)&&Array.isArray(e)){if(t.length!==e.length)return!1;for(let s=0;s<t.length;s++)if(!i(t[s],e[s]))return!1;return!0}return!1}static almostEqualNumberArrays(t,e,i){if(Array.isArray(t)&&0===t.length&&(t=void 0),Array.isArray(e)&&0===e.length&&(e=void 0),void 0===t&&void 0===e)return!0;if(Array.isArray(t)&&Array.isArray(e)){if(t.length!==e.length)return!1;for(let s=0;s<t.length;s++)if(!i(t[s],e[s]))return!1;return!0}return!1}static areEqualAllowUndefined(t,e,i=!0){return void 0===t&&void 0===e?i:void 0!==t&&void 0!==e&&t===e}static cloneMembers(t){if(void 0===t)return;const e=[];for(const i of t)e.push(i.clone());return e}static cloneArray(t){if(void 0===t)return;const e=[];for(const i of t)e.push(i.clone());return e}}Q.smallMetricDistance=1e-6,Q.smallMetricDistanceSquared=1e-12,Q.smallAngleRadians=1e-12,Q.smallAngleRadiansSquared=1e-24,Q.smallAngleDegrees=57e-12,Q.smallAngleSeconds=2e-7,Q.smallFraction=1e-10,Q.smallFloatingPoint=1e-15,Q.fullCircleRadiansMinusSmallAngle=2*Math.PI-Q.smallAngleRadians,Q.largeFractionResult=1e10,Q.largeCoordinateResult=1e13,Q.hugeCoordinate=1e12,function(t){t.almostEqual=function(t,e,i){return Q.isSameCoordinate(t.x,e.x,i)&&Q.isSameCoordinate(t.y,e.y,i)&&Q.isSameCoordinate(t.z,e.z,i)}}(y||(y={}));class K{set(t=0,e=0,i=0){this.x=t,this.y=e,this.z=i}setZero(){this.x=0,this.y=0,this.z=0}constructor(t=0,e=0,i=0){this.x=t,this.y=e,this.z=i}static isXAndY(t){return void 0!==t.x&&void 0!==t.y}static hasZ(t){return void 0!==t.z}static isXYAndZ(t){return this.isXAndY(t)&&this.hasZ(t)}static isAnyImmediatePointType(t){return j.isXAndY(t)||Q.isNumberArray(t,2)}static accessX(t,e){return void 0!==t.x?t.x:Array.isArray(t)&&t.length>0&&Number.isFinite(t[0])?t[0]:e}static accessY(t,e){return void 0!==t.y?t.y:Array.isArray(t)&&t.length>1&&Number.isFinite(t[1])?t[1]:e}static accessZ(t,e){return void 0!==t.z?t.z:Array.isArray(t)&&t.length>2&&Number.isFinite(t[2])?t[2]:e}setFrom(t){void 0===t?this.setZero():K.isXAndY(t)?(this.x=t.x,this.y=t.y,this.z=K.hasZ(t)?t.z:0):(this.x=t[0],this.y=t[1],this.z=t[2])}setFromPoint3d(t){t?(this.x=t.x,this.y=t.y,this.z=t.z):this.setZero()}setFromVector3d(t){t?(this.x=t.x,this.y=t.y,this.z=t.z):this.setZero()}isAlmostEqual(t,e){return y.almostEqual(this,t,e)}isAlmostEqualXYZ(t,e,i,s){return Q.isSameCoordinate(this.x,t,s)&&Q.isSameCoordinate(this.y,e,s)&&Q.isSameCoordinate(this.z,i,s)}isAlmostEqualPointPlusScaledVector(t,e,i,s){return Q.isSameCoordinate(this.x,t.x+e.x*i,s)&&Q.isSameCoordinate(this.y,t.y+e.y*i,s)&&Q.isSameCoordinate(this.z,t.z+e.z*i,s)}isAlmostEqualXY(t,e){return Q.isSameCoordinate(this.x,t.x,e)&&Q.isSameCoordinate(this.y,t.y,e)}toJSON(){return this.toArray()}toArray(){return[this.x,this.y,this.z]}toJSONXYZ(){return{x:this.x,y:this.y,z:this.z}}toFloat64Array(){return Float64Array.of(this.x,this.y,this.z)}setFromJSON(t){Array.isArray(t)?this.set(t[0]||0,t[1]||0,t[2]||0):t?this.set(t.x||0,t.y||0,t.z||0):this.set(0,0,0)}distance(t){const e=t.x-this.x,i=t.y-this.y,s=t.z-this.z;return Math.sqrt(e*e+i*i+s*s)}distanceSquared(t){const e=t.x-this.x,i=t.y-this.y,s=t.z-this.z;return e*e+i*i+s*s}distanceXY(t){const e=t.x-this.x,i=t.y-this.y;return Math.sqrt(e*e+i*i)}distanceSquaredXY(t){const e=t.x-this.x,i=t.y-this.y;return e*e+i*i}maxDiff(t){return Math.max(Math.abs(this.x-t.x),Math.abs(this.y-t.y),Math.abs(this.z-t.z))}at(t){return t<.5?this.x:t>1.5?this.z:this.y}setAt(t,e){t<.5?this.x=e:t>1.5?this.z=e:this.y=e}indexOfMaxAbs(){let t=0,e=Math.abs(this.x),i=Math.abs(this.y);return i>e&&(t=1,e=i),i=Math.abs(this.z),i>e&&(t=2),t}get isAlmostZero(){return Q.isSmallMetricDistance(this.x)&&Q.isSmallMetricDistance(this.y)&&Q.isSmallMetricDistance(this.z)}get isZero(){return 0===this.x&&0===this.y&&0===this.z}maxAbs(){return Math.max(Math.abs(this.x),Math.abs(this.y),Math.abs(this.z))}magnitude(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}magnitudeSquared(){return this.x*this.x+this.y*this.y+this.z*this.z}magnitudeXY(){return Math.sqrt(this.x*this.x+this.y*this.y)}magnitudeSquaredXY(){return this.x*this.x+this.y*this.y}isExactEqual(t){return this.x===t.x&&this.y===t.y&&this.z===t.z}isAlmostEqualMetric(t){return this.maxDiff(t)<=Q.smallMetricDistance}addInPlace(t){this.x+=t.x,this.y+=t.y,this.z+=t.z}subtractInPlace(t){this.x-=t.x,this.y-=t.y,this.z-=t.z}addScaledInPlace(t,e){this.x+=e*t.x,this.y+=e*t.y,this.z+=e*t.z}scaleInPlace(t){this.x*=t,this.y*=t,this.z*=t}addXYZInPlace(t=0,e=0,i=0){this.x+=t,this.y+=e,this.z+=i}cloneAsPoint3d(){return j.create(this.x,this.y,this.z)}vectorTo(t,e){return $.create(t.x-this.x,t.y-this.y,t.z-this.z,e)}scaledVectorTo(t,e,i){return $.create(e*(t.x-this.x),e*(t.y-this.y),e*(t.z-this.z),i)}unitVectorTo(t,e){return this.vectorTo(t,e).normalize(e)}freeze(){return Object.freeze(this)}static x(t,e=0){return void 0===t?e:Array.isArray(t)?t[0]:void 0!==t.x?t.x:e}static y(t,e=0){return void 0===t?e:Array.isArray(t)?t[1]:void 0!==t.y?t.y:e}static z(t,e=0){return void 0===t?e:Array.isArray(t)?t[2]:void 0!==t.z?t.z:e}}class j extends K{constructor(t=0,e=0,i=0){super(t,e,i)}static fromJSON(t){const e=new j;return e.setFromJSON(t),e}clone(t){return j.create(this.x,this.y,this.z,t)}static create(t=0,e=0,i=0,s){return s?(s.x=t,s.y=e,s.z=i,s):new j(t,e,i)}static createFrom(t,e){if(t instanceof Float64Array){let i=0,s=0,n=0;return t.length>0&&(i=t[0]),t.length>1&&(s=t[1]),t.length>2&&(n=t[2]),j.create(i,s,n,e)}return j.create(t.x,t.y,K.hasZ(t)?t.z:0,e)}static createFromPacked(t,e,i){const s=3*e;if(s>=0&&s+2<t.length)return j.create(t[s],t[s+1],t[s+2],i)}static createFromPackedXYZW(t,e,i){const s=4*e;if(s>=0&&s+3<t.length){const e=t[s+3];if(!Q.isSmallMetricDistance(e)){const n=1/e;return j.create(n*t[s],n*t[s+1],n*t[s+2],i)}}}static createArrayFromPackedXYZ(t){const e=[];for(let i=0;i+2<t.length;i+=3)e.push(new j(t[i],t[i+1],t[i+2]));return e}static createZero(t){return j.create(0,0,0,t)}crossProductToPoints(t,e,i){return $.createCrossProduct(t.x-this.x,t.y-this.y,t.z-this.z,e.x-this.x,e.y-this.y,e.z-this.z,i)}crossProductToPointsMagnitude(t,e){return Q.crossProductMagnitude(t.x-this.x,t.y-this.y,t.z-this.z,e.x-this.x,e.y-this.y,e.z-this.z)}tripleProductToPoints(t,e,i){return Q.tripleProduct(t.x-this.x,t.y-this.y,t.z-this.z,e.x-this.x,e.y-this.y,e.z-this.z,i.x-this.x,i.y-this.y,i.z-this.z)}crossProductToPointsXY(t,e){return Q.crossProductXYXY(t.x-this.x,t.y-this.y,e.x-this.x,e.y-this.y)}interpolate(t,e,i){if(t<=.5)return j.create(this.x+t*(e.x-this.x),this.y+t*(e.y-this.y),this.z+t*(e.z-this.z),i);const s=t-1;return j.create(e.x+s*(e.x-this.x),e.y+s*(e.y-this.y),e.z+s*(e.z-this.z),i)}interpolateXYZ(t,e,i,s,n){return j.create(Q.interpolate(this.x,t,s.x),Q.interpolate(this.y,e,s.y),Q.interpolate(this.z,i,s.z),n)}interpolatePerpendicularXY(t,e,i,s){s=s||new j;const n=e.minus(this);return this.interpolate(t,e,s),s.x-=i*n.y,s.y+=i*n.x,s}minus(t,e){return j.create(this.x-t.x,this.y-t.y,this.z-t.z,e)}plus(t,e){return j.create(this.x+t.x,this.y+t.y,this.z+t.z,e)}plusXYZ(t=0,e=0,i=0,s){return j.create(this.x+t,this.y+e,this.z+i,s)}plusScaled(t,e,i){return j.create(this.x+t.x*e,this.y+t.y*e,this.z+t.z*e,i)}plus2Scaled(t,e,i,s,n){return j.create(this.x+t.x*e+i.x*s,this.y+t.y*e+i.y*s,this.z+t.z*e+i.z*s,n)}plus3Scaled(t,e,i,s,n,r,o){return j.create(this.x+t.x*e+i.x*s+n.x*r,this.y+t.y*e+i.y*s+n.y*r,this.z+t.z*e+i.z*s+n.z*r,o)}static createScale(t,e,i){return j.create(t.x*e,t.y*e,t.z*e,i)}static createAdd2Scaled(t,e,i,s,n){return j.create(t.x*e+i.x*s,t.y*e+i.y*s,t.z*e+i.z*s,n)}static createAdd3Scaled(t,e,i,s,n,r,o){return j.create(t.x*e+i.x*s+n.x*r,t.y*e+i.y*s+n.y*r,t.z*e+i.z*s+n.z*r,o)}dotVectorsToTargets(t,e){return(t.x-this.x)*(e.x-this.x)+(t.y-this.y)*(e.y-this.y)+(t.z-this.z)*(e.z-this.z)}fractionOfProjectionToLine(t,e,i=0){const s=t.distanceSquared(e);return s<Q.smallMetricDistanceSquared?i:t.dotVectorsToTargets(e,this)/s}}class $ extends K{constructor(t=0,e=0,i=0){super(t,e,i)}static createArrayFromPackedXYZ(t){const e=[];for(let i=0;i+2<t.length;i+=3)e.push(new $(t[i],t[i+1],t[i+2]));return e}clone(t){return $.create(this.x,this.y,this.z,t)}static create(t=0,e=0,i=0,s){return s?(s.x=t,s.y=e,s.z=i,s):new $(t,e,i)}static createCrossProduct(t,e,i,s,n,r,o){return $.create(e*r-i*n,i*s-t*r,t*n-e*s,o)}addCrossProductToTargetsInPlace(t,e,i,s,n,r,o,a,c){const l=s-t,h=n-e,d=r-i,u=o-t,f=a-e,g=c-i;this.x+=h*g-d*f,this.y+=d*u-l*g,this.z+=l*f-h*u}static createCrossProductToPoints(t,e,i,s){return $.createCrossProduct(e.x-t.x,e.y-t.y,e.z-t.z,i.x-t.x,i.y-t.y,i.z-t.z,s)}static createUnitCrossProductToPoints(t,e,i,s){return $.createCrossProduct(e.x-t.x,e.y-t.y,e.z-t.z,i.x-t.x,i.y-t.y,i.z-t.z,s).normalize()}static createPolar(t,e,i){return $.create(t*e.cos(),t*e.sin(),i)}static createSpherical(t,e,i){const s=i.cos();return $.create(s*t*e.cos(),s*t*e.sin(),t*i.sin())}static fromJSON(t){const e=new $;return e.setFromJSON(t),e}static createFrom(t,e){if(t instanceof Float64Array){let i=0,s=0,n=0;return t.length>0&&(i=t[0]),t.length>1&&(s=t[1]),t.length>2&&(n=t[2]),$.create(i,s,n,e)}return Array.isArray(t)?$.create(t[0],t[1],t.length>2?t[2]:0):$.create(t.x,t.y,K.hasZ(t)?t.z:0,e)}static createStartEnd(t,e,i){const s=K.accessZ(t,0),n=K.accessZ(e,0)-s;return i?(i.set(e.x-t.x,e.y-t.y,n),i):new $(e.x-t.x,e.y-t.y,n)}static createStartEndXYZXYZ(t,e,i,s,n,r,o){return this.create(s-t,n-e,r-i,o)}static createRotateVectorAroundVector(t,e,i){const s=e.normalize();if(s){const e=s.crossProduct(t);let n,r;return i?(n=i.cos(),r=i.sin()):(n=0,r=1),$.createAdd3Scaled(t,n,e,r,s,s.dotProduct(t)*(1-n))}}setStartEnd(t,e){this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z}static createZero(t){return $.create(0,0,0,t)}static unitX(t=1){return new $(t,0,0)}static unitY(t=1){return new $(0,t,0)}static unitZ(t=1){return new $(0,0,t)}safeDivideOrNull(t,e){if(0!==t)return this.scale(1/t,e)}normalizeWithLength(t){const e=this.magnitude(),i=Q.correctSmallFraction(e);return t=t||new $,{v:this.safeDivideOrNull(i,t),mag:e}}normalize(t){return this.normalizeWithLength(t).v}normalizeInPlace(){return void 0!==this.normalizeWithLength(this).v}static createNormalized(t=0,e=0,i=0,s){if(void 0===s?s=$.create(t,e,i):s.set(t,e,i),s.normalizeInPlace())return s}static createNormalizedStartEnd(t,e,i){if((i=$.createStartEnd(t,e,i)).normalizeInPlace())return i}fractionOfProjectionToVector(t,e=0){const i=t.magnitudeSquared();return i<Q.smallMetricDistanceSquared?e:this.dotProduct(t)/i}negate(t){return(t=t||new $).x=-this.x,t.y=-this.y,t.z=-this.z,t}rotate90CCWXY(t){t=t||new $;const e=this.x,i=this.y;return t.x=-i,t.y=e,t.z=this.z,t}rotate90CWXY(t){t=t||new $;const e=this.x,i=this.y;return t.x=i,t.y=-e,t.z=this.z,t}unitPerpendicularXY(t){t=t||new $;const e=this.x,i=this.y;t.x=-i,t.y=e,t.z=0;const s=e*e+i*i;if(0!==s){const e=1/Math.sqrt(s);t.x*=e,t.y*=e}return t}rotateXY(t,e){const i=t.sin(),s=t.cos(),n=this.x,r=this.y;return(e=e||new $).x=n*s-r*i,e.y=n*i+r*s,e.z=this.z,e}rotate90Towards(t,e){const i=this.crossProduct(t).normalize();return i?i.crossProduct(this,e):void 0}rotate90Around(t,e){const i=t.normalize();return i?i.crossProduct(this).plusScaled(i,i.dotProduct(this),e):void 0}interpolate(t,e,i){if(i=i||new $,t<=.5)i.x=this.x+t*(e.x-this.x),i.y=this.y+t*(e.y-this.y),i.z=this.z+t*(e.z-this.z);else{const s=t-1;i.x=e.x+s*(e.x-this.x),i.y=e.y+s*(e.y-this.y),i.z=e.z+s*(e.z-this.z)}return i}plus(t,e){return(e=e||new $).x=this.x+t.x,e.y=this.y+t.y,e.z=this.z+t.z,e}minus(t,e){return(e=e||new $).x=this.x-t.x,e.y=this.y-t.y,e.z=this.z-t.z,e}plusScaled(t,e,i){return(i=i||new $).x=this.x+t.x*e,i.y=this.y+t.y*e,i.z=this.z+t.z*e,i}plus2Scaled(t,e,i,s,n){return(n=n||new $).x=this.x+t.x*e+i.x*s,n.y=this.y+t.y*e+i.y*s,n.z=this.z+t.z*e+i.z*s,n}plus3Scaled(t,e,i,s,n,r,o){return(o=o||new $).x=this.x+t.x*e+i.x*s+n.x*r,o.y=this.y+t.y*e+i.y*s+n.y*r,o.z=this.z+t.z*e+i.z*s+n.z*r,o}static createAdd2Scaled(t,e,i,s,n){return $.create(t.x*e+i.x*s,t.y*e+i.y*s,t.z*e+i.z*s,n)}static createAdd2ScaledXYZ(t,e,i,s,n,r,o,a,c){return $.create(t*s+n*a,e*s+r*a,i*s+o*a,c)}static createAdd3Scaled(t,e,i,s,n,r,o){return $.create(t.x*e+i.x*s+n.x*r,t.y*e+i.y*s+n.y*r,t.z*e+i.z*s+n.z*r,o)}scale(t,e){return(e=e||new $).x=this.x*t,e.y=this.y*t,e.z=this.z*t,e}scaleToLength(t,e){const i=Q.correctSmallFraction(this.magnitude());if(0!==i)return this.scale(t/i,e)}unitCrossProduct(t,e){return this.crossProduct(t,e).normalize(e)}unitCrossProductWithDefault(t,e,i,s,n){const r=this.crossProduct(t,n).normalize(n);return void 0===r?$.create(e,i,s,n):r}normalizeWithDefault(t,e,i,s){return this.normalize(s)||((s=$.create(t,e,i,s)).normalizeInPlace()?s:$.create(1,0,0,s))}tryNormalizeInPlace(t=Q.smallFraction){const e=this.magnitude();return!(e<t||0===e||(this.scaleInPlace(1/e),0))}sizedCrossProduct(t,e,i){if((i=this.crossProduct(t,i)).tryNormalizeInPlace())return i.scaleInPlace(e),i}crossProductMagnitudeSquared(t){const e=this.y*t.z-this.z*t.y,i=this.z*t.x-this.x*t.z,s=this.x*t.y-this.y*t.x;return e*e+i*i+s*s}crossProductMagnitude(t){return Math.sqrt(this.crossProductMagnitudeSquared(t))}dotProduct(t){return this.x*t.x+this.y*t.y+this.z*t.z}static dotProductAsXYAndZ(t,e){return t.x*e.x+t.y*e.y+t.z*e.z}dotProductStartEnd(t,e){return this.x*(e.x-t.x)+this.y*(e.y-t.y)+this.z*(e.z-t.z)}dotProductStart3dEnd4d(t,e){const i=e.w;return this.x*(e.x-t.x*i)+this.y*(e.y-t.y*i)+this.z*(e.z-t.z*i)}crossProductStartEnd(t,e,i){return $.createCrossProduct(this.x,this.y,this.z,e.x-t.x,e.y-t.y,e.z-t.z,i)}crossProductStartEndXY(t,e){return Q.crossProductXYXY(this.x,this.y,e.x-t.x,e.y-t.y)}dotProductStartEndXYZ(t,e,i,s){return this.x*(e-t.x)+this.y*(i-t.y)+this.z*(s-t.z)}dotProductStartEndXY(t,e){return this.x*(e.x-t.x)+this.y*(e.y-t.y)}dotProductStartEndXYZW(t,e,i,s,n){if(Q.isSmallMetricDistance(n))return 0;const r=1/n;return this.x*(r*e-t.x)+this.y*(r*i-t.y)+this.z*(r*s-t.z)}dotProductXY(t){return this.x*t.x+this.y*t.y}dotProductXYZ(t,e,i=0){return this.x*t+this.y*e+this.z*i}tripleProduct(t,e){return Q.tripleProduct(this.x,this.y,this.z,t.x,t.y,t.z,e.x,e.y,e.z)}crossProductXY(t){return this.x*t.y-this.y*t.x}crossProduct(t,e){return $.createCrossProduct(this.x,this.y,this.z,t.x,t.y,t.z,e)}crossProductXYZ(t,e,i,s){return $.createCrossProduct(this.x,this.y,this.z,t,e,i,s)}radiansTo(t){return Math.atan2(this.crossProductMagnitude(t),this.dotProduct(t))}angleTo(t){return W.createRadians(this.radiansTo(t))}angleFromPerpendicular(t){return W.createAtan2(this.dotProduct(t),this.crossProductMagnitude(t))}radiansFromPerpendicular(t){return Math.atan2(this.dotProduct(t),this.crossProductMagnitude(t))}angleToXY(t){return W.createAtan2(this.crossProductXY(t),this.dotProductXY(t))}signedRadiansTo(t,e){const i=this.crossProduct(t),s=Math.atan2(i.magnitude(),this.dotProduct(t));return e.dotProduct(i)<0?-s:s}signedAngleTo(t,e){return W.createRadians(this.signedRadiansTo(t,e))}planarRadiansTo(t,e){const i=e.dotProduct(e);if(0===i)return 0;const s=1/i,n=this.plusScaled(e,-this.dotProduct(e)*s),r=t.plusScaled(e,-t.dotProduct(e)*s);return n.signedRadiansTo(r,e)}planarAngleTo(t,e){return W.createRadians(this.planarRadiansTo(t,e))}smallerUnorientedRadiansTo(t){const e=this.dotProduct(t),i=this.crossProductMagnitude(t);return Math.atan2(Math.abs(i),Math.abs(e))}smallerUnorientedAngleTo(t){return W.createRadians(this.smallerUnorientedRadiansTo(t))}isParallelTo(t,e=!1,i=!1,s){const n=s?.radianSquaredTol??Q.smallAngleRadiansSquared,r=s?.distanceSquaredTol??Q.smallMetricDistanceSquared,o=this.magnitudeSquared(),a=t.magnitudeSquared();return o<r||a<r?i:!(this.dotProduct(t)<0&&!e)&&this.crossProductMagnitudeSquared(t)<=n*o*a}isPerpendicularTo(t,e=!1,i){const s=i?.radianSquaredTol??Q.smallAngleRadiansSquared,n=i?.distanceSquaredTol??Q.smallMetricDistanceSquared,r=this.magnitudeSquared(),o=t.magnitudeSquared();if(r<n||o<n)return e;const a=this.dotProduct(t);return a*a<=s*r*o}}class tt{isPointInPlane(t,e=Q.smallMetricDistance){return Math.abs(this.altitude(t))<=e}classifyAltitude(t,e=Q.smallMetricDistance){return Q.split3Way01(this.altitude(t),e)}classifyAltitudeXYZ(t,e,i,s=Q.smallMetricDistance){return Q.split3Way01(this.altitudeXYZ(t,e,i),s)}getUnitNormal(t){return $.createNormalized(this.normalX(),this.normalY(),this.normalZ(),t)}getAnyPointOnPlane(t){return this.projectPointToPlane(j.create(0,0,0),t)}}class et{constructor(t){this._curIndex=-1,this._collection=t}next(){return++this._curIndex>=this._collection.length?{done:!0}:{value:this._collection.getPoint3dAtUncheckedPointIndex(this._curIndex),done:!1}}[Symbol.iterator](){return this}}class it{vectorIndexXYAndZ(t,e,i){const s=this.vectorXYAndZIndex(e,t,i);return s?.negate(s)}dotProductIndexIndexIndex(t,e,i){if(t<0||t>=this.length||e<0||e>=this.length||i<0||i>=this.length)return;const s=this.getXAtUncheckedPointIndex(t),n=this.getYAtUncheckedPointIndex(t),r=this.getZAtUncheckedPointIndex(t);return(this.getXAtUncheckedPointIndex(e)-s)*(this.getXAtUncheckedPointIndex(i)-s)+(this.getYAtUncheckedPointIndex(e)-n)*(this.getYAtUncheckedPointIndex(i)-n)+(this.getZAtUncheckedPointIndex(e)-r)*(this.getZAtUncheckedPointIndex(i)-r)}dotProductIndexIndexXYAndZ(t,e,i){if(t<0||t>=this.length||e<0||e>=this.length)return;const s=this.getXAtUncheckedPointIndex(t),n=this.getYAtUncheckedPointIndex(t),r=this.getZAtUncheckedPointIndex(t);return(this.getXAtUncheckedPointIndex(e)-s)*(i.x-s)+(this.getYAtUncheckedPointIndex(e)-n)*(i.y-n)+(this.getZAtUncheckedPointIndex(e)-r)*(i.z-r)}crossProductIndexIndexXYAndZ(t,e,i,s){if(t<0||t>=this.length||e<0||e>=this.length)return;const n=this.getXAtUncheckedPointIndex(t),r=this.getYAtUncheckedPointIndex(t),o=this.getZAtUncheckedPointIndex(t);return $.createCrossProduct(this.getXAtUncheckedPointIndex(e)-n,this.getYAtUncheckedPointIndex(e)-r,this.getZAtUncheckedPointIndex(e)-o,i.x-n,i.y-r,i.z-o,s)}distanceSquaredIndexXYAndZ(t,e){if(!(t<0||t>=this.length))return Q.hypotenuseSquaredXYZ(e.x-this.getXAtUncheckedPointIndex(t),e.y-this.getYAtUncheckedPointIndex(t),e.z-this.getZAtUncheckedPointIndex(t))}cyclicIndex(t){return t%this.length}getRange(){const t=ut.createNull(),e=this.length,i=j.create();for(let s=0;s<e;s++)this.getPoint3dAtUncheckedPointIndex(s,i),t.extendPoint(i);return t}findOrderedDuplicates(t=Q.smallMetricDistance){const e=t*t,i=[];if(this.length>1)for(let t=0;t<this.length-1;){let s=t+1;for(;s<this.length;++s){const n=this.distanceSquaredIndexIndex(t,s);if(!(void 0!==n&&n<e))break;i.push(s)}t=s}return i}linearCombination(t,e){const i=Math.min(this.length,t.length),s=e instanceof $?$.createZero(e):j.createZero(e);for(let e=0;e<i;++e)s.x+=t[e]*this.getXAtUncheckedPointIndex(e),s.y+=t[e]*this.getYAtUncheckedPointIndex(e),s.z+=t[e]*this.getZAtUncheckedPointIndex(e);return s}interpolateIndexIndex(t,e,i,s){if(!(t<0||t>=this.length||i<0||i>=this.length))return j.create(Q.interpolate(this.getXAtUncheckedPointIndex(t),e,this.getXAtUncheckedPointIndex(i)),Q.interpolate(this.getYAtUncheckedPointIndex(t),e,this.getYAtUncheckedPointIndex(i)),Q.interpolate(this.getZAtUncheckedPointIndex(t),e,this.getZAtUncheckedPointIndex(i)),s)}get points(){return new et(this)}getArray(){const t=[];for(const e of this.points)t.push(e);return t}front(t){if(0!==this.length)return this.getPoint3dAtUncheckedPointIndex(0,t)}back(t){if(0!==this.length)return this.getPoint3dAtUncheckedPointIndex(this.length-1,t)}almostEqualIndexIndex(t,e,i=Q.smallMetricDistance){if(!(t<0||t>=this.length||e<0||e>=this.length))return Q.isSameCoordinate(this.getXAtUncheckedPointIndex(t),this.getXAtUncheckedPointIndex(e),i)&&Q.isSameCoordinate(this.getYAtUncheckedPointIndex(t),this.getYAtUncheckedPointIndex(e),i)&&Q.isSameCoordinate(this.getZAtUncheckedPointIndex(t),this.getZAtUncheckedPointIndex(e),i)}}class st extends it{}class nt extends st{constructor(t=8,e){super(),this._data=new Float64Array(3*t),this._xyzInUse=0,this._xyzCapacity=t,this._growthFactor=void 0!==e&&e>=1?e:1.5}copyData(t,e,i){let s=void 0!==i?3*i:0;if(s<0&&(s=0),s>=this._data.length)return{count:0,offset:0};let n=void 0!==e?3*e:t.length;return n>0&&(n>t.length&&(n=t.length),s+n>this._data.length&&(n=this._data.length-s),n%3!=0&&(n-=n%3)),n<=0?{count:0,offset:0}:(n===t.length?this._data.set(t,s):t instanceof Float64Array?this._data.set(t.subarray(0,n),s):this._data.set(t.slice(0,n),s),{count:n/3,offset:s/3})}get length(){return this._xyzInUse}set length(t){this.resize(t,!0)}get float64Length(){return 3*this._xyzInUse}float64Data(){return this._data}ensureCapacity(t,e=!0){if(t>this._xyzCapacity){e&&(t*=this._growthFactor);const i=this._data;this._data=new Float64Array(3*t),this.copyData(i,this._xyzInUse),this._xyzCapacity=t}}resize(t,e){t>=0&&t<this._xyzInUse?this._xyzInUse=t:t>this._xyzInUse&&(this.ensureCapacity(t,!1),e&&this._data.fill(0,3*this._xyzInUse),this._xyzInUse=t)}clone(t){return t?(t.length!==this.length&&t.clear(),t.resize(this.length)):t=new nt(this.length),t.copyData(this._data,this.length),t._xyzInUse=this.length,t}static create(t,e){if(e)e.clear();else{const i="number"==typeof t[0]?t.length/3:t.length;e=new nt(i)}return e.pushFrom(t),e}static createArrayOfGrowableXYZArray(t){const e=new at;return ht.streamXYZ(t,e),e.claimArrayOfGrowableXYZArray()}push(t){this.pushXYZ(t.x,t.y,t.z)}pushAll(t){this.ensureCapacity(this._xyzInUse+t.length,!1);for(const e of t)this.push(e)}pushFrom(t){if(t instanceof j)this.pushXYZ(t.x,t.y,t.z);else if(t instanceof nt)this.pushFromGrowableXYZArray(t);else if(t instanceof H)this.pushXYZ(t.x,t.y,0);else if(Q.isNumberArray(t,4)||t instanceof Float64Array){const e=Math.trunc(t.length/3);this.ensureCapacity(this._xyzInUse+e,!1),this.copyData(t,e,this._xyzInUse),this._xyzInUse+=e}else if(Q.isNumberArray(t,3))this.pushXYZ(t[0],t[1],t[2]);else if(Q.isNumberArray(t,2))this.pushXYZ(t[0],t[1],0);else if(Array.isArray(t))for(const e of t)this.pushFrom(e);else if(j.isXYAndZ(t))this.pushXYZ(t.x,t.y,t.z);else if(j.isXAndY(t))this.pushXYZ(t.x,t.y,0);else if(t instanceof it){const e=t.length;this.ensureCapacity(this._xyzInUse+e,!1);for(let i=0;i<e;i++)this.pushXYZ(t.getXAtUncheckedPointIndex(i),t.getYAtUncheckedPointIndex(i),t.getZAtUncheckedPointIndex(i))}}pushWrap(t){if(this._xyzInUse>=t){this.ensureCapacity(this._xyzInUse+t,!1);for(let e=0;e<t;e++){const t=3*e;this.pushXYZ(this._data[t],this._data[t+1],this._data[t+2])}}}pushXYZ(t,e,i){this.ensureCapacity(this._xyzInUse+1);const s=3*this._xyzInUse;this._data[s]=t,this._data[s+1]=e,this._data[s+2]=i,this._xyzInUse++}shiftForward(t){if(t<=0)return;this.ensureCapacity(this._xyzInUse+t);const e=3*t,i=3*this._xyzInUse;this._data.copyWithin(e,0,i),this._xyzInUse+=t}pushFrontXYZ(t,e,i){this.shiftForward(1),this._data[0]=t,this._data[1]=e,this._data[2]=i}pushFront(t){this.pushFrontXYZ(t.x,t.y,t.z)}moveIndexToIndex(t,e){if(this.isIndexValid(t)&&this.isIndexValid(e)){let i=3*t,s=3*e;this._data[s++]=this._data[i++],this._data[s++]=this._data[i++],this._data[s]=this._data[i]}}pop(){this._xyzInUse>0&&this._xyzInUse--}isIndexValid(t){return!(t>=this._xyzInUse||t<0)}clear(){this._xyzInUse=0}getPoint3dAtUncheckedPointIndex(t,e){const i=3*t;return j.create(this._data[i],this._data[i+1],this._data[i+2],e)}getPoint2dAtUncheckedPointIndex(t,e){const i=3*t;return H.create(this._data[i],this._data[i+1],e)}getVector3dAtUncheckedVectorIndex(t,e){const i=3*t;return $.create(this._data[i],this._data[i+1],this._data[i+2],e)}getPoint3dAtCheckedPointIndex(t,e){if(this.isIndexValid(t)){const i=3*t;return j.create(this._data[i],this._data[i+1],this._data[i+2],e)}}getXAtUncheckedPointIndex(t){const e=3*t;return this._data[e]}getYAtUncheckedPointIndex(t){const e=3*t;return this._data[e+1]}getZAtUncheckedPointIndex(t){const e=3*t;return this._data[e+2]}getPoint2dAtCheckedPointIndex(t,e){if(this.isIndexValid(t)){const i=3*t;return H.create(this._data[i],this._data[i+1],e)}}getVector3dAtCheckedVectorIndex(t,e){if(this.isIndexValid(t)){const i=3*t;return $.create(this._data[i],this._data[i+1],this._data[i+2],e)}}transferFromGrowableXYZArray(t,e,i){if(this.isIndexValid(t)&&e.isIndexValid(i)){const s=3*t,n=3*i;return this._data[s]=e._data[n],this._data[s+1]=e._data[n+1],this._data[s+2]=e._data[n+2],!0}return!1}pushFromGrowableXYZArray(t,e){if(void 0===e){const e=t.length;return this.ensureCapacity(this.length+e,!1),this.copyData(t._data,e,this.length),this._xyzInUse+=e,e}if(t.isIndexValid(e)){const i=3*e;return this.pushXYZ(t._data[i],t._data[i+1],t._data[i+2]),1}return 0}setAtCheckedPointIndex(t,e){if(!this.isIndexValid(t))return!1;let i=3*t;return this._data[i++]=e.x,this._data[i++]=e.y,this._data[i]=e.z,!0}setXYZAtCheckedPointIndex(t,e,i,s){if(!this.isIndexValid(t))return!1;let n=3*t;return this._data[n++]=e,this._data[n++]=i,this._data[n]=s,!0}getPoint3dArray(){const t=3*this._xyzInUse,e=[],i=this._data;for(let s=0;s<t;s+=3)e.push(j.create(i[s],i[s+1],i[s+2]));return e}static multiplyTransformInPlace(t,e){if(Array.isArray(e))for(const i of e)i.multiplyTransformInPlace(t);else e.multiplyTransformInPlace(t)}multiplyTransformInPlace(t){const e=this._data,i=this.float64Length,s=t.matrix.coffs,n=t.origin,r=n.x,o=n.y,a=n.z;let c=0,l=0,h=0;for(let t=0;t+2<=i;t+=3)c=e[t],l=e[t+1],h=e[t+2],e[t]=s[0]*c+s[1]*l+s[2]*h+r,e[t+1]=s[3]*c+s[4]*l+s[5]*h+o,e[t+2]=s[6]*c+s[7]*l+s[8]*h+a}reverseInPlace(){const t=this.length;let e,i,s;const n=this._data;for(let r=0,o=t-1;r<o;r++,o--)e=3*r,i=3*o,s=n[e],n[e]=n[i],n[i]=s,e++,i++,s=n[e],n[e]=n[i],n[i]=s,e++,i++,s=n[e],n[e]=n[i],n[i]=s}multiplyMatrix3dInPlace(t){const e=this._data,i=this.float64Length,s=t.coffs;let n=0,r=0,o=0;for(let t=0;t+2<=i;t+=3)n=e[t],r=e[t+1],o=e[t+2],e[t]=s[0]*n+s[1]*r+s[2]*o,e[t+1]=s[3]*n+s[4]*r+s[5]*o,e[t+2]=s[6]*n+s[7]*r+s[8]*o}multiplyAndRenormalizeMatrix3dInverseTransposeInPlace(t){const e=this._data,i=this.float64Length;if(!t.computeCachedInverse(!0))return!1;const s=t.inverseCoffs,n=Q.smallFloatingPoint;let r,o,a,c,l,h=0,d=0,u=0,f=0;for(let t=0;t+2<=i;t+=3)h=e[t],d=e[t+1],u=e[t+2],r=s[0]*h+s[3]*d+s[6]*u,o=s[1]*h+s[4]*d+s[7]*u,a=s[2]*h+s[5]*d+s[8]*u,l=r*r+o*o+a*a,l<n?(r=h,o=d,a=u,f++):Math.abs(l-1)>n&&(c=1/Math.sqrt(l),r*=c,o*=c,a*=c),e[t]=r,e[t+1]=o,e[t+2]=a;return 0===f}multiplyMatrix4dAndQuietRenormalizeMatrix4d(t){const e=this._data,i=this.float64Length,s=j.create();for(let n=0;n+2<=i;n+=3)t.multiplyXYZWQuietRenormalize(e[n],e[n+1],e[n+2],1,s),e[n]=s.x,e[n+1]=s.y,e[n+2]=s.z}tryTransformInverseInPlace(t){const e=this._data,i=this.float64Length,s=t.matrix;s.computeCachedInverse(!0);const n=s.inverseCoffs;if(!n)return!1;const r=t.origin,o=r.x,a=r.y,c=r.z;let l=0,h=0,d=0;for(let t=0;t+2<i;t+=3)l=e[t]-o,h=e[t+1]-a,d=e[t+2]-c,e[t]=n[0]*l+n[1]*h+n[2]*d,e[t+1]=n[3]*l+n[4]*h+n[5]*d,e[t+2]=n[6]*l+n[7]*h+n[8]*d;return!0}extendRange(t,e){const i=this.float64Length,s=this._data;if(e)for(let n=0;n+2<i;n+=3)t.extendTransformedXYZ(e,s[n],s[n+1],s[n+2]);else for(let e=0;e+2<i;e+=3)t.extendXYZ(s[e],s[e+1],s[e+2])}getRange(t){const e=ut.createNull();return this.extendRange(e,t),e}setRange(t,e){t.setNull(),this.extendRange(t,e)}sumLengths(){let t=0;const e=3*(this._xyzInUse-1),i=this._data;for(let s=0;s<e;s+=3)t+=Q.hypotenuseXYZ(i[s+3]-i[s],i[s+4]-i[s+1],i[s+5]-i[s+2]);return t}scaleInPlace(t){if(this._data){const e=this.float64Length;for(let i=0;i<e;i++)this._data[i]=this._data[i]*t}}isCloseToPlane(t,e=Q.smallMetricDistance){const i=3*this._xyzInUse,s=this._data;for(let n=0;n<i;n+=3)if(Math.abs(t.altitudeXYZ(s[n],s[n+1],s[n+2]))>e)return!1;return!0}forceClosure(t=Q.smallMetricDistance){const e=this.distanceIndexIndex(0,this.length-1);if(void 0===e);else if(e>t)this.pushXYZ(this._data[0],this._data[1],this._data[2]);else if(e>0){const t=this._data.length-3;for(let e=0;e<3;e++)this._data[t+e]=this._data[e]}}interpolate(t,e,i,s){if(this.isIndexValid(t)&&this.isIndexValid(i)){const n=1-e,r=this._data;return t*=3,i*=3,j.create(n*r[t]+e*r[i],n*r[t+1]+e*r[i+1],n*r[t+2]+e*r[i+2],s)}}pushInterpolatedFromGrowableXYZArray(t,e,i,s){if(t.isIndexValid(e)&&t.isIndexValid(s)){const n=1-i,r=t._data;e*=3,s*=3,this.pushXYZ(n*r[e]+i*r[s],n*r[e+1]+i*r[s+1],n*r[e+2]+i*r[s+2])}}areaXY(){let t=0;const e=3*this._xyzInUse;if(e>6){const i=this._data[e-3],s=this._data[e-2];let n=this._data[0]-i,r=this._data[1]-s,o=0,a=0;for(let c=3;c<e;c+=3,n=o,r=a)o=this._data[c]-i,a=this._data[c+1]-s,t+=Q.crossProductXYXY(n,r,o,a)}return.5*t}vectorIndexIndex(t,e,i){if(!this.isIndexValid(t)||!this.isIndexValid(e))return;const s=this._data;return t*=3,e*=3,$.create(s[e]-s[t],s[e+1]-s[t+1],s[e+2]-s[t+2],i)}vectorXYAndZIndex(t,e,i){if(this.isIndexValid(e)){const s=this._data;return e*=3,$.create(s[e]-t.x,s[e+1]-t.y,s[e+2]-t.z,i)}}crossProductIndexIndexIndex(t,e,i,s){if(this.isIndexValid(t)&&this.isIndexValid(e)&&this.isIndexValid(i)){const n=3*t,r=3*e,o=3*i,a=this._data;return Q.crossProductXYZXYZ(a[r]-a[n],a[r+1]-a[n+1],a[r+2]-a[n+2],a[o]-a[n],a[o+1]-a[n+1],a[o+2]-a[n+2],s)}}evaluateUncheckedIndexDotProductXYZ(t,e,i,s){const n=3*t,r=this._data;return r[n]*e+r[n+1]*i+r[n+2]*s}evaluateUncheckedIndexPlaneAltitude(t,e){const i=3*t,s=this._data;return e.altitudeXYZ(s[i],s[i+1],s[i+2])}accumulateCrossProductIndexIndexIndex(t,e,i,s){if(this.isIndexValid(t)&&this.isIndexValid(e)&&this.isIndexValid(i)){const n=3*t,r=3*e,o=3*i,a=this._data;s.addCrossProductToTargetsInPlace(a[n],a[n+1],a[n+2],a[r],a[r+1],a[r+2],a[o],a[o+1],a[o+2])}}accumulateScaledXYZ(t,e,i){if(this.isIndexValid(t)){const s=3*t,n=this._data;i.x+=e*n[s],i.y+=e*n[s+1],i.z+=e*n[s+2]}}crossProductXYAndZIndexIndex(t,e,i,s){if(this.isIndexValid(e)&&this.isIndexValid(i)){const n=3*e,r=3*i,o=this._data;return Q.crossProductXYZXYZ(o[n]-t.x,o[n+1]-t.y,o[n+2]-t.z,o[r]-t.x,o[r+1]-t.y,o[r+2]-t.z,s)}}distanceIndexToPoint(t,e){if(this.isIndexValid(t)){const i=3*t;return Q.hypotenuseXYZ(e.x-this._data[i],e.y-this._data[i+1],e.z-this._data[i+2])}}distanceSquaredIndexIndex(t,e){if(this.isIndexValid(t)&&this.isIndexValid(e)){const i=3*t,s=3*e;return Q.hypotenuseSquaredXYZ(this._data[s]-this._data[i],this._data[s+1]-this._data[i+1],this._data[s+2]-this._data[i+2])}}distanceIndexIndex(t,e){if(this.isIndexValid(t)&&this.isIndexValid(e)){const i=3*t,s=3*e;return Q.hypotenuseXYZ(this._data[s]-this._data[i],this._data[s+1]-this._data[i+1],this._data[s+2]-this._data[i+2])}}static distanceBetweenPointsIn2Arrays(t,e,i,s){if(t.isIndexValid(e)&&i.isIndexValid(s)){const n=3*e,r=3*s;return Q.hypotenuseXYZ(i._data[r]-t._data[n],i._data[r+1]-t._data[n+1],i._data[r+2]-t._data[n+2])}}static isAlmostEqual(t,e){if(t&&e){if(t.length!==e.length)return!1;for(let i=0;i<t.length;i++)if(!t.getPoint3dAtUncheckedPointIndex(i).isAlmostEqual(e.getPoint3dAtUncheckedPointIndex(i)))return!1;return!0}return!t&&!e}sortIndicesLexical(){const t=this._xyzInUse,e=new Uint32Array(t);for(let i=0;i<t;i++)e[i]=i;return e.sort(((t,e)=>this.compareLexicalBlock(t,e))),e}compareLexicalBlock(t,e){let i=0,s=0;for(let n=0;n<3;n++){if(i=this._data[3*t+n],s=this._data[3*e+n],i>s)return 1;if(i<s)return-1}return t-e}component(t,e){return this._data[3*t+e]}addSteppedPoints(t,e,i,s){const n=t._data;let r=3*e;const o=3*t.length;let a=0;for(this.ensureCapacity(this._xyzInUse+s,!1);r>=0&&r+2<o&&a<s;)this.pushXYZ(n[r],n[r+1],n[r+2]),r+=3*i,a++}static distanceRangeBetweenCorrespondingPoints(t,e){const i=t._data,s=e._data,n=Math.min(t.length,e.length);let r,o=0;const a=ft.createNull();for(;o<n;)r=3*o,a.extendX(Q.hypotenuseXYZ(i[r]-s[r],i[r+1]-s[r+1],i[r+2]-s[r+2])),o++;return a}static removeClosure(t,e=Q.smallMetricDistance){for(;t.length>1&&t.distanceIndexIndex(0,t.length-1)<e;)t.pop()}fillLocalXYTriangleFrame(t,e,i,s){if(this.isIndexValid(t)&&this.isIndexValid(e)&&this.isIndexValid(i)){let n=3*t;const r=this._data,o=r[n++],a=r[n++],c=r[n++];n=3*e;const l=r[n++]-o,h=r[n++]-a,d=r[n++]-c;n=3*i;const u=r[n++]-o,f=r[n++]-a,g=r[n++]-c;return(s=pt.createRowValues(l,u,0,o,h,f,0,a,d,g,1,c,s)).computeCachedInverse()?s:void 0}}mapComponent(t,e){const i=this._data.length;let s;for(let n=0;n+2<i;n+=3)s=e(this._data[n],this._data[n+1],this._data[n+2]),this._data[n+t]=s}}class rt{startChain(t,e){}handleXYZ(t,e,i){}endChain(t,e){}}class ot extends rt{handleXYZ(t,e,i){void 0!==this._x0&&this.handleXYZXYZ(this._x0,this._y0,this._z0,t,e,i),this._x0=t,this._y0=e,this._z0=i}startChain(t,e){this._x0=this._y0=this._z0=void 0}handleXYZXYZ(t,e,i,s,n,r){}}class at extends rt{startChain(t,e){this._currentData=void 0}handleXYZ(t,e,i){this._currentData||(this._currentData=new nt),this._currentData.pushXYZ(t,e,i)}endChain(t,e){void 0!==this._currentData&&(void 0===this._pointArrays&&(this._pointArrays=[]),this._pointArrays.push(this._currentData),this._currentData=void 0)}claimArrayOfGrowableXYZArray(){const t=this._pointArrays;return this._pointArrays=void 0,t}}class ct extends rt{constructor(){super(...arguments),this._range=ut.createNull()}handleXYZ(t,e,i){this._range||(this._range=ut.createNull()),this._range.extendXYZ(t,e,i)}claimResult(){const t=this._range;return this._range=void 0,t||ut.createNull()}}class lt{constructor(t){this._xyzFunction=t,this._resultStack=[],this._resultStack.push([])}startChain(t,e){this._resultStack.push([])}handleXYZ(t,e,i){this._resultStack[this._resultStack.length-1].push(this._xyzFunction(t,e,i))}endChain(t,e){const i=this._resultStack[this._resultStack.length-1];this._resultStack.pop(),this._resultStack[this._resultStack.length-1].push(i)}claimResult(){const t=this._resultStack[0];return 1===t.length?t[0]:t}}class ht{static streamXYZ(t,e){let i=0;if(Array.isArray(t))if(t.length>0&&j.isAnyImmediatePointType(t[0])){e.startChain(t,!0);for(const s of t){const t=j.accessX(s),n=j.accessY(s),r=j.accessZ(s,0);void 0!==t&&void 0!==n&&e.handleXYZ(t,n,r),i++}e.endChain(t,!0)}else{e.startChain(t,!1);for(const s of t)i+=this.streamXYZ(s,e);e.endChain(t,!1)}else if(t instanceof it){e.startChain(t,!0);const s=ht._workPoint=j.create(0,0,0,ht._workPoint);for(let n=0;n<t.length;n++)t.getPoint3dAtCheckedPointIndex(n,s),i++,e.handleXYZ(s.x,s.y,s.z);e.endChain(t,!0)}return i}}class dt{static npcScaleFactor(t,e){return e<=t?0:1/(e-t)}static isExtremeValue(t){return Math.abs(t)>=dt._EXTREME_POSITIVE}static isExtremePoint3d(t){return dt.isExtremeValue(t.x)||dt.isExtremeValue(t.y)||dt.isExtremeValue(t.z)}static isExtremePoint2d(t){return dt.isExtremeValue(t.x)||dt.isExtremeValue(t.y)}static rangeToRangeAbsoluteDistance(t,e,i,s){return e<t||s<i?dt._EXTREME_POSITIVE:s<t?t-s:s<=e||i<=e?0:i-e}static coordinateToRangeAbsoluteDistance(t,e,i){return i<e?dt._EXTREME_POSITIVE:t<e?e-t:t>i?t-i:0}static multiplyIfPositive(t,e,i=0){return t>0?e*t:i}}dt._EXTREME_POSITIVE=1e200,dt._EXTREME_NEGATIVE=-1e200;class ut extends dt{setNull(){this.low.x=dt._EXTREME_POSITIVE,this.low.y=dt._EXTREME_POSITIVE,this.low.z=dt._EXTREME_POSITIVE,this.high.x=dt._EXTREME_NEGATIVE,this.high.y=dt._EXTREME_NEGATIVE,this.high.z=dt._EXTREME_NEGATIVE}freeze(){return this.low.freeze(),this.high.freeze(),Object.freeze(this)}static toFloat64Array(t){return Float64Array.of(t.low.x,t.low.y,t.low.z,t.high.x,t.high.y,t.high.z)}toFloat64Array(){return ut.toFloat64Array(this)}static fromFloat64Array(t){if(6!==t.length)throw new Error("invalid array");return new this(t[0],t[1],t[2],t[3],t[4],t[5])}static fromArrayBuffer(t){return this.fromFloat64Array(new Float64Array(t))}constructor(t=dt._EXTREME_POSITIVE,e=dt._EXTREME_POSITIVE,i=dt._EXTREME_POSITIVE,s=dt._EXTREME_NEGATIVE,n=dt._EXTREME_NEGATIVE,r=dt._EXTREME_NEGATIVE){super(),this.low=j.create(t,e,i),this.high=j.create(s,n,r)}isAlmostEqual(t,e){return this.low.isAlmostEqual(t.low,e)&&this.high.isAlmostEqual(t.high,e)||this.isNull&&t.isNull}setFrom(t){this.low.setFrom(t.low),this.high.setFrom(t.high)}static createFrom(t,e){return e?(e.setFrom(t),e):this.createXYZXYZOrCorrectToNull(t.low.x,t.low.y,t.low.z,t.high.x,t.high.y,t.high.z,e)}setFromJSON(t){if(!t)return;if(this.setNull(),Array.isArray(t)){const e=j.create();for(const i of t)e.setFromJSON(i),this.extendPoint(e);return}const e=j.fromJSON(t.low),i=j.fromJSON(t.high);dt.isExtremePoint3d(e)||dt.isExtremePoint3d(i)||(this.extendPoint(e),this.extendPoint(i))}toJSON(){return{low:this.low.toJSON(),high:this.high.toJSON()}}static fromJSON(t){const e=new this;return e.setFromJSON(t),e}setDirect(t,e,i,s,n,r,o){this.low.x=t,this.low.y=e,this.low.z=i,this.high.x=s,this.high.y=n,this.high.z=r,o&&(this.low.x>this.high.x||this.low.y>this.high.y||this.low.z>this.high.z)&&this.setNull()}clone(t){return(t=t||new this.constructor).setDirect(this.low.x,this.low.y,this.low.z,this.high.x,this.high.y,this.high.z,!1),t}cloneTranslated(t,e){return e=e||new this.constructor,this.isNull||e.setDirect(this.low.x+t.x,this.low.y+t.y,this.low.z+t.z,this.high.x+t.x,this.high.y+t.y,this.high.z+t.z,!1),e}static createNull(t){return(t=t||new this).setNull(),t}extend(...t){let e;for(e of t)this.extendPoint(e)}static create(...t){const e=ut.createNull();let i;for(i of t)e.extendPoint(i);return e}static createFromVariantData(t){const e=new ct;return ht.streamXYZ(t,e),e.claimResult()}static createTransformed(t,...e){const i=this.createNull();let s;for(s of e)i.extendTransformedXYZ(t,s.x,s.y,s.z);return i}static createTransformedArray(t,e){const i=this.createNull();return i.extendArray(e,t),i}static createInverseTransformedArray(t,e){const i=this.createNull();return i.extendInverseTransformedArray(e,t),i}setXYZ(t,e,i){this.low.x=this.high.x=t,this.low.y=this.high.y=e,this.low.z=this.high.z=i}static createXYZ(t,e,i,s){return(s=s||new this).setDirect(t,e,i,t,e,i,!1),s}static createXYZXYZ(t,e,i,s,n,r,o){return(o=o||new this).setDirect(Math.min(t,s),Math.min(e,n),Math.min(i,r),Math.max(t,s),Math.max(e,n),Math.max(i,r),!1),o}static createXYZXYZOrCorrectToNull(t,e,i,s,n,r,o){return o=o||new this,t>s||e>n||i>r?this.createNull(o):(o.setDirect(Math.min(t,s),Math.min(e,n),Math.min(i,r),Math.max(t,s),Math.max(e,n),Math.max(i,r),!0),o)}static createRange2d(t,e=0,i){const s=i||new this;return s.setNull(),s.extendXYZ(t.low.x,t.low.y,e),s.extendXYZ(t.high.x,t.high.y,e),s}static createArray(t,e){let i;for(i of((e=e||new this).setNull(),t))e.extendPoint(i);return e}extendArray(t,e){if(Array.isArray(t))if(e)for(const i of t)this.extendTransformedXYZ(e,i.x,i.y,i.z);else for(const e of t)this.extendXYZ(e.x,e.y,e.z);else if(e)for(let i=0;i<t.length;i++)this.extendTransformedXYZ(e,t.getXAtUncheckedPointIndex(i),t.getYAtUncheckedPointIndex(i),t.getZAtUncheckedPointIndex(i));else for(let e=0;e<t.length;e++)this.extendXYZ(t.getXAtUncheckedPointIndex(e),t.getYAtUncheckedPointIndex(e),t.getZAtUncheckedPointIndex(e))}extendInverseTransformedArray(t,e){if(Array.isArray(t))for(const i of t)this.extendInverseTransformedXYZ(e,i.x,i.y,i.z);else for(let i=0;i<t.length;i++)this.extendInverseTransformedXYZ(e,t.getXAtUncheckedPointIndex(i),t.getYAtUncheckedPointIndex(i),t.getZAtUncheckedPointIndex(i))}extendTransformedXYZ(t,e,i,s){const n=t.origin,r=t.matrix.coffs;this.extendXYZ(n.x+r[0]*e+r[1]*i+r[2]*s,n.y+r[3]*e+r[4]*i+r[5]*s,n.z+r[6]*e+r[7]*i+r[8]*s)}extendTransformedXYZW(t,e,i,s,n){const r=t.origin,o=t.matrix.coffs;this.extendXYZW(r.x*n+o[0]*e+o[1]*i+o[2]*s,r.y*n+o[3]*e+o[4]*i+o[5]*s,r.z*n+o[6]*e+o[7]*i+o[8]*s,n)}extendInverseTransformedXYZ(t,e,i,s){const n=t.origin;if(!t.matrix.computeCachedInverse(!0))return!1;const r=t.matrix.inverseCoffs,o=e-n.x,a=i-n.y,c=s-n.z;return this.extendXYZ(r[0]*o+r[1]*a+r[2]*c,r[3]*o+r[4]*a+r[5]*c,r[6]*o+r[7]*a+r[8]*c),!0}extendTransformTransformedXYZ(t,e,i,s,n){const r=e.origin,o=e.matrix.coffs;this.extendTransformedXYZ(t,r.x+o[0]*i+o[1]*s+o[2]*n,r.y+o[3]*i+o[4]*s+o[5]*n,r.z+o[6]*i+o[7]*s+o[8]*n)}get isNull(){return this.high.x<this.low.x||this.high.y<this.low.y||this.high.z<this.low.z}static isNull(t){return t.high.x<t.low.x||t.high.y<t.low.y||t.high.z<t.low.z}get isSinglePoint(){return this.high.x===this.low.x&&this.high.y===this.low.y&&this.high.z===this.low.z}get center(){return this.low.interpolate(.5,this.high)}get xLow(){return this.low.x}get yLow(){return this.low.y}get zLow(){return this.low.z}get xHigh(){return this.high.x}get yHigh(){return this.high.y}get zHigh(){return this.high.z}xLength(){const t=this.high.x-this.low.x;return t>0?t:0}yLength(){const t=this.high.y-this.low.y;return t>0?t:0}zLength(){const t=this.high.z-this.low.z;return t>0?t:0}maxLength(){return Math.max(this.xLength(),this.yLength(),this.zLength())}diagonal(t){return this.low.vectorTo(this.high,t)}diagonalFractionToPoint(t,e){return this.low.interpolate(t,this.high,e)}fractionToPoint(t,e,i=0,s){return this.low.interpolateXYZ(t,e,i,this.high,s)}localXYZToWorld(t,e,i,s){if(!this.isNull)return this.low.interpolateXYZ(t,e,i,this.high,s)}localToWorld(t,e){return this.localXYZToWorld(t.x,t.y,t.z,e)}localToWorldArrayInPlace(t){if(this.isNull)return!1;for(const e of t)this.low.interpolateXYZ(e.x,e.y,e.z,this.high,e);return!1}worldToLocal(t,e){const i=dt.npcScaleFactor(this.low.x,this.high.x),s=dt.npcScaleFactor(this.low.y,this.high.y),n=dt.npcScaleFactor(this.low.z,this.high.z);if(0!==i&&0!==s&&0!==n)return j.create((t.x-this.low.x)*i,(t.y-this.low.y)*s,(t.z-this.low.z)*n,e)}worldToLocalArrayInPlace(t){const e=dt.npcScaleFactor(this.low.x,this.high.x),i=dt.npcScaleFactor(this.low.y,this.high.y),s=dt.npcScaleFactor(this.low.z,this.high.z);if(0===e||0===i||0===s)return!1;for(const n of t)j.create((n.x-this.low.x)*e,(n.y-this.low.y)*i,(n.z-this.low.z)*s,n);return!0}corners(t){return void 0!==t&&t.length>=8?(t[0].set(this.low.x,this.low.y,this.low.z),t[1].set(this.high.x,this.low.y,this.low.z),t[2].set(this.low.x,this.high.y,this.low.z),t[3].set(this.high.x,this.high.y,this.low.z),t[4].set(this.low.x,this.low.y,this.high.z),t[5].set(this.high.x,this.low.y,this.high.z),t[6].set(this.low.x,this.high.y,this.high.z),t[7].set(this.high.x,this.high.y,this.high.z),t.length=8,t):[j.create(this.low.x,this.low.y,this.low.z),j.create(this.high.x,this.low.y,this.low.z),j.create(this.low.x,this.high.y,this.low.z),j.create(this.high.x,this.high.y,this.low.z),j.create(this.low.x,this.low.y,this.high.z),j.create(this.high.x,this.low.y,this.high.z),j.create(this.low.x,this.high.y,this.high.z),j.create(this.high.x,this.high.y,this.high.z)]}static faceCornerIndices(t){return 0===t?[0,4,6,2]:1===t?[1,3,7,5]:2===t?[0,1,5,4]:3===t?[3,2,6,7]:4===t?[0,2,3,1]:[4,5,7,6]}rectangleXY(t=0,e=!0,i=!0){if(this.isNull)return;const s=[this.fractionToPoint(0,0,t),this.fractionToPoint(1,0,t),this.fractionToPoint(1,1,t),this.fractionToPoint(0,1,t)];return i&&s.push(s[0].clone()),e||s.reverse(),s}maxAbs(){return this.isNull?0:Math.max(this.low.maxAbs(),this.high.maxAbs())}get isAlmostZeroX(){return Q.isSmallMetricDistance(this.xLength())}get isAlmostZeroY(){return Q.isSmallMetricDistance(this.yLength())}get isAlmostZeroZ(){return Q.isSmallMetricDistance(this.zLength())}containsXYZ(t,e,i){return t>=this.low.x&&e>=this.low.y&&i>=this.low.z&&t<=this.high.x&&e<=this.high.y&&i<=this.high.z}containsXY(t,e){return t>=this.low.x&&e>=this.low.y&&t<=this.high.x&&e<=this.high.y}containsPoint(t){return this.containsXYZ(t.x,t.y,t.z)}containsPointXY(t){return t.x>=this.low.x&&t.y>=this.low.y&&t.x<=this.high.x&&t.y<=this.high.y}containsRange(t){return t.low.x>=this.low.x&&t.low.y>=this.low.y&&t.low.z>=this.low.z&&t.high.x<=this.high.x&&t.high.y<=this.high.y&&t.high.z<=this.high.z}intersectsRange(t){return!(this.low.x>t.high.x||this.low.y>t.high.y||this.low.z>t.high.z||t.low.x>this.high.x||t.low.y>this.high.y||t.low.z>this.high.z)}intersectsRangeXY(t){return!(this.low.x>t.high.x||this.low.y>t.high.y||t.low.x>this.high.x||t.low.y>this.high.y)}distanceToPoint(t){return this.isNull?dt._EXTREME_POSITIVE:Math.min(Q.hypotenuseXYZ(dt.coordinateToRangeAbsoluteDistance(t.x,this.low.x,this.high.x),dt.coordinateToRangeAbsoluteDistance(t.y,this.low.y,this.high.y),dt.coordinateToRangeAbsoluteDistance(t.z,this.low.z,this.high.z)),dt._EXTREME_POSITIVE)}distanceToRange(t){return Math.min(Q.hypotenuseXYZ(dt.rangeToRangeAbsoluteDistance(this.low.x,this.high.x,t.low.x,t.high.x),dt.rangeToRangeAbsoluteDistance(this.low.y,this.high.y,t.low.y,t.high.y),dt.rangeToRangeAbsoluteDistance(this.low.z,this.high.z,t.low.z,t.high.z)),dt._EXTREME_POSITIVE)}extendXYZ(t,e,i){t<this.low.x&&(this.low.x=t),t>this.high.x&&(this.high.x=t),e<this.low.y&&(this.low.y=e),e>this.high.y&&(this.high.y=e),i<this.low.z&&(this.low.z=i),i>this.high.z&&(this.high.z=i)}extendInterpolated(t,e,i){if(e<.5)this.extendXYZ(t.x+e*(i.x-t.x),t.y+e*(i.y-t.y),t.z+e*(i.z-t.z));else{const s=1-e;this.extendXYZ(i.x+s*(t.x-i.x),i.y+s*(t.y-i.y),i.z+s*(t.z-i.z))}}extendXOnly(t){t<this.low.x&&(this.low.x=t),t>this.high.x&&(this.high.x=t)}extendYOnly(t){t<this.low.y&&(this.low.y=t),t>this.high.y&&(this.high.y=t)}extendZOnly(t){t<this.low.z&&(this.low.z=t),t>this.high.z&&(this.high.z=t)}extendSingleAxis(t,e){e===p.X&&this.extendXOnly(t),e===p.Y&&this.extendYOnly(t),e===p.Z&&this.extendZOnly(t)}extendXYZW(t,e,i,s){Q.isSmallMetricDistance(s)||this.extendXYZ(t/s,e/s,i/s)}extendPoint(t,e){e?this.extendTransformedXYZ(e,t.x,t.y,t.z):this.extendXYZ(t.x,t.y,t.z)}extendTransformedPoint(t,e){this.extendTransformedXYZ(t,e.x,e.y,e.z)}extendRange(t){ut.isNull(t)||(this.extendXYZ(t.low.x,t.low.y,t.low.z),this.extendXYZ(t.high.x,t.high.y,t.high.z))}extendWhenLarger(t,e){ut.isNull(t)||ut.isNull(this)||(this.high.x+=dt.multiplyIfPositive(this.high.x-t.high.x,e),this.high.y+=dt.multiplyIfPositive(this.high.y-t.high.y,e),this.high.z+=dt.multiplyIfPositive(this.high.z-t.high.z,e),this.low.x-=dt.multiplyIfPositive(t.low.x-this.low.x,e),this.low.y-=dt.multiplyIfPositive(t.low.y-this.low.y,e),this.low.z-=dt.multiplyIfPositive(t.low.z-this.low.z,e))}intersect(t,e){return this.intersectsRange(t)?ut.createXYZXYZOrCorrectToNull(Math.max(this.low.x,t.low.x),Math.max(this.low.y,t.low.y),Math.max(this.low.z,t.low.z),Math.min(this.high.x,t.high.x),Math.min(this.high.y,t.high.y),Math.min(this.high.z,t.high.z),e):ut.createNull(e)}union(t,e){return this.isNull?t.clone(e):t.isNull?this.clone(e):ut.createXYZXYZOrCorrectToNull(Math.min(this.low.x,t.low.x),Math.min(this.low.y,t.low.y),Math.min(this.low.z,t.low.z),Math.max(this.high.x,t.high.x),Math.max(this.high.y,t.high.y),Math.max(this.high.z,t.high.z),e)}scaleAboutCenterInPlace(t){if(!this.isNull){t=Math.abs(t);const e=.5*(this.low.x+this.high.x),i=.5*(this.low.y+this.high.y),s=.5*(this.low.z+this.high.z);this.high.x=Q.interpolate(e,t,this.high.x),this.high.y=Q.interpolate(i,t,this.high.y),this.high.z=Q.interpolate(s,t,this.high.z),this.low.x=Q.interpolate(e,t,this.low.x),this.low.y=Q.interpolate(i,t,this.low.y),this.low.z=Q.interpolate(s,t,this.low.z)}}expandInPlace(t){this.setDirect(this.low.x-t,this.low.y-t,this.low.z-t,this.high.x+t,this.high.y+t,this.high.z+t,!0)}getLocalToWorldTransform(t){return pt.createOriginAndMatrix(j.create(this.low.x,this.low.y,this.low.z),xt.createRowValues(this.high.x-this.low.x,0,0,0,this.high.y-this.low.y,0,0,0,this.high.z-this.low.z),t)}getNpcToWorldRangeTransform(t){const e=this.getLocalToWorldTransform(t),i=e.matrix;return 0===i.coffs[0]&&(i.coffs[0]=1),0===i.coffs[4]&&(i.coffs[4]=1),0===i.coffs[8]&&(i.coffs[8]=1),e}ensureMinLengths(t=.001){let e=(t-this.xLength())/2;e>0&&(this.low.x-=e,this.high.x+=e),e=(t-this.yLength())/2,e>0&&(this.low.y-=e,this.high.y+=e),e=(t-this.zLength())/2,e>0&&(this.low.z-=e,this.high.z+=e)}}class ft extends dt{setNull(){this.low=dt._EXTREME_POSITIVE,this.high=dt._EXTREME_NEGATIVE}setDirect(t,e,i=!1){this.low=t,this.high=e,i&&t>e&&this.setNull()}constructor(t=dt._EXTREME_POSITIVE,e=dt._EXTREME_NEGATIVE){super(),this.low=t,this.high=e,this.setDirect(t,e)}isAlmostEqual(t){return Q.isSameCoordinate(this.low,t.low)&&Q.isSameCoordinate(this.high,t.high)||this.isNull&&t.isNull}setFrom(t){this.low=t.low,this.high=t.high}setFromJSON(t){if(this.setNull(),Array.isArray(t)){let e;for(e of t)Number.isFinite(e)&&this.extendX(e)}else void 0!==t.low&&Number.isFinite(t.low)&&void 0!==t.high&&Number.isFinite(t.high)&&(this.extendX(t.low),this.extendX(t.high))}static fromJSON(t){const e=new this;return t&&e.setFromJSON(t),e}toJSON(){return this.isNull?new Array:[this.low,this.high]}clone(t){return(t=t||new this.constructor).setDirect(this.low,this.high),t}static createFrom(t,e){return(e=e||new this).setDirect(t.low,t.high),e}static createNull(t){return(t=t||new this).setNull(),t}cloneTranslated(t,e){return(e=e||this.clone()).isNull||(e.low+=t,e.high+=t),e}setX(t){this.low=this.high=t}static createX(t,e){return(e=e||new this).setDirect(t,t),e}setXXUnordered(t,e){t<=e?(this.low=t,this.high=e):(this.low=e,this.high=t)}get isExact01(){return 0===this.low&&1===this.high}static createXX(t,e,i){return(i=i||new this).setDirect(Math.min(t,e),Math.max(t,e)),i}static createXXOrCorrectToNull(t,e,i){return e<t?ft.createNull(i):((i=i||new this).setDirect(Math.min(t,e),Math.max(t,e)),i)}static createArray(t,e){let i;for(i of(e=e||new this,t))e.extendX(i);return e}extendArray(t){let e;for(e of t)this.extendX(e)}extendArraySubset(t,e,i){const s=e+i;for(let i=e;i<s;i++)this.extendX(t[i])}get isNull(){return this.high<this.low}get isSinglePoint(){return this.high===this.low}length(){const t=this.high-this.low;return t>0?t:0}fractionToPoint(t){return Q.interpolate(this.low,t,this.high)}maxAbs(){return this.isNull?0:Math.max(Math.abs(this.low),Math.abs(this.high))}get isAlmostZeroLength(){return Q.isSmallMetricDistance(this.length())}containsX(t){return t>=this.low&&t<=this.high}containsXOpen(t){return t>this.low&&t<this.high}containsRange(t){return t.low>=this.low&&t.high<=this.high}intersectsRange(t){return!(this.low>t.high||t.low>this.high)}intersectRangeXXInPlace(t,e){e<t||e<this.low||t>this.high?this.setNull():(e<this.high&&(this.high=e),t>this.low&&(this.low=t))}distanceToRange(t){return dt.rangeToRangeAbsoluteDistance(this.low,this.high,t.low,t.high)}distanceToX(t){return this.isNull?dt._EXTREME_POSITIVE:dt.coordinateToRangeAbsoluteDistance(t,this.low,this.high)}extendX(t){t<this.low&&(this.low=t),t>this.high&&(this.high=t)}extendRange(t){t.isNull||(this.extendX(t.low),this.extendX(t.high))}extendLow(t){return!!(this.isNull||t<this.low)&&(this.low=t,!0)}extendHigh(t){return!!(this.isNull||t>this.high)&&(this.high=t,!0)}intersect(t,e){return this.intersectsRange(t)?ft.createXXOrCorrectToNull(Math.max(this.low,t.low),Math.min(this.high,t.high),e):ft.createNull(e)}union(t,e){return ft.createXX(Math.min(this.low,t.low),Math.max(this.high,t.high),e)}scaleAboutCenterInPlace(t){if(!this.isNull){t=Math.abs(t);const e=.5*(this.low+this.high);this.high=Q.interpolate(e,t,this.high),this.low=Q.interpolate(e,t,this.low)}}expandInPlace(t){this.setDirect(this.low-t,this.high+t,!0)}clipLinearMapToInterval(t,e,i,s){if(s<i||this.high<this.low)return!1;const n=Q.conditionalDivideFraction(i-t,e),r=Q.conditionalDivideFraction(s-t,e);return void 0===n||void 0===r?i<=t&&t<=s||(this.setNull(),!1):(n<r?(n>this.low&&(this.low=n),r<this.high&&(this.high=r)):(n<this.high&&(this.high=n),r>this.low&&(this.low=r)),!(this.high<this.low&&(this.setNull(),1)))}}class gt extends dt{setNull(){this.low.x=dt._EXTREME_POSITIVE,this.low.y=dt._EXTREME_POSITIVE,this.high.x=dt._EXTREME_NEGATIVE,this.high.y=dt._EXTREME_NEGATIVE}static toFloat64Array(t){return Float64Array.of(t.low.x,t.low.y,t.high.x,t.high.y)}toFloat64Array(){return gt.toFloat64Array(this)}static fromFloat64Array(t){if(4!==t.length)throw new Error("invalid array");return new this(t[0],t[1],t[2],t[3])}static fromArrayBuffer(t){return this.fromFloat64Array(new Float64Array(t))}constructor(t=gt._EXTREME_POSITIVE,e=gt._EXTREME_POSITIVE,i=gt._EXTREME_NEGATIVE,s=gt._EXTREME_NEGATIVE){super(),this.low=H.create(t,e),this.high=H.create(i,s)}isAlmostEqual(t){return this.low.isAlmostEqual(t.low)&&this.high.isAlmostEqual(t.high)||this.isNull&&t.isNull}setFrom(t){this.low.set(t.low.x,t.low.y),this.high.set(t.high.x,t.high.y)}static createFrom(t,e){return e?(e.setFrom(t),e):this.createXYXYOrCorrectToNull(t.low.x,t.low.y,t.high.x,t.high.y,e)}setFromJSON(t){if(this.setNull(),Array.isArray(t)){const e=H.create();for(const i of t)e.setFromJSON(i),this.extendPoint(e);return}const e=H.fromJSON(t.low),i=H.fromJSON(t.high);dt.isExtremePoint2d(e)||dt.isExtremePoint2d(i)||(this.extendPoint(e),this.extendPoint(i))}freeze(){return this.low.freeze(),this.high.freeze(),Object.freeze(this)}toJSON(){return this.isNull?[]:[this.low.toJSON(),this.high.toJSON()]}static fromJSON(t){const e=new this;return t&&e.setFromJSON(t),e}setDirect(t,e,i,s,n){this.low.x=t,this.low.y=e,this.high.x=i,this.high.y=s,n&&(this.low.x>this.high.x||this.low.y>this.high.y)&&this.setNull()}clone(t){return(t=t||new this.constructor).setDirect(this.low.x,this.low.y,this.high.x,this.high.y,!1),t}cloneTranslated(t,e){return e=e||new this.constructor,this.isNull||e.setDirect(this.low.x+t.x,this.low.y+t.y,this.high.x+t.x,this.high.y+t.y,!1),e}static createNull(t){return(t=t||new this).setNull(),t}setXY(t,e){this.low.x=this.high.x=t,this.low.y=this.high.y=e}static createXY(t,e,i){return(i=i||new this).setDirect(t,e,t,e,!1),i}static createXYXY(t,e,i,s,n){return(n=n||new this).setDirect(Math.min(t,i),Math.min(e,s),Math.max(t,i),Math.max(e,s),!1),n}static createXYXYXY(t,e,i,s,n,r,o){return(o=o||new this).setDirect(Math.min(t,i,n),Math.min(e,s,r),Math.max(t,i,n),Math.max(e,s,r),!1),o}static createXYXYOrCorrectToNull(t,e,i,s,n){return t>i||e>s?this.createNull(n):((n=n||new this).setDirect(Math.min(t,i),Math.min(e,s),Math.max(t,i),Math.max(e,s),!0),n)}static createArray(t,e){let i;for(i of(e=e||new this,t))e.extendPoint(i);return e}get isNull(){return this.high.x<this.low.x||this.high.y<this.low.y}static isNull(t){return t.high.x<t.low.x||t.high.y<t.low.y}get isSinglePoint(){return this.high.x===this.low.x&&this.high.y===this.low.y}get center(){return this.low.interpolate(.5,this.high)}get xLow(){return this.low.x}get yLow(){return this.low.y}get xHigh(){return this.high.x}get yHigh(){return this.high.y}xLength(){const t=this.high.x-this.low.x;return t>0?t:0}yLength(){const t=this.high.y-this.low.y;return t>0?t:0}diagonal(t){return this.low.vectorTo(this.high,t)}diagonalFractionToPoint(t,e){return this.low.interpolate(t,this.high,e)}fractionToPoint(t,e,i){return this.low.interpolateXY(t,e,this.high,i)}corners3d(t=!1,e=0){return t?[j.create(this.low.x,this.low.y,e),j.create(this.high.x,this.low.y,e),j.create(this.high.x,this.high.y,e),j.create(this.low.x,this.high.y,e),j.create(this.low.x,this.low.y,e)]:[j.create(this.low.x,this.low.y,e),j.create(this.high.x,this.low.y,e),j.create(this.low.x,this.high.y,e),j.create(this.high.x,this.high.y,e)]}maxAbs(){return this.isNull?0:Math.max(this.low.maxAbs(),this.high.maxAbs())}get isAlmostZeroX(){return Q.isSmallMetricDistance(this.xLength())}get isAlmostZeroY(){return Q.isSmallMetricDistance(this.yLength())}containsXY(t,e){return t>=this.low.x&&e>=this.low.y&&t<=this.high.x&&e<=this.high.y}containsPoint(t){return this.containsXY(t.x,t.y)}containsRange(t){return t.low.x>=this.low.x&&t.low.y>=this.low.y&&t.high.x<=this.high.x&&t.high.y<=this.high.y}intersectsRange(t){return!(this.low.x>t.high.x||this.low.y>t.high.y||t.low.x>this.high.x||t.low.y>this.high.y)}distanceToPoint(t){return this.isNull?gt._EXTREME_POSITIVE:Math.min(Q.hypotenuseXY(dt.coordinateToRangeAbsoluteDistance(t.x,this.low.x,this.high.x),dt.coordinateToRangeAbsoluteDistance(t.y,this.low.y,this.high.y)),gt._EXTREME_POSITIVE)}distanceToRange(t){return Math.min(Q.hypotenuseXY(dt.rangeToRangeAbsoluteDistance(this.low.x,this.high.x,t.low.x,t.high.x),dt.rangeToRangeAbsoluteDistance(this.low.y,this.high.y,t.low.y,t.high.y)),gt._EXTREME_POSITIVE)}extendXY(t,e){t<this.low.x&&(this.low.x=t),t>this.high.x&&(this.high.x=t),e<this.low.y&&(this.low.y=e),e>this.high.y&&(this.high.y=e)}extendTransformedXY(t,e,i){const s=t.multiplyComponentXYZ(0,e,i,0),n=t.multiplyComponentXYZ(1,e,i,0);this.extendXY(s,n)}extendPoint(t){this.extendXY(t.x,t.y)}extendRange(t){gt.isNull(t)||(this.extendXY(t.low.x,t.low.y),this.extendXY(t.high.x,t.high.y))}intersect(t,e){return this.intersectsRange(t)?gt.createXYXY(Math.max(this.low.x,t.low.x),Math.max(this.low.y,t.low.y),Math.min(this.high.x,t.high.x),Math.min(this.high.y,t.high.y),e):gt.createNull(e)}union(t,e){return this.isNull?gt.createFrom(t,e):gt.isNull(t)?this.clone(e):gt.createXYXY(Math.min(this.low.x,t.low.x),Math.min(this.low.y,t.low.y),Math.max(this.high.x,t.high.x),Math.max(this.high.y,t.high.y),e)}scaleAboutCenterInPlace(t){if(!this.isNull){t=Math.abs(t);const e=.5*(this.low.x+this.high.x),i=.5*(this.low.y+this.high.y);this.high.x=Q.interpolate(e,t,this.high.x),this.high.y=Q.interpolate(i,t,this.high.y),this.low.x=Q.interpolate(e,t,this.low.x),this.low.y=Q.interpolate(i,t,this.low.y)}}expandInPlace(t){this.setDirect(this.low.x-t,this.low.y-t,this.high.x+t,this.high.y+t,!0)}worldToLocal(t,e){const i=dt.npcScaleFactor(this.low.x,this.high.x),s=dt.npcScaleFactor(this.low.y,this.high.y);if(0!==i&&0!==s)return H.create((t.x-this.low.x)*i,(t.y-this.low.y)*s,e)}}class pt{constructor(t,e){this._origin=t,this._matrix=e}static get identity(){return void 0===this._identity&&(this._identity=pt.createIdentity(),this._identity.freeze()),this._identity}freeze(){return this._origin.freeze(),this._matrix.freeze(),Object.freeze(this)}setFrom(t){this._origin.setFrom(t._origin),this._matrix.setFrom(t._matrix)}setIdentity(){this._origin.setZero(),this._matrix.setIdentity()}setFromJSON(t){if(t){if(t instanceof Object&&t.origin&&t.matrix)return this._origin.setFromJSON(t.origin),void this._matrix.setFromJSON(t.matrix);if(Q.isArrayOfNumberArray(t,3,4))return this._matrix.setRowValues(t[0][0],t[0][1],t[0][2],t[1][0],t[1][1],t[1][2],t[2][0],t[2][1],t[2][2]),void this._origin.set(t[0][3],t[1][3],t[2][3]);if(Q.isNumberArray(t,12))return this._matrix.setRowValues(t[0],t[1],t[2],t[4],t[5],t[6],t[8],t[9],t[10]),void this._origin.set(t[3],t[7],t[11])}this.setIdentity()}isAlmostEqual(t){return this===t||this.origin.isAlmostEqual(t.origin)&&this.matrix.isAlmostEqual(t.matrix)}isAlmostEqualAllowZRotation(t){return this._origin.isAlmostEqual(t._origin)&&this._matrix.isAlmostEqualAllowZRotation(t._matrix)}toRows(){return[[this._matrix.coffs[0],this._matrix.coffs[1],this._matrix.coffs[2],this._origin.x],[this._matrix.coffs[3],this._matrix.coffs[4],this._matrix.coffs[5],this._origin.y],[this._matrix.coffs[6],this._matrix.coffs[7],this._matrix.coffs[8],this._origin.z]]}toJSON(){return this.toRows()}static fromJSON(t){const e=pt.createIdentity();return e.setFromJSON(t),e}clone(t){return t?(t._matrix.setFrom(this._matrix),t._origin.setFrom(this._origin),t):new pt(j.createFrom(this._origin),this._matrix.clone())}cloneRigid(t=g.XYZ){const e=xt.createRigidFromMatrix3d(this.matrix,t);if(e)return new pt(this.origin.cloneAsPoint3d(),e)}static createRefs(t,e,i){return t||(t=j.createZero()),i?(i._origin=t,i._matrix=e,i):new pt(t,e)}static createRowValues(t,e,i,s,n,r,o,a,c,l,h,d,u){return u?(u._origin.set(s,a,d),u._matrix.setRowValues(t,e,i,n,r,o,c,l,h),u):new pt(j.create(s,a,d),xt.createRowValues(t,e,i,n,r,o,c,l,h))}static createZero(t){return pt.createRowValues(0,0,0,0,0,0,0,0,0,0,0,0,t)}static createTranslationXYZ(t=0,e=0,i=0,s){return pt.createRefs($.create(t,e,i),xt.createIdentity(),s)}static createTranslation(t,e){return pt.createRefs(t,xt.createIdentity(),e)}get matrix(){return this._matrix}get origin(){return this._origin}getOrigin(){return j.createFrom(this._origin)}getTranslation(){return $.createFrom(this._origin)}getMatrix(){return this._matrix.clone()}get isIdentity(){return this._matrix.isIdentity&&this._origin.isAlmostZero}static createIdentity(t){return t?(t._origin.setZero(),t._matrix.setIdentity(),t):pt.createRefs(j.createZero(),xt.createIdentity())}static createOriginAndMatrix(t,e,i){return i?(i._origin.setFromPoint3d(t),i._matrix.setFrom(e),i):pt.createRefs(t?t.cloneAsPoint3d():j.createZero(),void 0===e?xt.createIdentity():e.clone(),i)}setOriginAndMatrixColumns(t,e,i,s){void 0!==t&&this._origin.setFrom(t),this._matrix.setColumns(e,i,s)}static createOriginAndMatrixColumns(t,e,i,s,n){return n?n.setOriginAndMatrixColumns(t,e,i,s):n=pt.createRefs($.createFrom(t),xt.createColumns(e,i,s)),n}static createRigidFromOriginAndColumns(t,e,i,s,n){const r=xt.createRigidFromColumns(e,i,s,n?n._matrix:void 0);if(r)return n?(n._origin.setFrom(t),n):((n=pt.createRefs(void 0,r))._origin.setFromPoint3d(t),n)}static createFixedPointAndMatrix(t,e,i){if(t){const s=xt.xyzMinusMatrixTimesXYZ(t,e,t);return pt.createRefs(s,e.clone(),i)}return pt.createRefs(void 0,e.clone())}static createMatrixPickupPutdown(t,e,i,s){const n=xt.xyzMinusMatrixTimesXYZ(i,t,e);return pt.createRefs(n,t.clone(),s)}static createScaleAboutPoint(t,e,i){const s=xt.createScale(e,e,e),n=xt.xyzMinusMatrixTimesXYZ(t,s,t);return pt.createRefs(n,s,i)}static createFlattenAlongVectorToPlane(t,e,i){const s=xt.createFlattenAlongVectorToPlane(t,i);if(void 0!==s)return pt.createFixedPointAndMatrix(e,s)}multiplyPoint2d(t,e){return xt.xyPlusMatrixTimesXY(this._origin,this._matrix,t,e)}multiplyPoint3d(t,e){return xt.xyzPlusMatrixTimesXYZ(this._origin,this._matrix,t,e)}multiplyXYAndZInPlace(t){return xt.xyzPlusMatrixTimesXYZInPlace(this._origin,this._matrix,t)}multiplyXYZ(t,e,i=0,s){return xt.xyzPlusMatrixTimesCoordinates(this._origin,this._matrix,t,e,i,s)}multiplyComponentXYZ(t,e,i,s=0){const n=this._matrix.coffs,r=3*t;return this.origin.at(t)+n[r]*e+n[r+1]*i+n[r+2]*s}multiplyComponentXYZW(t,e,i,s,n){const r=this._matrix.coffs,o=3*t;return this.origin.at(t)*n+r[o]*e+r[o+1]*i+r[o+2]*s}multiplyXYZW(t,e,i,s,n){return xt.xyzPlusMatrixTimesWeightedCoordinates(this._origin,this._matrix,t,e,i,s,n)}multiplyXYZWToFloat64Array(t,e,i,s,n){return xt.xyzPlusMatrixTimesWeightedCoordinatesToFloat64Array(this._origin,this._matrix,t,e,i,s,n)}multiplyXYZToFloat64Array(t,e,i,s){return xt.xyzPlusMatrixTimesCoordinatesToFloat64Array(this._origin,this._matrix,t,e,i,s)}multiplyTransposeXYZW(t,e,i,s,n){const r=this._matrix.coffs,o=this._origin;return Dt.create(t*r[0]+e*r[3]+i*r[6],t*r[1]+e*r[4]+i*r[7],t*r[2]+e*r[5]+i*r[8],t*o.x+e*o.y+i*o.z+s,n)}multiplyPoint3dArrayInPlace(t){let e;for(e of t)xt.xyzPlusMatrixTimesXYZ(this._origin,this._matrix,e,e)}multiplyPoint3dArrayArrayInPlace(t){for(const e of t)this.multiplyPoint3dArrayInPlace(e)}multiplyInversePoint3d(t,e){return this._matrix.multiplyInverseXYZAsPoint3d(t.x-this._origin.x,t.y-this._origin.y,t.z-this._origin.z,e)}multiplyInversePoint4d(t,e){const i=t.w;return this._matrix.multiplyInverseXYZW(t.x-i*this.origin.x,t.y-i*this.origin.y,t.z-i*this.origin.z,i,e)}multiplyInverseXYZ(t,e,i,s){return this._matrix.multiplyInverseXYZAsPoint3d(t-this._origin.x,e-this._origin.y,i-this._origin.z,s)}computeCachedInverse(t=!0){return this._matrix.computeCachedInverse(t)}static matchArrayLengths(t,e,i){const s=t.length,n=e.length;if(s>n)for(let t=n;t<s;t++)e.push(i());else n>s&&(e.length=s);return s}multiplyInversePoint3dArray(t,e){if(!this._matrix.computeCachedInverse(!0))return;const i=this.origin.x,s=this.origin.y,n=this.origin.z;if(e){const r=pt.matchArrayLengths(t,e,(()=>j.createZero()));for(let o=0;o<r;o++)this._matrix.multiplyInverseXYZAsPoint3d(t[o].x-i,t[o].y-s,t[o].z-n,e[o]);return e}e=[];for(const r of t)e.push(this._matrix.multiplyInverseXYZAsPoint3d(r.x-i,r.y-s,r.z-n));return e}multiplyInversePoint3dArrayInPlace(t){if(!this._matrix.computeCachedInverse(!0))return!1;for(const e of t)this._matrix.multiplyInverseXYZAsPoint3d(e.x-this.origin.x,e.y-this.origin.y,e.z-this.origin.z,e);return!0}multiplyPoint2dArray(t,e){if(e){const i=pt.matchArrayLengths(t,e,(()=>H.createZero()));for(let s=0;s<i;s++)xt.xyPlusMatrixTimesXY(this._origin,this._matrix,t[s],e[s]);return e}e=[];for(const i of t)e.push(xt.xyPlusMatrixTimesXY(this._origin,this._matrix,i));return e}multiplyPoint3dArray(t,e){if(e){const i=pt.matchArrayLengths(t,e,(()=>j.createZero()));for(let s=0;s<i;s++)xt.xyzPlusMatrixTimesXYZ(this._origin,this._matrix,t[s],e[s]);return e}e=[];for(const i of t)e.push(xt.xyzPlusMatrixTimesXYZ(this._origin,this._matrix,i));return e}multiplyVector(t,e){return this._matrix.multiplyVector(t,e)}multiplyVectorInPlace(t){this._matrix.multiplyVectorInPlace(t)}multiplyVectorXYZ(t,e,i,s){return this._matrix.multiplyXYZ(t,e,i,s)}setMultiplyTransformTransform(t,e){xt.xyzPlusMatrixTimesXYZ(t._origin,t._matrix,e._origin,this._origin),t._matrix.multiplyMatrixMatrix(e._matrix,this._matrix)}multiplyTransformTransform(t,e){return e?(e.setMultiplyTransformTransform(this,t),e):pt.createRefs(xt.xyzPlusMatrixTimesXYZ(this._origin,this._matrix,t._origin),this._matrix.multiplyMatrixMatrix(t._matrix))}multiplyTransformMatrix3d(t,e){return e?(this._matrix.multiplyMatrixMatrix(t,e._matrix),e._origin.setFrom(this._origin),e):pt.createRefs(this._origin.cloneAsPoint3d(),this._matrix.multiplyMatrixMatrix(t))}multiplyRange(t,e){if(t.isNull)return t.clone(e);const i=t.low.x,s=t.low.y,n=t.low.z,r=t.high.x,o=t.high.y,a=t.high.z;return(e=ut.createNull(e)).extendTransformedXYZ(this,i,s,n),e.extendTransformedXYZ(this,r,s,n),e.extendTransformedXYZ(this,i,o,n),e.extendTransformedXYZ(this,r,o,n),e.extendTransformedXYZ(this,i,s,a),e.extendTransformedXYZ(this,r,s,a),e.extendTransformedXYZ(this,i,o,a),e.extendTransformedXYZ(this,r,o,a),e}inverse(t){const e=this._matrix.inverse(t?t._matrix:void 0);if(e)return t?(e.multiplyXYZ(-this._origin.x,-this._origin.y,-this._origin.z,t._origin),t):pt.createRefs(e.multiplyXYZ(-this._origin.x,-this._origin.y,-this._origin.z),e)}static initFromRange(t,e,i,s){const n=e.minus(t);0===n.x&&(n.x=1),0===n.y&&(n.y=1),0===n.z&&(n.z=1);const r=new xt;if(i&&(xt.createScale(n.x,n.y,n.z,r),pt.createOriginAndMatrix(t,r,i)),s){const e=new j(-t.x/n.x,-t.y/n.y,-t.z/n.z);xt.createScale(1/n.x,1/n.y,1/n.z,r),pt.createOriginAndMatrix(e,r,s)}}}class mt{static loadMatrix(t,e,i,s,n,r,o,a,c,l){t[0]=e,t[1]=i,t[2]=s,t[3]=n,t[4]=r,t[5]=o,t[6]=a,t[7]=c,t[8]=l}static multiplyMatrixMatrix(t,e,i){return(!i||i.length<9)&&(i=new Float64Array(9)),mt.loadMatrix(i,t[0]*e[0]+t[1]*e[3]+t[2]*e[6],t[0]*e[1]+t[1]*e[4]+t[2]*e[7],t[0]*e[2]+t[1]*e[5]+t[2]*e[8],t[3]*e[0]+t[4]*e[3]+t[5]*e[6],t[3]*e[1]+t[4]*e[4]+t[5]*e[7],t[3]*e[2]+t[4]*e[5]+t[5]*e[8],t[6]*e[0]+t[7]*e[3]+t[8]*e[6],t[6]*e[1]+t[7]*e[4]+t[8]*e[7],t[6]*e[2]+t[7]*e[5]+t[8]*e[8]),i}static multiplyMatrixMatrixTranspose(t,e,i){return(!i||i.length<9)&&(i=new Float64Array(9)),mt.loadMatrix(i,t[0]*e[0]+t[1]*e[1]+t[2]*e[2],t[0]*e[3]+t[1]*e[4]+t[2]*e[5],t[0]*e[6]+t[1]*e[7]+t[2]*e[8],t[3]*e[0]+t[4]*e[1]+t[5]*e[2],t[3]*e[3]+t[4]*e[4]+t[5]*e[5],t[3]*e[6]+t[4]*e[7]+t[5]*e[8],t[6]*e[0]+t[7]*e[1]+t[8]*e[2],t[6]*e[3]+t[7]*e[4]+t[8]*e[5],t[6]*e[6]+t[7]*e[7]+t[8]*e[8]),i}static multiplyMatrixTransposeMatrix(t,e,i){return(!i||i.length<9)&&(i=new Float64Array(9)),mt.loadMatrix(i,t[0]*e[0]+t[3]*e[3]+t[6]*e[6],t[0]*e[1]+t[3]*e[4]+t[6]*e[7],t[0]*e[2]+t[3]*e[5]+t[6]*e[8],t[1]*e[0]+t[4]*e[3]+t[7]*e[6],t[1]*e[1]+t[4]*e[4]+t[7]*e[7],t[1]*e[2]+t[4]*e[5]+t[7]*e[8],t[2]*e[0]+t[5]*e[3]+t[8]*e[6],t[2]*e[1]+t[5]*e[4]+t[8]*e[7],t[2]*e[2]+t[5]*e[5]+t[8]*e[8]),i}static transposeInPlace(t){let e=t[1];t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e}static copyTransposed(t,e){return e===t?mt.transposeInPlace(e):((!e||e.length<9)&&(e=new Float64Array(9)),e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8]),e}static copy(t,e){return e!==t&&(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8]),e}}!function(t){t[t.unknown=0]="unknown",t[t.inverseStored=1]="inverseStored",t[t.singular=2]="singular"}(v||(v={}));class xt{static get identity(){return void 0===this._identity&&(this._identity=xt.createIdentity(),this._identity.freeze()),this._identity}freeze(){return this.computeCachedInverse(!0),Object.freeze(this)}constructor(t){this.coffs=t&&t.length>=9?t:new Float64Array(9),this.inverseCoffs=void 0,this.inverseState=v.unknown}toJSON(){return[[this.coffs[0],this.coffs[1],this.coffs[2]],[this.coffs[3],this.coffs[4],this.coffs[5]],[this.coffs[6],this.coffs[7],this.coffs[8]]]}setFromJSON(t){this.inverseCoffs=void 0,t?Array.isArray(t)?Q.isArrayOfNumberArray(t,3,3)?this.setRowValues(t[0][0],t[0][1],t[0][2],t[1][0],t[1][1],t[1][2],t[2][0],t[2][1],t[2][2]):9!==t.length?4!==t.length?this.setRowValues(0,0,0,0,0,0,0,0,0):this.setRowValues(t[0],t[1],0,t[2],t[3],0,0,0,1):this.setRowValues(t[0],t[1],t[2],t[3],t[4],t[5],t[6],t[7],t[8]):t instanceof xt&&this.setFrom(t):this.setRowValues(0,0,0,0,0,0,0,0,0)}static fromJSON(t){const e=xt.createIdentity();return e.setFromJSON(t),e}isAlmostEqual(t,e){return Q.isDistanceWithinTol(this.maxDiff(t),e)}isAlmostEqualColumn(t,e,i){const s=Q.maxAbsXYZ(this.coffs[t]-e.coffs[t],this.coffs[t+3]-e.coffs[t+3],this.coffs[t+6]-e.coffs[t+6]);return Q.isDistanceWithinTol(s,i)}isAlmostEqualColumnXYZ(t,e,i,s,n){const r=Q.maxAbsXYZ(this.coffs[t]-e,this.coffs[t+3]-i,this.coffs[t+6]-s);return Q.isDistanceWithinTol(r,n)}isAlmostEqualAllowZRotation(t,e){if(this.isAlmostEqual(t,e))return!0;if(this.isAlmostEqualColumn(p.Z,t,e)){const i=W.radiansBetweenVectorsXYZ(this.coffs[0],this.coffs[3],this.coffs[6],t.coffs[0],t.coffs[3],t.coffs[6]),s=W.createRadians(i),n=this.columnX(),r=this.columnY(),o=this.columnZ();let a=$.createRotateVectorAroundVector(n,o,s);if(t.isAlmostEqualColumnXYZ(0,a.x,a.y,a.z,e))return a=$.createRotateVectorAroundVector(r,o,s),t.isAlmostEqualColumnXYZ(1,a.x,a.y,a.z,e)}return!1}isExactEqual(t){return 0===this.maxDiff(t)}get isXY(){return 0===this.coffs[2]&&0===this.coffs[5]&&0===this.coffs[6]&&0===this.coffs[7]&&1===this.coffs[8]}static _create(t){return t||new xt}static createRowValues(t,e,i,s,n,r,o,a,c,l){return(l=l||new xt).inverseState=v.unknown,l.coffs[0]=t,l.coffs[1]=e,l.coffs[2]=i,l.coffs[3]=s,l.coffs[4]=n,l.coffs[5]=r,l.coffs[6]=o,l.coffs[7]=a,l.coffs[8]=c,l}static createCapture(t,e){const i=new xt(t);return e&&e.length>=9?(i.inverseCoffs=e,i.inverseState=v.inverseStored):i.inverseState=v.unknown,i}static createColumnsInAxisOrder(t,e,i,s,n){return n||(n=new xt),t===g.YZX?n.setColumns(s,e,i):t===g.ZXY?n.setColumns(i,s,e):t===g.XZY?n.setColumns(e,s,i):t===g.YXZ?n.setColumns(i,e,s):t===g.ZYX?n.setColumns(s,i,e):n.setColumns(e,i,s),n}createInverseCoffsWithZeros(){this.inverseCoffs||(this.inverseState=v.unknown,this.inverseCoffs=new Float64Array(9))}setupInverseTranspose(){const t=this.coffs;this.inverseState=v.inverseStored,this.inverseCoffs=Float64Array.from([t[0],t[3],t[6],t[1],t[4],t[7],t[2],t[5],t[8]])}setRowValues(t,e,i,s,n,r,o,a,c){this.coffs[0]=t,this.coffs[1]=e,this.coffs[2]=i,this.coffs[3]=s,this.coffs[4]=n,this.coffs[5]=r,this.coffs[6]=o,this.coffs[7]=a,this.coffs[8]=c,this.inverseState=v.unknown}setIdentity(){this.setRowValues(1,0,0,0,1,0,0,0,1),this.setupInverseTranspose()}setZero(){this.setRowValues(0,0,0,0,0,0,0,0,0),this.inverseState=v.singular}setFrom(t){if(void 0!==t){if(t!==this){for(let e=0;e<9;e++)this.coffs[e]=t.coffs[e];if(t.inverseState===v.inverseStored&&void 0!==t.inverseCoffs){this.createInverseCoffsWithZeros();for(let e=0;e<9;e++)this.inverseCoffs[e]=t.inverseCoffs[e];this.inverseState=v.inverseStored}else t.inverseState!==v.inverseStored?this.inverseState=t.inverseState:this.inverseState=v.unknown}}else this.setIdentity()}clone(t){return(t=t||new xt).setFrom(this),t}static createZero(){const t=new xt;return t.inverseState=v.singular,t}static createIdentity(t){return(t=t||new xt).setIdentity(),t}static createScale(t,e,i,s){return s?s.setZero():s=new xt,s.coffs[0]=t,s.coffs[4]=e,s.coffs[8]=i,0===t||0===e||0===i?s.inverseState=v.singular:(s.inverseState=v.inverseStored,s.inverseCoffs=Float64Array.from([1/t,0,0,0,1/e,0,0,0,1/i])),s}static createUniformScale(t){return xt.createScale(t,t,t)}static createPerpendicularVectorFavorXYPlane(t,e){const i=t.magnitude()/64;return Math.abs(t.x)<i&&Math.abs(t.y)<i?$.createCrossProduct(t.x,t.y,t.z,0,-1,0,e):$.createCrossProduct(0,0,1,t.x,t.y,t.z,e)}static createPerpendicularVectorFavorPlaneContainingZ(t,e){return e=xt.createPerpendicularVectorFavorXYPlane(t,e),t.crossProduct(e,e)}static createShuffledColumns(t,e,i,s,n){const r=xt._create(n);return r.setColumn(Q.axisOrderToAxis(s,0),t),r.setColumn(Q.axisOrderToAxis(s,1),e),r.setColumn(Q.axisOrderToAxis(s,2),i),r}static createRigidFromColumns(t,e,i,s){const n=t.normalize();if(n){const r=n.unitCrossProduct(e);if(r){const e=r.unitCrossProduct(t);if(e){const t=xt.createShuffledColumns(n,e,r,i,s);return t.setupInverseTranspose(),t}}}}static createRigidHeadsUp(t,e=g.ZXY,i){const s=xt.createPerpendicularVectorFavorXYPlane(t),n=xt.createRigidFromColumns(t,s,e,i);return n?(n.setupInverseTranspose(),n):xt.createIdentity(i)}static createRotationAroundVector(t,e,i){const s=e.cos(),n=e.sin(),r=1-s,o=t.normalize();if(o){const t=xt.createRowValues(o.x*o.x*r+s,o.x*o.y*r-n*o.z,o.x*o.z*r+n*o.y,o.y*o.x*r+n*o.z,o.y*o.y*r+s,o.y*o.z*r-n*o.x,o.z*o.x*r-n*o.y,o.z*o.y*r+n*o.x,o.z*o.z*r+s,i);return t.setupInverseTranspose(),t}}static createRotationAroundAxisIndex(t,e,i){const s=e.cos(),n=e.sin();let r;return r=t===p.X?xt.createRowValues(1,0,0,0,s,-n,0,n,s,i):t===p.Y?xt.createRowValues(s,0,n,0,1,0,-n,0,s,i):xt.createRowValues(s,-n,0,n,s,0,0,0,1,i),r.setupInverseTranspose(),r}applyGivensRowOp(t,e,i,s){let n=3*t,r=3*e;const o=n+3;for(;n<o;n++,r++){const t=this.coffs[n],e=this.coffs[r];this.coffs[n]=t*i+e*s,this.coffs[r]=-t*s+e*i}}applyGivensColumnOp(t,e,i,s){const n=t+9;for(;t<n;t+=3,e+=3){const n=this.coffs[t],r=this.coffs[e];this.coffs[t]=n*i+r*s,this.coffs[e]=-n*s+r*i}}static createColumns(t,e,i,s){return xt.createRowValues(t.x,e.x,i.x,t.y,e.y,i.y,t.z,e.z,i.z,s)}static createColumnsXYW(t,e,i,s,n,r,o){return xt.createRowValues(t.x,i.x,n.x,t.y,i.y,n.y,e,s,r,o)}static createViewedAxes(t,e,i=0,s=0){const n=t.crossProduct(e);if(n.normalizeInPlace()){const r=xt.createColumns(t,e,n);if(0!==i){let t=Math.sqrt(.5),e=i<0?-t:t;if(1!==Math.abs(i)){const s=W.degreesToRadians(45*i);t=Math.cos(s),e=Math.sin(s)}r.applyGivensColumnOp(2,0,t,e)}if(0!==s){const t=s*Math.atan(Math.sqrt(.5)),e=Math.cos(t),i=Math.sin(t);r.applyGivensColumnOp(1,2,e,-i)}return r}}static createStandardWorldToView(t,e=!1,i){switch(t){case m.Bottom:i=xt.createRowValues(1,0,0,0,-1,0,0,0,-1);break;case m.Left:i=xt.createRowValues(0,-1,0,0,0,1,-1,0,0);break;case m.Right:i=xt.createRowValues(0,1,0,0,0,1,1,0,0);break;case m.Front:i=xt.createRowValues(1,0,0,0,0,1,0,-1,0);break;case m.Back:i=xt.createRowValues(-1,0,0,0,0,1,0,1,0);break;case m.Iso:i=xt.createRowValues(.707106781186548,-.7071067811865476,0,.408248290463863,.408248290463863,.816496580927726,-.577350269189626,-.5773502691896257,.5773502691896257);break;case m.RightIso:i=xt.createRowValues(.707106781186548,.7071067811865476,0,-.408248290463863,.408248290463863,.816496580927726,.577350269189626,-.5773502691896257,.5773502691896257);break;case m.Top:default:i=xt.createIdentity(i)}return e&&i.transposeInPlace(),i}applySymmetricJacobi(t,e,i,s){const n=s.at(t,t),r=s.at(e,e),o=s.at(t,e);if(Math.abs(o)<Q.smallFloatingPoint*(n+r))return 0;const a=W.trigValuesToHalfAngleTrigValues(n-r,2*o),c=a.c,l=a.s;return Math.abs(l)<2e-15?0:(s.applyGivensRowOp(t,e,c,l),s.applyGivensColumnOp(t,e,c,l),i.applyGivensColumnOp(t,e,c,l),Math.abs(o))}symmetricEigenvalues(t,e){const i=this.clone();t.setIdentity(),i.coffs[3]=i.coffs[1],i.coffs[6]=i.coffs[2],i.coffs[7]=i.coffs[5];const s=1e-12*this.sumSquares();for(let n=0;n<7;n++)if(this.applySymmetricJacobi(0,1,t,i)+this.applySymmetricJacobi(0,2,t,i)+this.applySymmetricJacobi(1,2,t,i)<s)return e.set(i.at(0,0),i.at(1,1),i.at(2,2)),!0;return!1}applyFastSymmetricJacobi(t,e,i,s){const n=4*t,r=4*e,o=3*t+e,a=3*e+t,c=3*t+i,l=3*i+t,h=3*e+i,d=3*i+e,u=this.coffs[n],f=this.coffs[r],g=this.coffs[o];if(Math.abs(g)<Q.smallFloatingPoint*(u+f))return 0;const p=W.trigValuesToHalfAngleTrigValues(u-f,2*g),m=p.c,x=p.s,_=m*m,y=x*x,v=2*m*x;this.coffs[n]=_*u+v*g+y*f,this.coffs[r]=y*u-v*g+_*f,this.coffs[o]=0,this.coffs[a]=0;const P=this.coffs[c],A=this.coffs[h];return this.coffs[c]=m*P+x*A,this.coffs[h]=-x*P+m*A,this.coffs[l]=this.coffs[c],this.coffs[d]=this.coffs[h],s.applyGivensColumnOp(t,e,m,x),Math.abs(g)}fastSymmetricEigenvalues(t,e){const i=this.clone();t.setIdentity();const s=1e-12*this.sumSquares();for(let n=0;n<7;n++)if(i.applyFastSymmetricJacobi(0,1,2,t)+i.applyFastSymmetricJacobi(0,2,1,t)+i.applyFastSymmetricJacobi(1,2,0,t)<s)return e.set(i.at(0,0),i.at(1,1),i.at(2,2)),!0;return!1}getAxisAndAngleOfRotation(){const t=this.coffs[0]+this.coffs[4]+this.coffs[8],e=this.coffs[3]-this.coffs[1],i=this.coffs[7]-this.coffs[5],s=this.coffs[2]-this.coffs[6],n=(t-1)/2,r=Q.hypotenuseXYZ(e,i,s)/2,o=n*n+r*r-1;if(Math.abs(o)>Q.smallAngleRadians)return{axis:$.create(0,0,1),angle:W.createRadians(0),ok:!1};if(Math.abs(r)<Q.smallAngleRadians){if(n>0)return{axis:$.create(0,0,1),angle:W.createRadians(0),ok:!0};const t=this.coffs[0],e=this.coffs[4],i=this.coffs[8];if(Q.isAlmostEqualNumber(-1,e)&&Q.isAlmostEqualNumber(-1,i))return{axis:$.create(1,0,0),angle:W.createDegrees(180),ok:!0};if(Q.isAlmostEqualNumber(-1,t)&&Q.isAlmostEqualNumber(-1,i))return{axis:$.create(0,1,0),angle:W.createDegrees(180),ok:!0};if(Q.isAlmostEqualNumber(-1,t)&&Q.isAlmostEqualNumber(-1,e))return{axis:$.create(0,0,1),angle:W.createDegrees(180),ok:!0};const s=xt.createIdentity(),r=$.create(0,0,0);if(this.fastSymmetricEigenvalues(s,r)){for(let t=0;t<2;t++){const e=r.at(t);if(Q.isAlmostEqualNumber(1,e))return{axis:s.getColumn(t),angle:W.createDegrees(180),ok:!0}}return{axis:$.create(0,0,1),angle:W.createRadians(0),ok:!1}}return{axis:$.create(0,0,1),angle:W.createRadians(0),ok:!1}}const a=1/(2*r);return{axis:$.create(i*a,s*a,e*a),angle:W.createAtan2(r,n),ok:!0}}applyJacobiColumnRotation(t,e,i){const s=this.coffs[t]*this.coffs[t]+this.coffs[t+3]*this.coffs[t+3]+this.coffs[t+6]*this.coffs[t+6],n=this.coffs[e]*this.coffs[e]+this.coffs[e+3]*this.coffs[e+3]+this.coffs[e+6]*this.coffs[e+6],r=this.coffs[t]*this.coffs[e]+this.coffs[t+3]*this.coffs[e+3]+this.coffs[t+6]*this.coffs[e+6],o=W.trigValuesToHalfAngleTrigValues(s-n,2*r),a=o.c,c=o.s;return Math.abs(c)<2e-15?0:(this.applyGivensColumnOp(t,e,a,c),i.applyGivensRowOp(t,e,a,c),Math.abs(r))}factorPerpendicularColumns(t,e){t.setFrom(this),e.setIdentity();const i=1e-12*this.sumSquares();for(let s=0;s<7;s++)if(t.applyJacobiColumnRotation(0,1,e)+t.applyJacobiColumnRotation(0,2,e)+t.applyJacobiColumnRotation(1,2,e)<i)return!0;return!1}factorOrthogonalScaleOrthogonal(t,e,i){const s=xt.createZero();if(!this.factorPerpendicularColumns(s,i))return!1;const n=[];n.push(s.getColumn(0)),n.push(s.getColumn(1)),n.push(s.getColumn(2)),e.set(n[0].magnitude(),n[1].magnitude(),n[2].magnitude()),s.determinant()<0&&(e.z=-e.z);const r=Q.smallFloatingPoint,o=Math.abs(e.x)<r,a=Math.abs(e.y)<r,c=Math.abs(e.z)<r;return o||a||c?o||a?o?t.setIdentity():t=xt.createRigidHeadsUp(n[0],g.XYZ,t):(n[0].scaleInPlace(1/e.x),n[1].scaleInPlace(1/e.y),n[2]=n[0].unitCrossProduct(n[1],n[2]),t.setColumns(n[0],n[1],n[2])):t=s.scaleColumns(1/e.x,1/e.y,1/e.z,t),!0}static createPartialRotationVectorToVector(t,e,i,s){let n=t.unitCrossProduct(i);return n?xt.createRotationAroundVector(n,W.createRadians(e*t.planarAngleTo(i,n).radians)):Q.isSmallMetricDistance(t.magnitude())||Q.isSmallMetricDistance(i.magnitude())?void 0:t.dotProduct(i)>0?xt.createIdentity(s):(n=xt.createPerpendicularVectorFavorPlaneContainingZ(t,n),xt.createRotationAroundVector(n,W.createRadians(e*Math.PI)))}static createRotationVectorToVector(t,e,i){return this.createPartialRotationVectorToVector(t,1,e,i)}static create90DegreeRotationAroundAxis(t){if(0===(t=Q.cyclic3dAxis(t))){const t=xt.createRowValues(1,0,0,0,0,-1,0,1,0);return t.setupInverseTranspose(),t}if(1===t){const t=xt.createRowValues(0,0,1,0,1,0,-1,0,0);return t.setupInverseTranspose(),t}{const t=xt.createRowValues(0,-1,0,1,0,0,0,0,1);return t.setupInverseTranspose(),t}}columnX(t){return $.create(this.coffs[0],this.coffs[3],this.coffs[6],t)}columnY(t){return $.create(this.coffs[1],this.coffs[4],this.coffs[7],t)}columnZ(t){return $.create(this.coffs[2],this.coffs[5],this.coffs[8],t)}columnXMagnitudeSquared(){return Q.hypotenuseSquaredXYZ(this.coffs[0],this.coffs[3],this.coffs[6])}columnYMagnitudeSquared(){return Q.hypotenuseSquaredXYZ(this.coffs[1],this.coffs[4],this.coffs[7])}columnZMagnitudeSquared(){return Q.hypotenuseSquaredXYZ(this.coffs[2],this.coffs[5],this.coffs[8])}columnXMagnitude(){return Q.hypotenuseXYZ(this.coffs[0],this.coffs[3],this.coffs[6])}columnYMagnitude(){return Q.hypotenuseXYZ(this.coffs[1],this.coffs[4],this.coffs[7])}columnZMagnitude(){return Q.hypotenuseXYZ(this.coffs[2],this.coffs[5],this.coffs[8])}columnXYCrossProductMagnitude(){return Q.crossProductMagnitude(this.coffs[0],this.coffs[3],this.coffs[6],this.coffs[1],this.coffs[4],this.coffs[7])}rowXMagnitude(){return Q.hypotenuseXYZ(this.coffs[0],this.coffs[1],this.coffs[2])}rowYMagnitude(){return Q.hypotenuseXYZ(this.coffs[3],this.coffs[4],this.coffs[5])}rowZMagnitude(){return Q.hypotenuseXYZ(this.coffs[6],this.coffs[7],this.coffs[8])}columnXDotColumnY(){return this.coffs[0]*this.coffs[1]+this.coffs[3]*this.coffs[4]+this.coffs[6]*this.coffs[7]}columnXDotColumnZ(){return this.coffs[0]*this.coffs[2]+this.coffs[3]*this.coffs[5]+this.coffs[6]*this.coffs[8]}columnYDotColumnZ(){return this.coffs[1]*this.coffs[2]+this.coffs[4]*this.coffs[5]+this.coffs[7]*this.coffs[8]}columnDotXYZ(t,e,i,s){return this.coffs[t]*e+this.coffs[t+3]*i+this.coffs[t+6]*s}rowX(t){return $.create(this.coffs[0],this.coffs[1],this.coffs[2],t)}rowY(t){return $.create(this.coffs[3],this.coffs[4],this.coffs[5],t)}rowZ(t){return $.create(this.coffs[6],this.coffs[7],this.coffs[8],t)}dotColumnX(t){return t.x*this.coffs[0]+t.y*this.coffs[3]+t.z*this.coffs[6]}dotColumnY(t){return t.x*this.coffs[1]+t.y*this.coffs[4]+t.z*this.coffs[7]}dotColumnZ(t){return t.x*this.coffs[2]+t.y*this.coffs[5]+t.z*this.coffs[8]}dotRowX(t){return t.x*this.coffs[0]+t.y*this.coffs[1]+t.z*this.coffs[2]}dotRowY(t){return t.x*this.coffs[3]+t.y*this.coffs[4]+t.z*this.coffs[5]}dotRowZ(t){return t.x*this.coffs[6]+t.y*this.coffs[7]+t.z*this.coffs[8]}dotRowXXYZ(t,e,i){return t*this.coffs[0]+e*this.coffs[1]+i*this.coffs[2]}dotRowYXYZ(t,e,i){return t*this.coffs[3]+e*this.coffs[4]+i*this.coffs[5]}dotRowZXYZ(t,e,i){return t*this.coffs[6]+e*this.coffs[7]+i*this.coffs[8]}columnZCrossVector(t,e){return Q.crossProductXYZXYZ(this.coffs[2],this.coffs[5],this.coffs[8],t.x,t.y,t.z,e)}setColumnsPoint4dXYZ(t,e,i){this.inverseState=v.unknown,this.setRowValues(t.x,e.x,i.x,t.y,e.y,i.y,t.z,e.z,i.z)}setColumn(t,e){const i=Q.cyclic3dAxis(t);this.inverseState=v.unknown,e?(this.coffs[i]=e.x,this.coffs[i+3]=e.y,this.coffs[i+6]=e.z):(this.coffs[i]=0,this.coffs[i+3]=0,this.coffs[i+6]=0)}setColumns(t,e,i){this.setColumn(0,t),this.setColumn(1,e),this.setColumn(2,i)}setRow(t,e){const i=3*Q.cyclic3dAxis(t);this.coffs[i]=e.x,this.coffs[i+1]=e.y,this.coffs[i+2]=e.z,this.inverseState=v.unknown}getColumn(t,e){const i=Q.cyclic3dAxis(t);return $.create(this.coffs[i],this.coffs[i+3],this.coffs[i+6],e)}getRow(t,e){const i=3*Q.cyclic3dAxis(t);return $.create(this.coffs[i],this.coffs[i+1],this.coffs[i+2],e)}static createRows(t,e,i,s){return xt.createRowValues(t.x,t.y,t.z,e.x,e.y,e.z,i.x,i.y,i.z,s)}static createDirectionalScale(t,e,i){const s=t.normalize();if(s){const t=s.x,n=s.y,r=s.z,o=e-1;return xt.createRowValues(1+o*t*t,o*t*n,o*t*r,o*n*t,1+o*n*n,o*n*r,o*r*t,o*r*n,1+o*r*r,i)}return xt.createUniformScale(e)}static createFlattenAlongVectorToPlane(t,e){const i=xt.createIdentity(),s=t.dotProduct(e),n=Q.conditionalDivideCoordinate(1,-s);if(void 0!==n)return i.addScaledOuterProductInPlace(t,e,n),i}multiplyPoint(t,e){const i=t.x,s=t.y,n=t.z;return j.create(this.coffs[0]*i+this.coffs[1]*s+this.coffs[2]*n,this.coffs[3]*i+this.coffs[4]*s+this.coffs[5]*n,this.coffs[6]*i+this.coffs[7]*s+this.coffs[8]*n,e)}multiplyVector(t,e){const i=t.x,s=t.y,n=t.z;return $.create(this.coffs[0]*i+this.coffs[1]*s+this.coffs[2]*n,this.coffs[3]*i+this.coffs[4]*s+this.coffs[5]*n,this.coffs[6]*i+this.coffs[7]*s+this.coffs[8]*n,e)}multiplyVectorArrayInPlace(t){for(const e of t)e.set(this.coffs[0]*e.x+this.coffs[1]*e.y+this.coffs[2]*e.z,this.coffs[3]*e.x+this.coffs[4]*e.y+this.coffs[5]*e.z,this.coffs[6]*e.x+this.coffs[7]*e.y+this.coffs[8]*e.z)}static xyzMinusMatrixTimesXYZ(t,e,i,s){const n=i.x,r=i.y,o=i.z;return j.create(t.x-(e.coffs[0]*n+e.coffs[1]*r+e.coffs[2]*o),t.y-(e.coffs[3]*n+e.coffs[4]*r+e.coffs[5]*o),t.z-(e.coffs[6]*n+e.coffs[7]*r+e.coffs[8]*o),s)}static xyPlusMatrixTimesXY(t,e,i,s){const n=i.x,r=i.y;return H.create(t.x+e.coffs[0]*n+e.coffs[1]*r,t.y+e.coffs[3]*n+e.coffs[4]*r,s)}static xyzPlusMatrixTimesXYZ(t,e,i,s){const n=i.x,r=i.y,o=i.z;return j.create(t.x+e.coffs[0]*n+e.coffs[1]*r+e.coffs[2]*o,t.y+e.coffs[3]*n+e.coffs[4]*r+e.coffs[5]*o,t.z+e.coffs[6]*n+e.coffs[7]*r+e.coffs[8]*o,s)}static xyzPlusMatrixTimesXYZInPlace(t,e,i){const s=i.x,n=i.y,r=i.z;i.x=t.x+e.coffs[0]*s+e.coffs[1]*n+e.coffs[2]*r,i.y=t.y+e.coffs[3]*s+e.coffs[4]*n+e.coffs[5]*r,i.z=t.z+e.coffs[6]*s+e.coffs[7]*n+e.coffs[8]*r}static xyzPlusMatrixTimesCoordinates(t,e,i,s,n,r){return j.create(t.x+e.coffs[0]*i+e.coffs[1]*s+e.coffs[2]*n,t.y+e.coffs[3]*i+e.coffs[4]*s+e.coffs[5]*n,t.z+e.coffs[6]*i+e.coffs[7]*s+e.coffs[8]*n,r)}static xyzPlusMatrixTimesWeightedCoordinates(t,e,i,s,n,r,o){return Dt.create(e.coffs[0]*i+e.coffs[1]*s+e.coffs[2]*n+t.x*r,e.coffs[3]*i+e.coffs[4]*s+e.coffs[5]*n+t.y*r,e.coffs[6]*i+e.coffs[7]*s+e.coffs[8]*n+t.z*r,r,o)}static xyzPlusMatrixTimesWeightedCoordinatesToFloat64Array(t,e,i,s,n,r,o){return(!o||o.length<4)&&(o=new Float64Array(4)),o[0]=e.coffs[0]*i+e.coffs[1]*s+e.coffs[2]*n+t.x*r,o[1]=e.coffs[3]*i+e.coffs[4]*s+e.coffs[5]*n+t.y*r,o[2]=e.coffs[6]*i+e.coffs[7]*s+e.coffs[8]*n+t.z*r,o[3]=r,o}static xyzPlusMatrixTimesCoordinatesToFloat64Array(t,e,i,s,n,r){return(!r||r.length<3)&&(r=new Float64Array(3)),r[0]=e.coffs[0]*i+e.coffs[1]*s+e.coffs[2]*n+t.x,r[1]=e.coffs[3]*i+e.coffs[4]*s+e.coffs[5]*n+t.y,r[2]=e.coffs[6]*i+e.coffs[7]*s+e.coffs[8]*n+t.z,r}multiplyTransposeVector(t,e){e=e||new $;const i=t.x,s=t.y,n=t.z;return e.x=this.coffs[0]*i+this.coffs[3]*s+this.coffs[6]*n,e.y=this.coffs[1]*i+this.coffs[4]*s+this.coffs[7]*n,e.z=this.coffs[2]*i+this.coffs[5]*s+this.coffs[8]*n,e}multiplyXYZ(t,e,i,s){return(s=s||new $).x=this.coffs[0]*t+this.coffs[1]*e+this.coffs[2]*i,s.y=this.coffs[3]*t+this.coffs[4]*e+this.coffs[5]*i,s.z=this.coffs[6]*t+this.coffs[7]*e+this.coffs[8]*i,s}multiplyXYZtoXYZ(t,e){const i=t.x,s=t.y,n=t.z;return e.x=this.coffs[0]*i+this.coffs[1]*s+this.coffs[2]*n,e.y=this.coffs[3]*i+this.coffs[4]*s+this.coffs[5]*n,e.z=this.coffs[6]*i+this.coffs[7]*s+this.coffs[8]*n,e}multiplyXY(t,e,i){return(i=i||new $).x=this.coffs[0]*t+this.coffs[1]*e,i.y=this.coffs[3]*t+this.coffs[4]*e,i.z=this.coffs[6]*t+this.coffs[7]*e,i}originPlusMatrixTimesXY(t,e,i,s){return j.create(t.x+this.coffs[0]*e+this.coffs[1]*i,t.y+this.coffs[3]*e+this.coffs[4]*i,t.z+this.coffs[6]*e+this.coffs[7]*i,s)}multiplyVectorInPlace(t){const e=t.x,i=t.y,s=t.z;t.x=this.coffs[0]*e+this.coffs[1]*i+this.coffs[2]*s,t.y=this.coffs[3]*e+this.coffs[4]*i+this.coffs[5]*s,t.z=this.coffs[6]*e+this.coffs[7]*i+this.coffs[8]*s}multiplyTransposeVectorInPlace(t){const e=t.x,i=t.y,s=t.z;t.x=this.coffs[0]*e+this.coffs[3]*i+this.coffs[6]*s,t.y=this.coffs[1]*e+this.coffs[4]*i+this.coffs[7]*s,t.z=this.coffs[2]*e+this.coffs[5]*i+this.coffs[8]*s}multiplyTransposeXYZ(t,e,i,s){return(s=s||new $).x=this.coffs[0]*t+this.coffs[3]*e+this.coffs[6]*i,s.y=this.coffs[1]*t+this.coffs[4]*e+this.coffs[7]*i,s.z=this.coffs[2]*t+this.coffs[5]*e+this.coffs[8]*i,s}multiplyInverse(t,e){if(this.computeCachedInverse(!0),this.inverseCoffs){const i=t.x,s=t.y,n=t.z;return $.create(this.inverseCoffs[0]*i+this.inverseCoffs[1]*s+this.inverseCoffs[2]*n,this.inverseCoffs[3]*i+this.inverseCoffs[4]*s+this.inverseCoffs[5]*n,this.inverseCoffs[6]*i+this.inverseCoffs[7]*s+this.inverseCoffs[8]*n,e)}}multiplyInverseTranspose(t,e){if(this.computeCachedInverse(!0),this.inverseCoffs){const i=t.x,s=t.y,n=t.z;return $.create(this.inverseCoffs[0]*i+this.inverseCoffs[3]*s+this.inverseCoffs[6]*n,this.inverseCoffs[1]*i+this.inverseCoffs[4]*s+this.inverseCoffs[7]*n,this.inverseCoffs[2]*i+this.inverseCoffs[5]*s+this.inverseCoffs[8]*n,e)}}multiplyInverseXYZAsVector3d(t,e,i,s){if(this.computeCachedInverse(!0),this.inverseCoffs)return $.create(this.inverseCoffs[0]*t+this.inverseCoffs[1]*e+this.inverseCoffs[2]*i,this.inverseCoffs[3]*t+this.inverseCoffs[4]*e+this.inverseCoffs[5]*i,this.inverseCoffs[6]*t+this.inverseCoffs[7]*e+this.inverseCoffs[8]*i,s)}multiplyInverseXYZW(t,e,i,s,n){if(this.computeCachedInverse(!0),this.inverseCoffs)return Dt.create(this.inverseCoffs[0]*t+this.inverseCoffs[1]*e+this.inverseCoffs[2]*i,this.inverseCoffs[3]*t+this.inverseCoffs[4]*e+this.inverseCoffs[5]*i,this.inverseCoffs[6]*t+this.inverseCoffs[7]*e+this.inverseCoffs[8]*i,s,n)}multiplyInverseXYZAsPoint3d(t,e,i,s){if(this.computeCachedInverse(!0),this.inverseCoffs)return j.create(this.inverseCoffs[0]*t+this.inverseCoffs[1]*e+this.inverseCoffs[2]*i,this.inverseCoffs[3]*t+this.inverseCoffs[4]*e+this.inverseCoffs[5]*i,this.inverseCoffs[6]*t+this.inverseCoffs[7]*e+this.inverseCoffs[8]*i,s)}finishInverseCoffs(t,e,i){e&&i?(this.createInverseCoffsWithZeros(),this.inverseState=v.inverseStored,t(e,i,this.inverseCoffs)):this.inverseState=v.unknown}multiplyMatrixMatrix(t,e){return e=e||new xt,mt.multiplyMatrixMatrix(this.coffs,t.coffs,e.coffs),this.inverseState===v.inverseStored&&t.inverseState===v.inverseStored?e.finishInverseCoffs(((t,e,i)=>mt.multiplyMatrixMatrix(t,e,i)),t.inverseCoffs,this.inverseCoffs):this.inverseState===v.singular||t.inverseState===v.singular?e.inverseState=v.singular:e.inverseState=v.unknown,e}multiplyMatrixMatrixInverse(t,e){if(t.computeCachedInverse(!0))return e=e||new xt,mt.multiplyMatrixMatrix(this.coffs,t.inverseCoffs,xt._productBuffer),this.inverseState===v.inverseStored?e.finishInverseCoffs(((t,e,i)=>mt.multiplyMatrixMatrix(t,e,i)),t.coffs,this.inverseCoffs):e.inverseState=v.unknown,mt.copy(xt._productBuffer,e.coffs),e}multiplyMatrixInverseMatrix(t,e){if(this.computeCachedInverse(!0))return e=e||new xt,mt.multiplyMatrixMatrix(this.inverseCoffs,t.coffs,xt._productBuffer),t.inverseState===v.inverseStored?e.finishInverseCoffs(((t,e,i)=>mt.multiplyMatrixMatrix(t,e,i)),t.inverseCoffs,this.coffs):e.inverseState=v.unknown,mt.copy(xt._productBuffer,e.coffs),e}multiplyMatrixMatrixTranspose(t,e){return e=e||new xt,mt.multiplyMatrixMatrixTranspose(this.coffs,t.coffs,e.coffs),this.inverseState===v.inverseStored&&t.inverseState===v.inverseStored?e.finishInverseCoffs(((t,e,i)=>mt.multiplyMatrixTransposeMatrix(t,e,i)),t.inverseCoffs,this.inverseCoffs):this.inverseState===v.singular||t.inverseState===v.singular?e.inverseState=v.singular:e.inverseState=v.unknown,e}multiplyMatrixTransposeMatrix(t,e){return e=e||new xt,mt.multiplyMatrixTransposeMatrix(this.coffs,t.coffs,e.coffs),this.inverseState===v.inverseStored&&t.inverseState===v.inverseStored?e.finishInverseCoffs(((t,e,i)=>mt.multiplyMatrixMatrixTranspose(t,e,i)),t.inverseCoffs,this.inverseCoffs):this.inverseState===v.singular||t.inverseState===v.singular?e.inverseState=v.singular:e.inverseState=v.unknown,e}multiplyMatrixTransform(t,e){return e?(this.multiplyXYZtoXYZ(t.origin,e.origin),this.multiplyMatrixMatrix(t.matrix,e.matrix),e):pt.createRefs(this.multiplyXYZ(t.origin.x,t.origin.y,t.origin.z),this.multiplyMatrixMatrix(t.matrix))}transpose(t){return t||(t=new xt),mt.copyTransposed(this.coffs,t.coffs),void 0!==this.inverseCoffs?(t.inverseState=v.inverseStored,t.inverseCoffs=mt.copyTransposed(this.inverseCoffs,t.inverseCoffs)):(t.inverseState=this.inverseState,t.inverseCoffs=void 0),t}transposeInPlace(){mt.transposeInPlace(this.coffs),this.inverseCoffs&&mt.transposeInPlace(this.inverseCoffs)}inverse(t){if(this.computeCachedInverse(!0))return t===this?(mt.copy(this.coffs,xt._productBuffer),mt.copy(this.inverseCoffs,this.coffs),mt.copy(xt._productBuffer,this.inverseCoffs),t):(void 0===t&&(t=xt.createIdentity()),t.createInverseCoffsWithZeros(),mt.copy(this.coffs,t.inverseCoffs),mt.copy(this.inverseCoffs,t.coffs),t.inverseState=this.inverseState,t)}static rowColumnDot(t,e,i,s){return t[e]*i[s]+t[e+1]*i[s+3]+t[e+2]*i[s+6]}static indexedRowCrossProduct(t,e,i,s,n){s[n]=t[e+1]*t[i+2]-t[e+2]*t[i+1],s[n+3]=t[e+2]*t[i]-t[e]*t[i+2],s[n+6]=t[e]*t[i+1]-t[e+1]*t[i]}indexedColumnCrossProductInPlace(t,e,i){const s=this.coffs;s[i]=s[t+3]*s[e+6]-s[t+6]*s[e+3],s[i+3]=s[t+6]*s[e]-s[t]*s[e+6],s[i+6]=s[t]*s[e+3]-s[t+3]*s[e]}axisOrderCrossProductsInPlace(t){switch(t){case g.XYZ:this.indexedColumnCrossProductInPlace(0,1,2),this.indexedColumnCrossProductInPlace(2,0,1);break;case g.YZX:this.indexedColumnCrossProductInPlace(1,2,0),this.indexedColumnCrossProductInPlace(0,1,2);break;case g.ZXY:this.indexedColumnCrossProductInPlace(2,0,1),this.indexedColumnCrossProductInPlace(1,2,0);break;case g.XZY:this.indexedColumnCrossProductInPlace(0,2,1),this.indexedColumnCrossProductInPlace(1,0,2);break;case g.YXZ:this.indexedColumnCrossProductInPlace(1,0,2),this.indexedColumnCrossProductInPlace(2,1,0);break;case g.ZYX:this.indexedColumnCrossProductInPlace(2,1,0),this.indexedColumnCrossProductInPlace(0,2,1)}}normalizeColumnsInPlace(t){const e=this.columnXMagnitude(),i=this.columnYMagnitude(),s=this.columnZMagnitude();return t&&t.set(e,i,s),!(Q.isSmallMetricDistance(e)||Q.isSmallMetricDistance(i)||Q.isSmallMetricDistance(s)||(this.scaleColumns(1/e,1/i,1/s,this),0))}normalizeRowsInPlace(t){const e=this.rowXMagnitude(),i=this.rowYMagnitude(),s=this.rowZMagnitude();return t&&t.set(e,i,s),!(Q.isSmallMetricDistance(e)||Q.isSmallMetricDistance(i)||Q.isSmallMetricDistance(s)||(this.scaleRows(1/e,1/i,1/s,this),0))}isSingular(){return!this.computeCachedInverse(!0)}markSingular(){this.inverseState=v.singular}computeCachedInverse(t){if(t&&xt.useCachedInverse&&this.inverseState!==v.unknown)return xt.numUseCache++,this.inverseState===v.inverseStored;this.inverseState=v.unknown,this.createInverseCoffsWithZeros();const e=this.coffs,i=this.inverseCoffs;xt.indexedRowCrossProduct(e,3,6,i,0),xt.indexedRowCrossProduct(e,6,0,i,1),xt.indexedRowCrossProduct(e,0,3,i,2),xt.numComputeCache++;const s=xt.rowColumnDot(e,0,i,0);if(0===s)return this.inverseState=v.singular,this.inverseCoffs=void 0,!1;const n=1/s;for(let t=0;t<9;t++)i[t]*=n;return this.inverseState=v.inverseStored,!0}static flatIndexOf(t,e){return 3*Q.cyclic3dAxis(t)+Q.cyclic3dAxis(e)}indexedColumnWithWeight(t,e,i){return t=Q.cyclic3dAxis(t),Dt.create(this.coffs[t],this.coffs[t+3],this.coffs[t+6],e,i)}at(t,e){return this.coffs[xt.flatIndexOf(t,e)]}setAt(t,e,i){this.coffs[xt.flatIndexOf(t,e)]=i,this.inverseState=v.unknown}scale(t,e){return xt.createRowValues(this.coffs[0]*t,this.coffs[1]*t,this.coffs[2]*t,this.coffs[3]*t,this.coffs[4]*t,this.coffs[5]*t,this.coffs[6]*t,this.coffs[7]*t,this.coffs[8]*t,e)}scaleColumns(t,e,i,s){return xt.createRowValues(this.coffs[0]*t,this.coffs[1]*e,this.coffs[2]*i,this.coffs[3]*t,this.coffs[4]*e,this.coffs[5]*i,this.coffs[6]*t,this.coffs[7]*e,this.coffs[8]*i,s)}scaleColumnsInPlace(t,e,i){if(this.coffs[0]*=t,this.coffs[1]*=e,this.coffs[2]*=i,this.coffs[3]*=t,this.coffs[4]*=e,this.coffs[5]*=i,this.coffs[6]*=t,this.coffs[7]*=e,this.coffs[8]*=i,this.inverseState===v.inverseStored&&void 0!==this.inverseCoffs){const s=Q.conditionalDivideFraction(1,t),n=Q.conditionalDivideFraction(1,e),r=Q.conditionalDivideFraction(1,i);void 0!==s&&void 0!==n&&void 0!==r?(this.inverseCoffs[0]*=s,this.inverseCoffs[1]*=s,this.inverseCoffs[2]*=s,this.inverseCoffs[3]*=n,this.inverseCoffs[4]*=n,this.inverseCoffs[5]*=n,this.inverseCoffs[6]*=r,this.inverseCoffs[7]*=r,this.inverseCoffs[8]*=r):this.inverseState=v.singular}}scaleRows(t,e,i,s){return xt.createRowValues(this.coffs[0]*t,this.coffs[1]*t,this.coffs[2]*t,this.coffs[3]*e,this.coffs[4]*e,this.coffs[5]*e,this.coffs[6]*i,this.coffs[7]*i,this.coffs[8]*i,s)}scaleRowsInPlace(t,e,i){if(this.coffs[0]*=t,this.coffs[1]*=t,this.coffs[2]*=t,this.coffs[3]*=e,this.coffs[4]*=e,this.coffs[5]*=e,this.coffs[6]*=i,this.coffs[7]*=i,this.coffs[8]*=i,this.inverseState===v.inverseStored&&void 0!==this.inverseCoffs){const s=Q.conditionalDivideFraction(1,t),n=Q.conditionalDivideFraction(1,e),r=Q.conditionalDivideFraction(1,i);void 0!==s&&void 0!==n&&void 0!==r?(this.inverseCoffs[0]*=s,this.inverseCoffs[1]*=n,this.inverseCoffs[2]*=r,this.inverseCoffs[3]*=s,this.inverseCoffs[4]*=n,this.inverseCoffs[5]*=r,this.inverseCoffs[6]*=s,this.inverseCoffs[7]*=n,this.inverseCoffs[8]*=r):this.inverseState=v.singular}}addScaledInPlace(t,e){for(let i=0;i<9;i++)this.coffs[i]+=e*t.coffs[i];this.inverseState=v.unknown}addScaledOuterProductInPlace(t,e,i){this.coffs[0]+=i*t.x*e.x,this.coffs[1]+=i*t.x*e.y,this.coffs[2]+=i*t.x*e.z,this.coffs[3]+=i*t.y*e.x,this.coffs[4]+=i*t.y*e.y,this.coffs[5]+=i*t.y*e.z,this.coffs[6]+=i*t.z*e.x,this.coffs[7]+=i*t.z*e.y,this.coffs[8]+=i*t.z*e.z,this.inverseState=v.unknown}static createRigidViewAxesZTowardsEye(t,e,i,s){s=xt.createIdentity(s);const n=Q.hypotenuseXY(t,e);if(Q.isSmallMetricDistance(n))i<0&&s.scaleColumnsInPlace(1,-1,-1);else{const r=t/n,o=e/n;if(s.setRowValues(-o,0,r,r,0,o,0,1,0),0!==i){const r=Q.hypotenuseXYZ(t,e,i),o=i/r,a=n/r;s.applyGivensColumnOp(1,2,a,-o)}}return s}determinant(){return this.coffs[0]*this.coffs[4]*this.coffs[8]-this.coffs[0]*this.coffs[5]*this.coffs[7]-this.coffs[1]*this.coffs[3]*this.coffs[8]+this.coffs[1]*this.coffs[5]*this.coffs[6]+this.coffs[2]*this.coffs[3]*this.coffs[7]-this.coffs[2]*this.coffs[4]*this.coffs[6]}conditionNumber(){const t=Math.abs(this.determinant()),e=Q.hypotenuseXYZ(this.coffs[0],this.coffs[3],this.coffs[6])+Q.hypotenuseXYZ(this.coffs[1],this.coffs[4],this.coffs[7])+Q.hypotenuseXYZ(this.coffs[2],this.coffs[5],this.coffs[8]);return Q.safeDivideFraction(t,e,0)}sumSquares(){let t=0;for(let e=0;e<9;e++)t+=this.coffs[e]*this.coffs[e];return t}sumDiagonalSquares(){let t=0;for(let e=0;e<9;e+=4)t+=this.coffs[e]*this.coffs[e];return t}sumDiagonal(){return this.coffs[0]+this.coffs[4]+this.coffs[8]}maxAbs(){let t=0;for(let e=0;e<9;e++)t=Math.max(t,Math.abs(this.coffs[e]));return t}maxDiff(t){let e=0;for(let i=0;i<9;i++)e=Math.max(e,Math.abs(this.coffs[i]-t.coffs[i]));return e}get isIdentity(){return this.maxDiff(xt.identity)<Q.smallAngleRadians}get isDiagonal(){const t=this.sumSquares(),e=this.sumDiagonalSquares(),i=Math.abs(t-e);return Math.sqrt(i)<=Q.smallAngleRadians*(1+Math.sqrt(t))}sumSkewSquares(){return Q.hypotenuseSquaredXYZ(this.coffs[1]-this.coffs[3],this.coffs[2]-this.coffs[6],this.coffs[5]-this.coffs[7])}isSymmetric(){const t=this.sumSkewSquares();return Math.sqrt(t)<=Q.smallAngleRadians*(1+Math.sqrt(this.sumSquares()))}get hasCachedInverse(){return this.inverseState===v.inverseStored&&void 0!==this.inverseCoffs}get isUpperTriangular(){const t=this.sumSquares(),e=Q.hypotenuseSquaredXYZ(this.coffs[3],this.coffs[6],this.coffs[7]);return Math.sqrt(e)<=Q.smallAngleRadians*(1+Math.sqrt(t))}get isLowerTriangular(){const t=this.sumSquares(),e=Q.hypotenuseSquaredXYZ(this.coffs[1],this.coffs[2],this.coffs[5]);return Math.sqrt(e)<=Q.smallAngleRadians*(1+Math.sqrt(t))}sameDiagonalScale(){const t=this.sumSquares(),e=this.sumDiagonalSquares(),i=Math.abs(t-e);if(Math.sqrt(i)<=Q.smallAngleRadians*(1+Math.sqrt(t))&&Q.isSameCoordinate(this.coffs[0],this.coffs[4])&&Q.isSameCoordinate(this.coffs[0],this.coffs[8]))return this.coffs[0]}testPerpendicularUnitRowsAndColumns(){return this.multiplyMatrixMatrixTranspose(this).isIdentity}isRigid(t=!1){return this.testPerpendicularUnitRowsAndColumns()&&(t||this.determinant()>0)}factorRigidWithSignedScale(t){const e=this.multiplyMatrixMatrixTranspose(this).sameDiagonalScale();if(void 0===e||e<=0)return;const i=this.determinant()>0?Math.sqrt(e):-Math.sqrt(e),s=1/i;return{rigidAxes:this.scaleColumns(s,s,s,t),scale:i}}factorRigidSkew(t,e,i=g.XYZ){return xt.createRigidFromMatrix3d(this,i,t)?(t.multiplyMatrixTransposeMatrix(this,e),!0):(t.setIdentity(),e.setFrom(this),!1)}get isSignedPermutation(){let t=0;for(let e=0;e<3;e++)for(let i=0;i<3;i++){const s=this.at(e,i);if(0===s);else{if(1!==s&&-1!==s)return!1;if(t++,0!==this.at(e+1,i)||0!==this.at(e+2,i)||0!==this.at(e,i+1)||0!==this.at(e,i+2))return!1}}return 3===t}makeRigid(t=g.XYZ){const e=this.maxAbs();if(Q.isSmallMetricDistance(e))return!1;const i=1/e;return this.scaleColumnsInPlace(i,i,i),this.axisOrderCrossProductsInPlace(t),this.normalizeColumnsInPlace()}static createRigidFromMatrix3d(t,e=g.XYZ,i){if((i=t.clone(i)).makeRigid(e))return i}static createFromQuaternion(t){const e=t.x*t.x,i=t.y*t.y,s=t.z*t.z,n=t.w*t.w,r=e+i+s+n;if(0===r)return xt.createIdentity();{const o=1/r;return xt.createRowValues(o*(n+e-i-s),2*o*(t.w*t.z+t.x*t.y),2*o*(t.x*t.z-t.w*t.y),2*o*(t.x*t.y-t.w*t.z),o*(n-e+i-s),2*o*(t.w*t.x+t.y*t.z),2*o*(t.x*t.z+t.w*t.y),2*o*(t.y*t.z-t.w*t.x),o*(n-e-i+s))}}static computeQuatTerm(t,e,i,s){let n;return s>.5?(n=.5*Math.sqrt(s),e*t<0&&(n=-n)):n=t*i,n}toQuaternion(){const t=Dt.createZero(),e=[[this.coffs[0],this.coffs[3],this.coffs[6]],[this.coffs[1],this.coffs[4],this.coffs[7]],[this.coffs[2],this.coffs[5],this.coffs[8]]],i=e[0][0],s=e[1][1],n=e[2][2],r=[];let o;r[0]=1+i-s-n,r[1]=1-i+s-n,r[2]=1-i-s+n,r[3]=1+i+s+n;let a=0;for(let t=1;t<=3;t++)r[t]>r[a]&&(a=t);return 0===a?(t.x=.5*Math.sqrt(r[0]),o=1/(4*t.x),t.y=xt.computeQuatTerm(e[0][1]+e[1][0],t.x,o,r[1]),t.z=xt.computeQuatTerm(e[0][2]+e[2][0],t.x,o,r[2]),t.w=xt.computeQuatTerm(e[2][1]-e[1][2],t.x,o,r[3])):1===a?(t.y=.5*Math.sqrt(r[1]),o=1/(4*t.y),t.x=xt.computeQuatTerm(e[0][1]+e[1][0],t.y,o,r[0]),t.z=xt.computeQuatTerm(e[1][2]+e[2][1],t.y,o,r[2]),t.w=xt.computeQuatTerm(e[0][2]-e[2][0],t.y,o,r[3])):2===a?(t.z=.5*Math.sqrt(r[2]),o=1/(4*t.z),t.x=xt.computeQuatTerm(e[0][2]+e[2][0],t.z,o,r[0]),t.y=xt.computeQuatTerm(e[1][2]+e[2][1],t.z,o,r[1]),t.w=xt.computeQuatTerm(e[1][0]-e[0][1],t.z,o,r[3])):(t.w=.5*Math.sqrt(r[3]),o=1/(4*t.w),t.x=xt.computeQuatTerm(e[2][1]-e[1][2],t.w,o,r[0]),t.y=xt.computeQuatTerm(e[0][2]-e[2][0],t.w,o,r[1]),t.z=xt.computeQuatTerm(e[1][0]-e[0][1],t.w,o,r[2])),t}}xt.useCachedInverse=!0,xt.numUseCache=0,xt.numComputeCache=0,xt._productBuffer=new Float64Array(9);class _t extends tt{constructor(t,e){super(),this._origin=t,this._normal=e}static _create(t,e,i,s,n,r){return new _t(j.create(t,e,i),$.create(s,n,r))}static createXYPlane(t){return t?_t._create(t.x,t.y,t.z,0,0,1):_t._create(0,0,0,0,0,1)}static createYZPlane(t){return t?_t._create(t.x,t.y,t.z,1,0,0):_t._create(0,0,0,1,0,0)}static createZXPlane(t){return t?_t._create(t.x,t.y,t.z,0,1,0):_t._create(0,0,0,0,1,0)}static create(t,e,i){if(i){if(void 0===e.normalize(i._normal))return;return t.clone(i._origin),i}const s=e.normalize();if(void 0!==s)return new _t(t.clone(),s)}static createFrom(t,e){if(t instanceof _t)return t.clone(e);if(e){if(void 0===t.getUnitNormal(e._normal))return;return t.getAnyPointOnPlane(e._origin),e}const i=t.getUnitNormal();if(void 0===i)return;const s=t.getAnyPointOnPlane();return new _t(s,i)}static createXYZUVW(t,e,i,s,n,r,o){const a=Q.hypotenuseXYZ(s,n,r);if(!(a<Q.smallMetricDistance))return o?(o._origin.set(t,e,i),o._normal.set(s/a,n/a,r/a),o):new _t(j.create(t,e,i),$.create(s/a,n/a,r/a))}static createOriginAndTargetXY(t,e,i){const s=e.x-t.x,n=e.y-t.y;return this.createXYZUVW(t.x,t.y,0,n,-s,0,i)}static createXYAngle(t,e,i,s){return s?(s._origin.set(t,e,0),s._normal.set(i.cos(),i.sin(),0),s):new _t(j.create(t,e,0),$.create(i.cos(),i.sin()))}static createPointPointVectorInPlane(t,e,i){const s=i.crossProductStartEnd(t,e);if(s.tryNormalizeInPlace())return new _t(t,s)}static createOriginAndTargets(t,e,i){const s=t.crossProductToPoints(e,i);if(s.tryNormalizeInPlace())return new _t(t,s)}static createOriginAndVectors(t,e,i){const s=e.crossProduct(i);if(s.tryNormalizeInPlace())return new _t(t,s)}isAlmostEqual(t){return this._origin.isAlmostEqual(t._origin)&&this._normal.isAlmostEqual(t._normal)}setFromJSON(t){t?(this._origin.setFromJSON(t.origin),this._normal.setFromJSON(t.normal)):(this._origin.set(0,0,0),this._normal.set(0,0,1))}toJSON(){return{origin:this._origin.toJSON(),normal:this._normal.toJSON()}}static fromJSON(t){const e=_t.createXYPlane();return e.setFromJSON(t),e}getOriginRef(){return this._origin}getNormalRef(){return this._normal}getLocalToWorld(){const t=xt.createRigidHeadsUp(this._normal,g.ZXY);return pt.createRefs(this._origin.clone(),t)}getProjectionToPlane(){const t=xt.createIdentity();return t.addScaledOuterProductInPlace(this._normal,this._normal,-1),t.markSingular(),pt.createFixedPointAndMatrix(this._origin,t)}set(t,e){this._origin.setFrom(t),this._normal.setFrom(e)}clone(t){return t?(t.set(this._origin,this._normal),t):new _t(this._origin.clone(),this._normal.clone())}cloneTransformed(t,e=!1){const i=this.clone();if(e){if(t.multiplyInversePoint3d(i._origin,i._origin),void 0!==t.matrix.multiplyTransposeVector(i._normal,i._normal)&&i._normal.normalizeInPlace())return i}else if(t.multiplyPoint3d(i._origin,i._origin),void 0!==t.matrix.multiplyInverseTranspose(i._normal,i._normal)&&i._normal.normalizeInPlace())return i}setFrom(t){this.set(t._origin,t._normal)}altitude(t){return this._normal.dotProductStartEnd(this._origin,t)}altitudeXY(t,e){return(t-this._origin.x)*this._normal.x+(e-this._origin.y)*this._normal.y}normalX(){return this._normal.x}normalY(){return this._normal.y}normalZ(){return this._normal.z}getUnitNormal(t){return this._normal.clone(t)}getAnyPointOnPlane(t){return this._origin.clone(t)}weightedAltitude(t){return this._normal.dotProductStart3dEnd4d(this._origin,t)}altitudeToPoint(t,e){return this._origin.plusScaled(this._normal,t,e)}velocityXYZ(t,e,i){return this._normal.dotProductXYZ(t,e,i)}velocity(t){return this._normal.dotProduct(t)}altitudeXYZ(t,e,i){return this._normal.dotProductStartEndXYZ(this._origin,t,e,i)}altitudeXYZW(t,e,i,s){return this._normal.dotProductStartEndXYZW(this._origin,t,e,i,s)}projectPointToPlane(t,e){return t.plusScaled(this._normal,-this._normal.dotProductStartEnd(this._origin,t),e)}isPointInPlane(t,e=Q.smallMetricDistance){const i=this._normal.dotProductStartEnd(this._origin,t);return Math.abs(i)<=e}}function yt(t,e){return t?t.clone(e):void 0}!function(t){t[t.isolated=0]="isolated",t[t.isolatedAtVertex=1]="isolatedAtVertex",t[t.intervalStart=10]="intervalStart",t[t.intervalInterior=11]="intervalInterior",t[t.intervalEnd=12]="intervalEnd"}(P||(P={})),function(t){t[t.error=0]="error",t[t.success=1]="success",t[t.stoppedAtBoundary=2]="stoppedAtBoundary"}(A||(A={}));class vt{constructor(){this.pointQ=j.createZero(),this.fraction=0,this.point=j.createZero(),this.a=0}setIntervalRole(t){this.intervalRole=t}captureFraction1Point1(t,e){this.fraction1=t,this.point1=e}get hasFraction1(){return void 0!==this.fraction1}get isIsolated(){return void 0===this.intervalRole||this.intervalRole===P.isolated||this.intervalRole===P.isolatedAtVertex}get fractionDelta(){return void 0!==this.fraction1?this.fraction1-this.fraction:0}collapseToEnd(){void 0!==this.fraction1&&(this.fraction=this.fraction1),this.point1&&(this.point=this.point1),this.collapseToStart()}collapseToStart(){this.fraction1=void 0,this.point1=void 0}clone(t){return t===this||((t=t||new vt).curve=this.curve,t.fraction=this.fraction,t.fraction1=this.fraction1,t.point1=yt(this.point1,t.point1),t.point.setFromPoint3d(this.point),t.vectorInCurveLocationDetail=yt(this.vectorInCurveLocationDetail,t.vectorInCurveLocationDetail),t.a=this.a,t.childDetail=yt(this.childDetail,t.childDetail),t.curveSearchStatus=this.curveSearchStatus),t}setFP(t,e,i,s=0){this.fraction=t,this.point.setFromPoint3d(e),this.vectorInCurveLocationDetail=yt(i,this.vectorInCurveLocationDetail),this.a=s}setFR(t,e,i=0){return this.setFP(t,e.origin,e.direction,i)}setCurve(t){this.curve=t}setDistanceTo(t){this.a=this.point.distance(t)}static create(t,e){return(e=e||new vt).curve=t,e}static createCurveFractionPoint(t,e,i,s){return(s=s||new vt).curve=t,s.fraction=e,s.point.setFromPoint3d(i),s.vectorInCurveLocationDetail=void 0,s.a=0,s.childDetail=void 0,s.curveSearchStatus=void 0,s}static createRayFractionPoint(t,e,i,s){return(s=s||new vt).fraction=e,s.ray=t,s.point.setFromPoint3d(i),s}static createCurveFractionPointDistanceCurveSearchStatus(t,e,i,s,n,r){return(r=r||new vt).curve=t,r.fraction=e,r.point.setFromPoint3d(i),r.vectorInCurveLocationDetail=void 0,r.a=s,r.childDetail=void 0,r.curveSearchStatus=n,r}static createConditionalMoveSignedDistance(t,e,i,s,n,r){let o=n,a=A.success;return t||Q.isIn01(s)||(s<0?(o=-e.curveLengthBetweenFractions(i,0),s=0,a=A.stoppedAtBoundary):s>1&&(s=1,o=e.curveLengthBetweenFractions(i,1),a=A.stoppedAtBoundary)),(r=r||new vt).curve=e,r.fraction=s,e.fractionToPoint(s,r.point),r.vectorInCurveLocationDetail=void 0,r.a=o,r.childDetail=void 0,r.curveSearchStatus=a,r}static createCurveEvaluatedFraction(t,e,i){return(i=i||new vt).curve=t,i.fraction=e,t.fractionToPoint(e,i.point),i.vectorInCurveLocationDetail=void 0,i.a=0,i.childDetail=void 0,i.curveSearchStatus=void 0,i}static createCurveEvaluatedFractionPointAndDerivative(t,e,i){(i=i||new vt).curve=t,i.fraction=e;const s=t.fractionToPointAndDerivative(e);return i.point.setFromPoint3d(s.origin),i.vectorInCurveLocationDetail=s.direction,i.a=0,i.childDetail=void 0,i.curveSearchStatus=void 0,i}static createCurveEvaluatedFractionFraction(t,e,i,s){return(s=s||new vt).curve=t,s.fraction=e,t.fractionToPoint(e,s.point),s.fraction1=i,s.point1=t.fractionToPoint(i,s.point1),s.vectorInCurveLocationDetail=void 0,s.a=0,s.childDetail=void 0,s.curveSearchStatus=void 0,s}static createCurveFractionPointDistance(t,e,i,s,n){return(n=n||new vt).curve=t,n.fraction=e,n.point.setFromPoint3d(i),n.vectorInCurveLocationDetail=void 0,n.a=s,n.childDetail=void 0,n.curveSearchStatus=void 0,n}updateIfCloserCurveFractionPointDistance(t,e,i,s){return!(this.a<s||(vt.createCurveFractionPointDistance(t,e,i,s,this),0))}swapFractionsAndPoints(){if(void 0!==this.fraction1){const t=this.fraction;this.fraction=this.fraction1,this.fraction1=t}if(void 0!==this.point1){const t=this.point;this.point=this.point1,this.point1=t}}inverseInterpolateFraction(t,e=0){const i=Q.inverseInterpolate01(this.fraction,this.fraction1,t);return void 0===i?e:i}static chooseSmallerA(t,e){return t?e?t.a<=e.a?t:e:t:e}isSameCurveAndFraction(t){return this.curve===t.curve&&Q.isAlmostEqualNumber(this.fraction,t.fraction)}tryTransformInPlace(t){return!(this.curve&&!this.curve.tryTransformInPlace(t)||(this.ray&&this.ray.transformInPlace(t),this.curve?this.curve.fractionToPoint(this.fraction,this.point):t.multiplyXYAndZInPlace(this.point),this.vectorInCurveLocationDetail&&t.multiplyVectorInPlace(this.vectorInCurveLocationDetail),this.childDetail&&this.childDetail!==this&&!this.childDetail.tryTransformInPlace(t)||(this.point1&&(this.curve&&this.fraction1?this.curve.fractionToPoint(this.fraction1,this.point1):t.multiplyXYAndZInPlace(this.point1)),0)))}}!function(t){t[t.Intersection=0]="Intersection",t[t.PerpendicularChord=1]="PerpendicularChord",t[t.CoincidentGeometry=2]="CoincidentGeometry",t[t.ParallelGeometry=3]="ParallelGeometry"}(I||(I={}));class Pt{constructor(t,e){this.detailA=t||new vt,this.detailB=e||new vt}static createCapture(t,e,i){return(i=i||new Pt).detailA=t,i.detailB=e,i}static createCaptureOptionalReverse(t,e,i,s){return(s=s||new Pt).detailA=t,s.detailB=e,s}clone(t){return(t=t||new Pt).detailA=this.detailA.clone(),t.detailB=this.detailB.clone(),t.approachType=this.approachType,t}swapDetails(){const t=this.detailA;this.detailA=this.detailB,this.detailB=t}static removeAdjacentDuplicates(t,e=0){return t.flatMap(((t,i,s)=>i>=e&&i>0&&!t.detailA.hasFraction1&&!t.detailB.hasFraction1&&t.detailA.isSameCurveAndFraction(s[i-1].detailA)&&t.detailB.isSameCurveAndFraction(s[i-1].detailB)?[]:[t]))}tryTransformInPlace(t){return this.detailA.tryTransformInPlace(t)&&this.detailB.tryTransformInPlace(t)}}class At{get startDegrees(){return W.radiansToDegrees(this._radians0)}get endDegrees(){return W.radiansToDegrees(this._radians1)}get sweepDegrees(){return W.radiansToDegrees(this._radians1-this._radians0)}get startRadians(){return this._radians0}get endRadians(){return this._radians1}get sweepRadians(){return this._radians1-this._radians0}get isEmpty(){return W.isAlmostEqualRadiansNoPeriodShift(0,this.sweepRadians)}get startAngle(){return W.createRadians(this._radians0)}get endAngle(){return W.createRadians(this._radians1)}static create(t){return t instanceof At?t.clone():t instanceof W?new At(0,t.radians):At.create360()}constructor(t=0,e=0){this._radians0=t,this._radians1=e}setStartEndRadians(t=0,e=2*Math.PI){const i=e-t;W.isFullCircleRadians(i)&&(e=t+(i>0?2:-2)*Math.PI),this._radians0=t,this._radians1=e}setStartEndDegrees(t=0,e=360){this.setStartEndRadians(W.degreesToRadians(t),W.degreesToRadians(e))}static createStartEndRadians(t=0,e=2*Math.PI,i){return(i=i||new At).setStartEndRadians(t,e),i}cloneMinusRadians(t){return new At(this._radians0-t,this._radians1-t)}static createStartEndDegrees(t=0,e=360,i){return At.createStartEndRadians(W.degreesToRadians(t),W.degreesToRadians(e),i)}static createStartEnd(t,e,i){return(i=i||new At).setStartEndRadians(t.radians,e.radians),i}static createStartSweepRadians(t=0,e=Math.PI,i){return(i=i||new At).setStartEndRadians(t,t+e),i}static createStartSweepDegrees(t=0,e=360,i){return At.createStartEndRadians(W.degreesToRadians(t),W.degreesToRadians(t+e),i)}static createStartSweep(t,e,i){return At.createStartSweepRadians(t.radians,e.radians,i)}interpolate(t,e){return new At(Q.interpolate(this._radians0,t,e._radians0),Q.interpolate(this._radians1,t,e._radians1))}setFrom(t){this._radians0=t._radians0,this._radians1=t._radians1}static create360(t){return new At(t=t||0,t+2*Math.PI)}static createFullLatitude(){return At.createStartEndRadians(-.5*Math.PI,.5*Math.PI)}reverseInPlace(){const t=this._radians0;this._radians0=this._radians1,this._radians1=t}cloneComplement(t=!1,e){const i=this.sweepRadians>=0?2:-2;return t?At.createStartEndRadians(this.startRadians,this.endRadians-i*Math.PI,e):At.createStartEndRadians(this.endRadians,this.startRadians+i*Math.PI,e)}capLatitudeInPlace(){const t=.5*Math.PI;this._radians0=Q.clampToStartEnd(this._radians0,-t,t),this._radians1=Q.clampToStartEnd(this._radians1,-t,t)}get isCCW(){return this._radians1>=this._radians0}get isFullCircle(){return W.isFullCircleRadians(this.sweepRadians)}get isFullLatitudeSweep(){const t=.5*Math.PI;return W.isAlmostEqualRadiansNoPeriodShift(this._radians0,-t)&&W.isAlmostEqualRadiansNoPeriodShift(this._radians1,t)}clone(){return new At(this._radians0,this._radians1)}fractionToRadians(t){return t<.5?this._radians0+t*(this._radians1-this._radians0):this._radians1+(t-1)*(this._radians1-this._radians0)}fractionToAngle(t){return W.createRadians(this.fractionToRadians(t))}fractionPeriod(){return this.isEmpty?1:W.pi2Radians/Math.abs(this._radians1-this._radians0)}angleToUnboundedFraction(t){return this.isEmpty?1:(t.radians-this._radians0)/(this._radians1-this._radians0)}static fractionToSignedPeriodicFractionStartEnd(t,e,i,s){const n=i-e;if(W.isAlmostEqualRadiansNoPeriodShift(0,n))return t;if(Q.isIn01(t))return t;const r=W.pi2Radians/Math.abs(n);return(t%=r)+r<1&&(t+=r),Q.isIn01(t)||s&&t<0||!s&&t>1?t:s?t-r:t+r}fractionToSignedPeriodicFraction(t,e){return At.fractionToSignedPeriodicFractionStartEnd(t,this._radians0,this._radians1,e)}static radiansToPositivePeriodicFractionStartEnd(t,e,i,s=0){const n=Q.largeCoordinateResult;let r=this.radiansToSignedPeriodicFractionStartEnd(t,e,i,n);return r===n?s:(r<0&&(r+=W.pi2Radians/Math.abs(i-e)),r)}radiansToPositivePeriodicFraction(t,e=0){return At.radiansToPositivePeriodicFractionStartEnd(t,this._radians0,this._radians1,e)}angleToPositivePeriodicFraction(t,e=0){return this.radiansToPositivePeriodicFraction(t.radians,e)}radiansArrayToPositivePeriodicFractions(t){const e=t.length;for(let i=0;i<e;i++)t.reassign(i,this.radiansToPositivePeriodicFraction(t.atUncheckedIndex(i)))}static radiansToSignedPeriodicFractionStartEnd(t,e,i,s=0){const n=i-e;if(W.isAlmostEqualRadiansNoPeriodShift(0,n))return s;if(W.isAlmostEqualRadiansAllowPeriodShift(e,i)){if(W.isAlmostEqualRadiansNoPeriodShift(t,e))return 0;if(W.isAlmostEqualRadiansNoPeriodShift(t,i))return 1}else{if(W.isAlmostEqualRadiansAllowPeriodShift(t,e))return 0;if(W.isAlmostEqualRadiansAllowPeriodShift(t,i))return 1}const r=(t-e)/n;return this.fractionToSignedPeriodicFractionStartEnd(r,e,i,r<0)}radiansToSignedPeriodicFraction(t,e=0){return At.radiansToSignedPeriodicFractionStartEnd(t,this._radians0,this._radians1,e)}angleToSignedPeriodicFraction(t,e=0){return this.radiansToSignedPeriodicFraction(t.radians,e)}static radiansToSignedFractionStartEnd(t,e,i,s=!1,n=0){const r=Q.largeCoordinateResult;let o=this.radiansToSignedPeriodicFractionStartEnd(t,e,i,r);if(o===r)return n;if(s&&o>1||!s&&o<0){let t=W.pi2Radians/Math.abs(i-e);s&&(t=-t),o+=t}return o}radiansToSignedFraction(t,e=!1,i=0){return At.radiansToSignedFractionStartEnd(t,this._radians0,this._radians1,e,i)}angleToSignedFraction(t,e=!1,i=0){return this.radiansToSignedFraction(t.radians,e,i)}static isRadiansInStartEnd(t,e,i,s=!0){return(t-e)*(t-i)<=0||(e===i?s?W.isAlmostEqualRadiansAllowPeriodShift(t,e):W.isAlmostEqualRadiansNoPeriodShift(t,e):!!s&&this.radiansToPositivePeriodicFractionStartEnd(t,e,i,1e3)<=1)}isRadiansInSweep(t,e=!0){return At.isRadiansInStartEnd(t,this.startRadians,this.endRadians,e)}isAngleInSweep(t){return this.isRadiansInSweep(t.radians)}setFromJSON(t){t?t instanceof At?this.setFrom(t):Q.isNumberArray(t.degrees,2)?this.setStartEndDegrees(t.degrees[0],t.degrees[1]):Q.isNumberArray(t.radians,2)?this.setStartEndRadians(t.radians[0],t.radians[1]):Q.isNumberArray(t,2)?this.setStartEndDegrees(t[0],t[1]):this.setStartEndRadians():this.setStartEndRadians()}static fromJSON(t){const e=At.create360();return e.setFromJSON(t),e}toJSON(){return[this.startDegrees,this.endDegrees]}isAlmostEqualAllowPeriodShift(t,e=Q.smallAngleRadians){return this.isCCW===t.isCCW&&W.isAlmostEqualRadiansAllowPeriodShift(this._radians0,t._radians0,e)&&W.isAlmostEqualRadiansAllowPeriodShift(this._radians1-this._radians0,t._radians1-t._radians0,e)}isAlmostEqualNoPeriodShift(t,e=Q.smallAngleRadians){return W.isAlmostEqualRadiansNoPeriodShift(this._radians0,t._radians0,e)&&W.isAlmostEqualRadiansNoPeriodShift(this._radians1-this._radians0,t._radians1-t._radians0,e)}isAlmostEqual(t){return this.isAlmostEqualNoPeriodShift(t)}}class It{constructor(t=8,e){this._data=new Float64Array(t),this._inUse=0,this._growthFactor=void 0!==e&&e>=1?e:1.5}copyData(t,e,i){let s=i??0;if(s<0&&(s=0),s>=this._data.length)return{count:0,offset:0};let n=e??t.length;return n>0&&(n>t.length&&(n=t.length),s+n>this._data.length&&(n=this._data.length-s)),n<=0?{count:0,offset:0}:(n===t.length?this._data.set(t,s):t instanceof Float64Array?this._data.set(t.subarray(0,n),s):this._data.set(t.slice(0,n),s),{count:n,offset:s})}static create(t){const e=new It(t.length);return e.copyData(t),e._inUse=t.length,e}static compare(t,e){return t-e}clone(t=!1){const e=new It(t?this.capacity():this._inUse);return e.copyData(this._data,this._inUse),e._inUse=this._inUse,e}get length(){return this._inUse}setAtUncheckedIndex(t,e){this._data[t]=e}move(t,e){this._data[e]=this._data[t]}swap(t,e){const i=this._data[t];this._data[t]=this._data[e],this._data[e]=i}push(t){this.ensureCapacity(this._inUse+1),this._data[this._inUse]=t,this._inUse++}pushArray(t){this.ensureCapacity(this._inUse+t.length),this.copyData(t,t.length,this._inUse),this._inUse+=t.length}pushBlockCopy(t,e){t>=0&&t<this._inUse&&e>0&&t+e<=this._inUse&&(this.ensureCapacity(this._inUse+e),this._data.copyWithin(this._inUse,t,t+e),this._inUse+=e)}clear(){this._inUse=0}capacity(){return this._data.length}ensureCapacity(t,e=!0){if(t>this.capacity()){e&&(t*=this._growthFactor);const i=this._data;this._data=new Float64Array(t),this.copyData(i,this._inUse)}}resize(t,e=0){t>=0&&t<this._inUse?this._inUse=t:t>this._inUse&&(this.ensureCapacity(t,!1),this._data.fill(e,this._inUse),this._inUse=t)}pop(){this._inUse>0&&this._inUse--}atUncheckedIndex(t){return this._data[t]}front(){return this._data[0]}back(){return this._data[this._inUse-1]}reassign(t,e){this._data[t]=e}sort(t=(t,e)=>It.compare(t,e)){for(let e=0;e<this._inUse;e++)for(let i=e+1;i<this._inUse;i++){const s=this._data[e],n=this._data[i];t(s,n)>0&&(this._data[e]=n,this._data[i]=s)}}restrictToInterval(t,e){const i=this._data,s=i.length;let n=0,r=0;for(let o=0;o<s;o++)r=i[o],r>=t&&r<=e&&(i[n++]=r);this._inUse=n}compressAdjacentDuplicates(t=0){const e=this._data,i=this._inUse;if(0===i)return;let s,n=1,r=e[0];for(let o=1;o<i;o++)s=e[o],Math.abs(s-r)>t&&(e[n++]=s,r=s);this._inUse=n}}class St{constructor(t=0,e=0,i=0){this.coffs=[t,e,i]}static solveQuadratic(t,e,i){const s=Q.conditionalDivideFraction(e,t),n=Q.conditionalDivideFraction(i,t);if(void 0!==s&&void 0!==n){const t=s*s-4*n;if(t>0){const e=Math.sqrt(t);return[.5*(-s-e),.5*(-s+e)]}if(t<0)return;const e=-.5*s;return[e,e]}const r=Q.conditionalDivideFraction(-i,e);if(void 0!==r)return[r]}addConstant(t){this.coffs[0]+=t}addSquaredLinearTerm(t,e,i=1){this.coffs[0]+=i*(t*t),this.coffs[1]+=i*(2*t*e),this.coffs[2]+=i*(e*e)}realRoots(){const t=St.solveQuadratic(this.coffs[2],this.coffs[1],this.coffs[0]);if(t&&t.length>1&&t[0]>t[1]){const e=t[0];t[0]=t[1],t[1]=e}return t}evaluate(t){return this.coffs[0]+t*(this.coffs[1]+t*this.coffs[2])}evaluateDerivative(t){return this.coffs[1]+2*t*this.coffs[2]}tryGetVertexFactorization(){const t=Q.conditionalDivideFraction(-this.coffs[1],2*this.coffs[2]);if(void 0!==t){const e=this.evaluate(t);return{c:this.coffs[2],x0:t,y0:e}}}static fromRootsAndC2(t,e,i=1){return new St(i*t*e,-i*(t+e),i)}}class wt{static isZero(t){return Math.abs(t)<this._EQN_EPS}static isSmallRatio(t,e,i=1e-9,s=8e-16){return Math.abs(t)<=i||Math.abs(t)<s*Math.abs(e)}static cbrt(t){return t>0?Math.pow(t,1/3):t<0?-Math.pow(-t,1/3):0}static safeDivide(t,e,i,s=0,n){return Math.abs(i)>this._safeDivideFactor*Math.abs(e)?(t[n]=e/i,!0):(t[n]=s,!1)}static checkRootProximity(t,e){return 0===e?t.atUncheckedIndex(e)<t.atUncheckedIndex(e+1):e>0&&e+1<t.length?t.atUncheckedIndex(e)>t.atUncheckedIndex(e-1)&&t.atUncheckedIndex(e)<t.atUncheckedIndex(e+1):t.atUncheckedIndex(e)>t.atUncheckedIndex(e-1)}static newtonMethodAdjustment(t,e,i){let s=t[i],n=0;for(let r=i-1;r>=0;r--)n=s+e*n,s=t[r]+e*s;if(Math.abs(n)>=1e-14*(1+Math.abs(e)))return s/n}static improveRoots(t,e,i,s){for(let n=0;n<i.length;n++){let r=this.newtonMethodAdjustment(t,i.atUncheckedIndex(n),e);if(void 0===r||0===r)continue;const o=i.atUncheckedIndex(n);let a=0,c=0;for(;void 0!==r&&0!==r&&a<12;){if(Math.abs(r)<1e-10*(1+Math.abs(i.atUncheckedIndex(n)))){if(++c>1)break}else c=0;const l=i.atUncheckedIndex(n)-r;if(i.reassign(n,l),s&&!this.checkRootProximity(i,n)){i.reassign(n,o);break}r=this.newtonMethodAdjustment(t,i.atUncheckedIndex(n),e),a++}}}static appendSolution(t,e){void 0!==t&&e.push(t)}static append2Solutions(t,e,i){i.push(t),i.push(e)}static appendLinearRoot(t,e,i){wt.appendSolution(Q.conditionalDivideFraction(-t,e),i)}static mostDistantFromMean(t){if(!t||0===t.length)return 0;let e=0;for(let i=0;i<t.length;i++)e+=t.atUncheckedIndex(i);e/=t.length;let i=0,s=t.atUncheckedIndex(0);for(let n=0;n<t.length;n++){const r=Math.abs(t.atUncheckedIndex(n)-e);r>i&&(i=r,s=t.atUncheckedIndex(n))}return s}static appendQuadraticRoots(t,e){const i=Q.conditionalDivideFraction(1,t[2]);if(!i)return void this.appendLinearRoot(t[0],t[1],e);const s=.5*t[1]*i,n=s*s-t[0]*i;if(this.isZero(n))this.appendSolution(-s,e);else if(!(n<0)&&n>0){const t=Math.sqrt(n);this.append2Solutions(t-s,-t-s,e)}}static addConstant(t,e){for(let i=0;i<e.length;i++)e.reassign(i,e.atUncheckedIndex(i)+t)}static signedCubeRoot(t){return t>=0?Math.pow(t,1/3):-Math.pow(-t,1/3)}static appendFullCubicSolutions(t,e,i,s,n){const r=(e*e-3*t*i)/(t*t*9),o=-e/(3*t),a=s+o*(i+o*(e+o*t)),c=4*t*t*r*r*r,l=a*a-c;if(l>0){const e=Math.sqrt(l),i=.5/t;n.push(o+this.signedCubeRoot(i*(-a+e))+this.signedCubeRoot(i*(-a-e)))}else if(l<0){let e=Math.sqrt(c);t<0&&(e=-e);const i=Math.acos(-a/e)/3,s=2*Math.sqrt(r),l=2*Math.PI/3;n.push(o+s*Math.cos(i)),n.push(o+s*Math.cos(i+l)),n.push(o+s*Math.cos(i-l))}else{const e=this.signedCubeRoot(.5*a/t),i=o+e;n.push(o-2*e),n.push(i),n.push(i)}}static appendCubicRoots(t,e){void 0!==Q.conditionalDivideCoordinate(1,t[3])?(this.appendFullCubicSolutions(t[3],t[2],t[1],t[0],e),this.improveRoots(t,3,e,!1)):this.appendQuadraticRoots(t,e),e.sort()}static appendQuarticRoots(t,e){const i=new Float64Array(4);let s,n;const r=new Float64Array(1);if(!this.safeDivide(r,1,t[4],0,0))return void this.appendCubicRoots(t,e);const o=t[3]*r[0],a=t[2]*r[0],c=t[1]*r[0],l=-.25*o,h=o*o,d=-.375*h+a,u=.125*h*o-.5*o*a+c,f=-.01171875*h*h+.0625*h*a-.25*o*c+t[0]*r[0],g=new It;if(this.isZero(f))return i[0]=u,i[1]=d,i[2]=0,i[3]=1,this.appendCubicRoots(i,e),e.push(0),void this.addConstant(l,e);{i[0]=.5*f*d-.125*u*u,i[1]=-f,i[2]=-.5*d,i[3]=1,this.appendCubicRoots(i,g);const t=this.mostDistantFromMean(g);if(s=t*t-f,n=2*t-d,this.isSmallRatio(s,f))s=0;else{if(!(s>0))return;s=Math.sqrt(s)}if(this.isSmallRatio(n,d))n=0;else{if(!(n>0))return;n=Math.sqrt(n)}i[0]=t-s,i[1]=u<0?-n:n,i[2]=1,this.appendQuadraticRoots(i,e),i[0]=t+s,i[1]=u<0?n:-n,i[2]=1,this.appendQuadraticRoots(i,e)}this.addConstant(l,e),e.sort(),this.improveRoots(t,4,e,!0)}static appendCosSinRadians(t,e,i,s,n){i&&i.push(t),s&&s.push(e),n&&n.push(Math.atan2(e,t))}static appendImplicitLineUnitCircleIntersections(t,e,i,s,n,r,o=1e-14){let a;const c=e*e+i*i;let l=0;if(a=o<0?0:2*o,c<=0)l=0===t?-2:-1;else{const o=-t/c,h=1-t*t/c;if(h<-a){const a=Math.sqrt(c),h=t<0?1/a:-1/a;this.appendCosSinRadians(o*e,o*i,s,n,r),this.appendCosSinRadians(e*h,i*h,s,n,r),l=0}else if(h<a){const a=Math.sqrt(c),h=t<0?1/a:-1/a;this.appendCosSinRadians(o*e,o*i,s,n,r),this.appendCosSinRadians(e*h,i*h,s,n,r),l=1}else{const t=Math.sqrt(h/c),a=o*e,d=o*i;this.appendCosSinRadians(a-t*i,d+t*e,s,n,r),this.appendCosSinRadians(a+t*i,d-t*e,s,n,r),l=2}}return l}}wt._EQN_EPS=1e-9,wt._safeDivideFactor=1e-14;class Ct{static degreeKnownEvaluate(t,e,i){if(e<0)return 0;let s=t[e];for(let n=e-1;n>=0;n--)s=i*s+t[n];return s}static evaluate(t,e){const i=t.length-1;return this.degreeKnownEvaluate(t,i,e)}static accumulate(t,e,i){let s=t.length-1;const n=e.length-1;for(let s=0;s<=n;s++)t[s]+=i*e[s];for(;s>=0&&0===t[s];)s--;return s}static zero(t){for(let e=0;e<t.length;e++)t[e]=0}}class Tt{static solveAngles(t,i,s,n){let r,o=Math.abs(s);n.length=0;const a=this._smallAngle;for(let e=0;e<=i;e++)r=Math.abs(t[e]),r>o&&(o=r);const c=a*o;let l=i;for(;l>0&&Math.abs(t[l])<=c;)l--;const h=new It;if(-1===l);else{if(0===l||(1===l?h.push(-t[0]/t[1]):2===l?wt.appendQuadraticRoots(t,h):3===l?wt.appendCubicRoots(t,h):4===l?wt.appendQuarticRoots(t,h):e(!1,"Unimplemented degree in trig solver")),h.length>0)for(let t=0;t<h.length;t++){const e=Ct.evaluate(this.S,h.atUncheckedIndex(t)),i=Ct.evaluate(this.C,h.atUncheckedIndex(t));n.push(Math.atan2(e,i))}l<i&&n.push(-.5*Math.PI)}return n.length>0}static solveUnitCircleImplicitQuadricIntersection(t,e,i,s,n,r,o){const a=new Float64Array(5);let c;Ct.zero(a),Q.hypotenuseXYZ(t,e,i)>Tt._coefficientRelTol*Q.hypotenuseXYZ(s,n,r)?(Ct.accumulate(a,this.CW,s),Ct.accumulate(a,this.SW,n),Ct.accumulate(a,this.WW,r),Ct.accumulate(a,this.SS,i),Ct.accumulate(a,this.CC,t),Ct.accumulate(a,this.SC,e),c=4):(Ct.accumulate(a,this.C,s),Ct.accumulate(a,this.S,n),Ct.accumulate(a,this.W,r),c=2);const l=Math.max(Math.abs(t),Math.abs(i),Math.abs(e),Math.abs(s),Math.abs(n),Math.abs(r));return this.solveAngles(a,c,l,o)}static solveUnitCircleEllipseIntersection(t,e,i,s,n,r,o,a){a.length=0;const c=i*i+s*s,l=2*(i*n+s*r),h=n*n+r*r,d=2*(i*t+s*e),u=2*(n*t+r*e),f=t*t+e*e-1,g=this.solveUnitCircleImplicitQuadricIntersection(c,l,h,d,u,f,o);for(const c of o){const o=Math.cos(c),l=Math.sin(c),h=t+i*o+n*l,d=e+s*o+r*l;a.push(Math.atan2(d,h))}return g}static solveUnitCircleHomogeneousEllipseIntersection(t,e,i,s,n,r,o,a,c,l,h){h.length=0;const d=s*s+n*n-r*r,u=2*(s*o+n*a-r*c),f=o*o+a*a-c*c,g=2*(s*t+n*e-r*i),p=2*(o*t+a*e-c*i),m=t*t+e*e-i*i,x=this.solveUnitCircleImplicitQuadricIntersection(d,u,f,g,p,m,l);for(const i of l){const r=Math.cos(i),c=Math.sin(i),l=t+s*r+o*c,d=e+n*r+a*c;h.push(Math.atan2(d,l))}return x}}Tt._smallAngle=1e-11,Tt.S=Float64Array.from([0,2,-2]),Tt.C=Float64Array.from([1,-2]),Tt.W=Float64Array.from([1,-2,2]),Tt.CW=Float64Array.from([1,-4,6,-4]),Tt.SW=Float64Array.from([0,2,-6,8,-4]),Tt.SC=Float64Array.from([0,2,-6,4]),Tt.SS=Float64Array.from([0,0,4,-8,4]),Tt.CC=Float64Array.from([1,-4,4]),Tt.WW=Float64Array.from([1,-4,8,-8,4]),Tt.CCMinusSS=Float64Array.from([1,-4,0,8,-4]),Tt._coefficientRelTol=1e-12;class Ft{constructor(t,e,i,s){this.a=t,this.b=e,this.c=i,this.d=s}evaluate(t,e){return this.a+this.b*t+e*(this.c+this.d*t)}static createUnitSquareValues(t,e,i,s){return new Ft(t,e,e,s-e-i)}static solveBilinearPair(t,e,i,s,n,r,o,a){const c=Q.crossProductXYXY(t,n,i,o),l=Q.crossProductXYXY(e,r,i,o)+Q.crossProductXYXY(t,n,s,a),h=Q.crossProductXYXY(e,r,s,a),d=St.solveQuadratic(h,l,c);if(void 0===d)return;const u=[];for(const c of d){const l=Q.conditionalDivideFraction(-(t+e*c),i+s*c),h=Q.conditionalDivideFraction(-(n+r*c),o+a*c);void 0!==l?u.push(H.create(c,l)):void 0!==h&&u.push(H.create(c,h))}return u}static solvePair(t,e,i,s){return Ft.solveBilinearPair(t.a-e,t.b,t.c,t.d,i.a-s,i.b,i.c,i.d)}}class kt{constructor(t,e,i){this.a=t,this.cosineCoff=e,this.sineCoff=i}set(t,e,i){this.a=t,this.cosineCoff=e,this.sineCoff=i}evaluateRadians(t){return this.a+this.cosineCoff*Math.cos(t)+this.sineCoff*Math.sin(t)}range(t){const e=Q.hypotenuseXY(this.cosineCoff,this.sineCoff);return ft.createXX(this.a-e,this.a+e,t)}rangeInStartEndRadians(t,e,i){if(W.isFullCircleRadians(e-t))return this.range(i);i=ft.createXX(this.evaluateRadians(t),this.evaluateRadians(e),i);const s=Math.atan2(this.sineCoff,this.cosineCoff),n=s+Math.PI;return At.isRadiansInStartEnd(s,t,e)&&i.extendX(this.evaluateRadians(s)),At.isRadiansInStartEnd(n,t,e)&&i.extendX(this.evaluateRadians(n)),i}rangeInSweep(t,e){return this.rangeInStartEndRadians(t.startRadians,t.endRadians,e)}referenceMinMaxRadians(){return Math.atan2(this.sineCoff,this.cosineCoff)}}class Mt{static lineSegment2dXYTransverseIntersectionUnbounded(t,e,i,s,n){const r=e.x-t.x,o=e.y-t.y,a=s.x-i.x,c=s.y-i.y,l=i.x-t.x,h=i.y-t.y,d=Q.crossProductXYXY(r,o,a,c),u=Q.crossProductXYXY(l,h,a,c),f=Q.crossProductXYXY(r,o,l,h),g=Q.conditionalDivideFraction(u,d),p=Q.conditionalDivideFraction(f,d);return void 0!==g&&void 0!==p?(n.set(g,-p),!0):(n.set(0,0),!1)}static lineSegmentXYUVTransverseIntersectionUnbounded(t,e,i,s,n,r,o,a,c){const l=n-t,h=r-e,d=Q.crossProductXYXY(i,s,o,a),u=Q.crossProductXYXY(l,h,o,a),f=Q.crossProductXYXY(i,s,l,h),g=Q.conditionalDivideFraction(u,d),p=Q.conditionalDivideFraction(f,d);return void 0!==g&&void 0!==p?(c.set(g,-p),!0):(c.set(0,0),!1)}static lineSegment3dXYTransverseIntersectionUnbounded(t,e,i,s,n){const r=e.x-t.x,o=e.y-t.y,a=s.x-i.x,c=s.y-i.y,l=i.x-t.x,h=i.y-t.y,d=Q.crossProductXYXY(r,o,a,c),u=Q.crossProductXYXY(l,h,a,c),f=Q.crossProductXYXY(r,o,l,h),g=Q.conditionalDivideFraction(u,d),p=Q.conditionalDivideFraction(f,d);return void 0!==g&&void 0!==p?(n.set(g,-p),!0):(n.set(0,0),!1)}static lineSegment3dHXYTransverseIntersectionUnbounded(t,e,i,s,n){const r=Q.tripleProduct(t.x,e.x,i.x,t.y,e.y,i.y,t.w,e.w,i.w),o=Q.tripleProduct(t.x,e.x,s.x,t.y,e.y,s.y,t.w,e.w,s.w),a=Q.conditionalDivideFraction(-r,o-r);if(void 0!==a){const r=Q.tripleProduct(i.x,s.x,t.x,i.y,s.y,t.y,i.w,s.w,t.w),o=Q.tripleProduct(i.x,s.x,e.x,i.y,s.y,e.y,i.w,s.w,e.w),c=Q.conditionalDivideFraction(-r,o-r);if(void 0!==c)return J.create(c,a,n)}}static lineSegment3dHXYClosestPointUnbounded(t,e,i){const s=e.x*t.w-t.x*e.w,n=e.y*t.w-t.y*e.w,r=Q.tripleProduct(t.x,-n,i.x,t.y,s,i.y,t.w,0,i.w),o=Q.tripleProduct(e.x,-n,i.x,e.y,s,i.y,e.w,0,i.w);return Q.conditionalDivideFraction(-r,o-r)}static lineSegment3dXYClosestPointUnbounded(t,e,i){const s=e.x-t.x,n=e.y-t.y,r=s*s+n*n,o=s*(i.x-t.x)+n*(i.y-t.y);return Q.conditionalDivideFraction(o,r)}static lineSegment3dClosestPointUnbounded(t,e,i){const s=e.x-t.x,n=e.y-t.y,r=e.z-t.z,o=s*s+n*n+r*r,a=s*(i.x-t.x)+n*(i.y-t.y)+r*(i.z-t.z);return Q.conditionalDivideFraction(a,o)}static lineSegment3dClosestApproachUnbounded(t,e,i,s,n){return this.ray3dXYZUVWClosestApproachUnbounded(t.x,t.y,t.z,e.x-t.x,e.y-t.y,e.z-t.z,i.x,i.y,i.z,s.x-i.x,s.y-i.y,s.z-i.z,n)}static ray3dXYZUVWClosestApproachUnbounded(t,e,i,s,n,r,o,a,c,l,h,d,u){const f=o-t,g=a-e,p=c-i,m=Q.hypotenuseSquaredXYZ(s,n,r),x=Q.hypotenuseSquaredXYZ(l,h,d),_=Q.dotProductXYZXYZ(s,n,r,l,h,d),y=Q.dotProductXYZXYZ(f,g,p,s,n,r),v=Q.dotProductXYZXYZ(f,g,p,l,h,d);return Mt.linearSystem2d(m,-_,_,-x,y,v,u)}static linearSystem2d(t,e,i,s,n,r,o){const a=Q.crossProductXYXY(t,i,e,s),c=Q.crossProductXYXY(n,r,e,s),l=Q.crossProductXYXY(t,i,n,r),h=Q.conditionalDivideFraction(c,a),d=Q.conditionalDivideFraction(l,a);return void 0!==h&&void 0!==d?(o.set(h,d),!0):(o.set(0,0),!1)}static linearSystem3d(t,e,i,s,n,r,o,a,c,l,h,d,u){const f=Q.tripleProduct(t,s,o,e,n,a,i,r,c),g=Q.tripleProduct(l,h,d,e,n,a,i,r,c),p=Q.tripleProduct(t,s,o,l,h,d,i,r,c),m=Q.tripleProduct(t,s,o,e,n,a,l,h,d),x=Q.conditionalDivideFraction(g,f),_=Q.conditionalDivideFraction(p,f),y=Q.conditionalDivideFraction(m,f);if(void 0!==x&&void 0!==_&&void 0!==y)return $.create(x,_,y,u)}static intersect3Planes(t,e,i,s,n,r,o){return this.linearSystem3d(e.x,e.y,e.z,s.x,s.y,s.z,r.x,r.y,r.z,Q.dotProductXYZXYZ(t.x,t.y,t.z,e.x,e.y,e.z),Q.dotProductXYZXYZ(i.x,i.y,i.z,s.x,s.y,s.z),Q.dotProductXYZXYZ(n.x,n.y,n.z,r.x,r.y,r.z),o)}static eliminateFromPivot(t,e,i,s){const n=t.length;let r=Q.conditionalDivideFraction(i[e],t[e]);if(void 0===r)return!1;r*=s;for(let s=e+1;s<n;s++)i[s]+=r*t[s];return!0}static solveBilinearPair(t,e,i,s,n,r,o,a){return Ft.solveBilinearPair(t,e,i,s,n,r,o,a)}}class bt{constructor(t,e){this.origin=t,this.direction=e,this.a=void 0}static _create(t,e,i,s,n,r){return new bt(j.create(t,e,i),$.create(s,n,r))}static createXAxis(){return bt._create(0,0,0,1,0,0)}static createYAxis(){return bt._create(0,0,0,0,1,0)}static createZAxis(){return bt._create(0,0,0,0,0,1)}static createZero(t){return t?(t.origin.setZero(),t.direction.setZero(),t):new bt(j.createZero(),$.createZero())}isAlmostEqual(t){return this.origin.isAlmostEqual(t.origin)&&this.direction.isAlmostEqual(t.direction)}dotProductToPoint(t){return this.direction.dotProductStartEnd(this.origin,t)}pointToFraction(t){return Q.safeDivideFraction(this.dotProductToPoint(t),this.direction.magnitudeSquared(),0)}projectPointToRay(t){return this.origin.plusScaled(this.direction,this.pointToFraction(t))}isAlmostEqualPointSet(t){if(!this.direction.isParallelTo(t.direction,!0))return!1;let e=this.projectPointToRay(t.origin);return!!t.origin.isAlmostEqualMetric(e)&&(e=t.projectPointToRay(this.origin),!!this.origin.isAlmostEqualMetric(e))}static create(t,e,i){return i?(i.set(t,e),i):new bt(t.clone(),e.clone())}static createWeightedDerivative(t,e,i){const s=t[3],n=e[3],r=t[0],o=t[1],a=t[2],c=e[0]*s-t[0]*n,l=e[1]*s-t[1]*n,h=e[2]*s-t[2]*n;if(Q.isSmallMetricDistance(s))return;const d=1/s,u=d*d;return bt.createXYZUVW(r*d,o*d,a*d,c*u,l*u,h*u,i)}static createXYZUVW(t,e,i,s,n,r,o){return o?(o.getOriginRef().set(t,e,i),o.getDirectionRef().set(s,n,r),o):new bt(j.create(t,e,i),$.create(s,n,r))}static createCapture(t,e){return new bt(t,e)}static createPointVectorNumber(t,e,i,s){return s?(s.origin.setFrom(t),s.direction.setFrom(e),s.a=i,s):((s=new bt(t.clone(),e.clone())).a=i,s)}static createStartEnd(t,e,i){return i?(i.origin.setFrom(t),i.direction.setStartEnd(t,e),i):new bt(t.clone(),$.createStartEnd(t,e))}getOriginRef(){return this.origin}getDirectionRef(){return this.direction}set(t,e){this.origin.setFrom(t),this.direction.setFrom(e)}clone(t){return t?(t.set(this.origin.clone(),this.direction.clone()),t):new bt(this.origin.clone(),this.direction.clone())}cloneTransformed(t,e){return bt.create(t.multiplyPoint3d(this.origin,e?.origin),t.multiplyVector(this.direction,e?.direction),e)}cloneInverseTransformed(t,e){if(t.computeCachedInverse(!0))return bt.create(t.multiplyInversePoint3d(this.origin,e?.origin),t.matrix.multiplyInverseXYZAsVector3d(this.direction.x,this.direction.y,this.direction.z,e?.direction),e)}transformInPlace(t){t.multiplyPoint3d(this.origin,this.origin),t.multiplyVector(this.direction,this.direction)}setFrom(t){this.set(t.origin,t.direction)}fractionToPoint(t,e){return this.origin.plusScaled(this.direction,t,e)}toRigidZFrame(t){const e=bt._workMatrix=xt.createRigidHeadsUp(this.direction,g.ZXY,bt._workMatrix);return pt.createOriginAndMatrix(this.origin,e,t)}setFromJSON(t){if(!t)return this.origin.set(0,0,0),void this.direction.set(0,0,1);this.origin.setFromJSON(t.origin),this.direction.setFromJSON(t.direction)}toJSON(){return{origin:this.origin.toJSON(),direction:this.direction.toJSON()}}static fromJSON(t){const e=bt.createXAxis();return e.setFromJSON(t),e}trySetDirectionMagnitudeInPlace(t=1){return this.direction.tryNormalizeInPlace()?(this.direction.scaleInPlace(t),!0):(this.direction.setZero(),this.a=0,!1)}tryNormalizeInPlaceWithAreaWeight(t){const e=Q.smallMetricDistanceSquared;return this.a=t,!!(Math.abs(t)>e&&this.direction.tryNormalizeInPlace(e))||(this.direction.setZero(),this.a=0,!1)}distance(t){const e=this.direction.magnitudeSquared(),i=this.dotProductToPoint(t),s=Q.inverseMetricDistanceSquared(e);return s?Math.sqrt(this.origin.distanceSquared(t)-i*i*s):Math.sqrt(this.origin.distanceSquared(t))}intersectionWithPlane(t,e){const i=$.createStartEnd(t.getOriginRef(),this.origin),s=this.direction.dotProduct(t.getNormalRef()),n=this.direction.magnitudeSquared(),r=i.dotProduct(t.getNormalRef()),o=Q.conditionalDivideFraction(-r,s);if(void 0!==o)return void 0!==Q.conditionalDivideFraction(n,s)?(e&&this.origin.plusScaled(this.direction,o,e),o):void 0}intersectionWithRange3d(t,e){if(t.isNull)return ft.createNull(e);const i=ft.createXX(-Q.largeCoordinateResult,Q.largeCoordinateResult,e);return i.clipLinearMapToInterval(this.origin.x,this.direction.x,t.low.x,t.high.x)&&i.clipLinearMapToInterval(this.origin.y,this.direction.y,t.low.y,t.high.y)&&i.clipLinearMapToInterval(this.origin.z,this.direction.z,t.low.z,t.high.z),i}intersectionWithTriangle(t,e,i,s,n,r){(void 0===s||s<0)&&(s=Q.smallMetricDistance),(void 0===n||n<0)&&(n=Q.smallFloatingPoint);const o=bt._workVector0=$.createStartEnd(t,e,bt._workVector0),a=bt._workVector1=$.createStartEnd(t,i,bt._workVector1),c=bt._workVector2=this.direction.crossProduct(a,bt._workVector2),l=o.dotProduct(c);if(l>=-s&&l<=s)return;const h=1/l,d=bt._workVector3=$.createStartEnd(t,this.origin,bt._workVector3);let u=h*d.dotProduct(c);if(u<0){if(!(u>-n))return;u=0}else if(u>1){if(!(u<1+n))return;u=1}const f=bt._workVector4=d.crossProduct(o,bt._workVector4);let g=h*this.direction.dotProduct(f);if(g<0){if(!(g>-n))return;g=0}else if(u+g>1){if(!(u+g<1+n))return;g=1-u}const p=h*a.dotProduct(f);return p<=s?void 0:this.origin.plusScaled(this.direction,p,r)}perpendicularPartOfVectorToTarget(t,e){const i=$.createStartEnd(this.origin,t),s=this.direction.magnitudeSquared(),n=this.direction.dotProductStartEnd(this.origin,t),r=Q.safeDivideFraction(n,s,0);return i.plusScaled(this.direction,-r,e)}static closestApproachRay3dRay3d(t,e){const i=J.create();let s,n,r,o,a;Mt.ray3dXYZUVWClosestApproachUnbounded(t.origin.x,t.origin.y,t.origin.z,t.direction.x,t.direction.y,t.direction.z,e.origin.x,e.origin.y,e.origin.z,e.direction.x,e.direction.y,e.direction.z,i)?(s=i.x,n=i.y,r=t.fractionToPoint(s),o=e.fractionToPoint(n),a=r.isAlmostEqualMetric(o)?I.Intersection:I.PerpendicularChord):(n=0,s=t.pointToFraction(e.origin),r=t.fractionToPoint(s),o=e.fractionToPoint(n),a=r.isAlmostEqualMetric(o)?I.CoincidentGeometry:I.ParallelGeometry);const c=Pt.createCapture(vt.createRayFractionPoint(t,s,t.fractionToPoint(s)),vt.createRayFractionPoint(e,n,e.fractionToPoint(n)));return c.approachType=a,c}static interpolatePointAndTangent(t,e,i,s,n){n=n??bt.createZero();const r=i.x-t.x,o=i.y-t.y,a=i.z-t.z;if(n.direction.set(s*r,s*o,s*a),e<=.5)n.origin.set(t.x+e*r,t.y+e*o,t.z+e*a);else{const t=e-1;n.origin.set(i.x+t*r,i.y+t*o,i.z+t*a)}return n}}class Et extends tt{constructor(t,e,i){super(),this.origin=t,this.vectorU=e,this.vectorV=i}static createOriginAndVectors(t,e,i,s){return s?(s.origin.setFrom(t),s.vectorU.setFrom(e),s.vectorV.setFrom(i),s):new Et(t.clone(),e.clone(),i.clone())}clone(t){return void 0!==t&&t.setOriginAndVectors(this.origin,this.vectorU,this.vectorV),new Et(this.origin.clone(),this.vectorU.clone(),this.vectorV.clone())}static createFrom(t,e){if(t instanceof Et)return t.clone(e);const i=t.getUnitNormal();if(void 0===i)return;const s=t.getAnyPointOnPlane(),n=xt.createPerpendicularVectorFavorXYPlane(i);if(n.tryNormalizeInPlace()){const t=i.unitCrossProduct(n);if(void 0!==t)return new Et(s,n,t)}}static createFromTransformColumnsXYAndLengths(t,e,i,s){return s?(s.origin.setFrom(t.getOrigin()),t.matrix.columnX(s.vectorU),t.matrix.columnY(s.vectorV)):s=new Et(t.getOrigin(),t.matrix.columnX(),t.matrix.columnY()),void 0!==e&&s.vectorU.scaleToLength(e,s.vectorU),void 0!==i&&s.vectorV.scaleToLength(i,s.vectorV),s}static createCapture(t,e,i,s){return s?(s.origin=t,s.vectorU=e,s.vectorV=i,s):new Et(t,e,i)}setOriginAndVectorsXYZ(t,e,i,s,n,r,o,a,c){return this.origin.set(t,e,i),this.vectorU.set(s,n,r),this.vectorV.set(o,a,c),this}setOriginAndVectors(t,e,i){return this.origin.setFrom(t),this.vectorU.setFrom(e),this.vectorV.setFrom(i),this}static createOriginAndVectorsXYZ(t,e,i,s,n,r,o,a,c,l){return l?l.setOriginAndVectorsXYZ(t,e,i,s,n,r,o,a,c):new Et(j.create(t,e,i),$.create(s,n,r),$.create(o,a,c))}static createOriginAndTargets(t,e,i,s){return Et.createOriginAndVectorsXYZ(t.x,t.y,t.z,e.x-t.x,e.y-t.y,e.z-t.z,i.x-t.x,i.y-t.y,i.z-t.z,s)}static createXYPlane(t){return Et.createOriginAndVectorsXYZ(0,0,0,1,0,0,0,1,0,t)}static createOriginAndVectorsArrays(t,e,i,s){return Et.createOriginAndVectorsXYZ(t[0],t[1],t[2],e[0],e[1],e[2],i[0],i[1],i[2],s)}static createOriginAndVectorsWeightedArrays(t,e,i,s){const n=t[3];if(s=Et.createXYPlane(s),Q.isSmallMetricDistance(n))return s;const r=1/n,o=e[3]*r*r,a=i[3]*r*r;return s.origin.set(t[0]*r,t[1]*r,t[2]*r),$.createAdd2ScaledXYZ(e[0],e[1],e[2],r,t[0],t[1],t[2],-o,s.vectorU),$.createAdd2ScaledXYZ(i[0],i[1],i[2],r,t[0],t[1],t[2],-a,s.vectorV),s}fractionToPoint(t,e,i){return this.origin.plus2Scaled(this.vectorU,t,this.vectorV,e,i)}fractionToVector(t,e,i){return $.createAdd2Scaled(this.vectorU,t,this.vectorV,e,i)}setFromJSON(t){t&&t.origin&&t.vectorV?(this.origin.setFromJSON(t.origin),this.vectorU.setFromJSON(t.vectorU),this.vectorV.setFromJSON(t.vectorV)):(this.origin.set(0,0,0),this.vectorU.set(1,0,0),this.vectorV.set(0,1,0))}toJSON(){return{origin:this.origin.toJSON(),vectorU:this.vectorU.toJSON(),vectorV:this.vectorV.toJSON()}}static fromJSON(t){const e=Et.createXYPlane();return e.setFromJSON(t),e}isAlmostEqual(t){return this.origin.isAlmostEqual(t.origin)&&this.vectorU.isAlmostEqual(t.vectorU)&&this.vectorV.isAlmostEqual(t.vectorV)}normalizeInPlace(){const t=this.vectorU.normalizeInPlace(),e=this.vectorV.normalizeInPlace();return t&&e}getUnitNormal(t){return this.vectorU.unitCrossProduct(this.vectorV,t)}unitNormal(t){return this.vectorU.unitCrossProduct(this.vectorV,t)}getAnyPointOnPlane(t){return this.origin.clone(t)}unitNormalRay(t){Et._workVector||(Et._workVector=$.create());const e=this.vectorU.unitCrossProduct(this.vectorV,Et._workVector);if(void 0!==e)return bt.create(this.origin,e,t)}toRigidFrame(t){return pt.createRigidFromOriginAndColumns(this.origin,this.vectorU,this.vectorV,g.XYZ,t)}transformInPlace(t){t.multiplyPoint3d(this.origin,this.origin),t.multiplyVector(this.vectorU,this.vectorU),t.multiplyVector(this.vectorV,this.vectorV)}normalX(){const t=this.vectorU.unitCrossProduct(this.vectorV);return void 0!==t?t.x:0}normalY(){const t=this.vectorU.unitCrossProduct(this.vectorV);return void 0!==t?t.y:0}normalZ(){const t=this.vectorU.unitCrossProduct(this.vectorV);return void 0!==t?t.z:0}altitude(t){const e=this.vectorU.unitCrossProduct(this.vectorV);return void 0===e?0:Q.dotProductXYZXYZ(t.x-this.origin.x,t.y-this.origin.y,t.z-this.origin.z,e.x,e.y,e.z)}altitudeXYZ(t,e,i){const s=this.vectorU.unitCrossProduct(this.vectorV);return void 0===s?0:Q.dotProductXYZXYZ(t-this.origin.x,e-this.origin.y,i-this.origin.z,s.x,s.y,s.z)}velocity(t){const e=this.vectorU.unitCrossProduct(this.vectorV);return void 0===e?0:Q.dotProductXYZXYZ(t.x,t.y,t.z,e.x,e.y,e.z)}velocityXYZ(t,e,i){const s=this.vectorU.unitCrossProduct(this.vectorV);return void 0===s?0:Q.dotProductXYZXYZ(t,e,i,s.x,s.y,s.z)}weightedAltitude(t){const e=t.w;return Q.tripleProduct(t.x-this.origin.x*e,t.y-this.origin.y*e,t.z-this.origin.z*e,this.vectorU.x,this.vectorU.y,this.vectorU.z,this.vectorV.x,this.vectorV.y,this.vectorV.z)}projectPointToPlane(t,e){const i=this.vectorU.unitCrossProduct(this.vectorV);if(void 0!==i){const s=i.dotProductStartEnd(this.origin,t);return t.plusScaled(i,-s,e)}const s=this.vectorU.magnitudeSquared(),n=this.vectorV.magnitudeSquared();if(s>=n){const i=this.vectorU.dotProductStartEnd(this.origin,t),n=Q.conditionalDivideCoordinate(i,s,0);if(void 0!==n)return t.plusScaled(this.vectorU,n,e)}else{const i=this.vectorV.dotProductStartEnd(this.origin,t),s=Q.conditionalDivideCoordinate(i,n,0);if(void 0!==s)return t.plusScaled(this.vectorV,s,e)}return this.origin.clone(e)}}function Rt(t,e,i,s,n,r){return r*(t-2*n*e-s*i)}class Dt extends tt{set(t=0,e=0,i=0,s=0){return this.xyzw[0]=t,this.xyzw[1]=e,this.xyzw[2]=i,this.xyzw[3]=s,this}setComponent(t,e){t>=0&&t<4&&(this.xyzw[t]=e)}get x(){return this.xyzw[0]}set x(t){this.xyzw[0]=t}get y(){return this.xyzw[1]}set y(t){this.xyzw[1]=t}get z(){return this.xyzw[2]}set z(t){this.xyzw[2]=t}get w(){return this.xyzw[3]}set w(t){this.xyzw[3]=t}constructor(t=0,e=0,i=0,s=0){super(),this.xyzw=new Float64Array(4),this.xyzw[0]=t,this.xyzw[1]=e,this.xyzw[2]=i,this.xyzw[3]=s}static create(t=0,e=0,i=0,s=0,n){return n?n.set(t,e,i,s):new Dt(t,e,i,s)}static createPlaneFrom(t){return new Dt(t.normalX(),t.normalY(),t.normalZ(),t.altitudeXYZ(0,0,0))}setFrom(t){return this.xyzw[0]=t.xyzw[0],this.xyzw[1]=t.xyzw[1],this.xyzw[2]=t.xyzw[2],this.xyzw[3]=t.xyzw[3],this}clone(t){return t?t.setFrom(this):new Dt(this.xyzw[0],this.xyzw[1],this.xyzw[2],this.xyzw[3])}setFromJSON(t){Q.isNumberArray(t,4)?this.set(t[0],t[1],t[2],t[3]):this.set(0,0,0,0)}static fromJSON(t){const e=new Dt;return e.setFromJSON(t),e}isAlmostEqual(t){return Q.isSameCoordinate(this.x,t.x)&&Q.isSameCoordinate(this.y,t.y)&&Q.isSameCoordinate(this.z,t.z)&&Q.isSameCoordinate(this.w,t.w)}isAlmostEqualXYZW(t,e,i,s){return Q.isSameCoordinate(this.x,t)&&Q.isSameCoordinate(this.y,e)&&Q.isSameCoordinate(this.z,i)&&Q.isSameCoordinate(this.w,s)}toJSON(){return[this.xyzw[0],this.xyzw[1],this.xyzw[2],this.xyzw[3]]}distanceXYZW(t){return Q.hypotenuseXYZW(t.xyzw[0]-this.xyzw[0],t.xyzw[1]-this.xyzw[1],t.xyzw[2]-this.xyzw[2],t.xyzw[3]-this.xyzw[3])}distanceSquaredXYZW(t){return Q.hypotenuseSquaredXYZW(t.xyzw[0]-this.xyzw[0],t.xyzw[1]-this.xyzw[1],t.xyzw[2]-this.xyzw[2],t.xyzw[3]-this.xyzw[3])}realDistanceXY(t){const e=this.w,i=t.w;if(!Q.isSmallMetricDistance(e)&&!Q.isSmallMetricDistance(i))return Q.hypotenuseXY(t.xyzw[0]/i-this.xyzw[0]/e,t.xyzw[1]/i-this.xyzw[1]/e)}maxDiff(t){return Math.max(Math.abs(t.xyzw[0]-this.xyzw[0]),Math.abs(t.xyzw[1]-this.xyzw[1]),Math.abs(t.xyzw[2]-this.xyzw[2]),Math.abs(t.xyzw[3]-this.xyzw[3]))}maxAbs(){return Math.max(Math.abs(this.xyzw[0]),Math.abs(this.xyzw[1]),Math.abs(this.xyzw[2]),Math.abs(this.xyzw[3]))}magnitudeXYZW(){return Q.hypotenuseXYZW(this.xyzw[0],this.xyzw[1],this.xyzw[2],this.xyzw[3])}magnitudeSquaredXYZ(){return Q.hypotenuseSquaredXYZ(this.xyzw[0],this.xyzw[1],this.xyzw[2])}minus(t,e){return Dt.create(this.xyzw[0]-t.xyzw[0],this.xyzw[1]-t.xyzw[1],this.xyzw[2]-t.xyzw[2],this.xyzw[3]-t.xyzw[3],e)}crossWeightedMinus(t,e){const i=this.xyzw[3],s=t.xyzw[3];return $.create(s*this.xyzw[0]-i*t.xyzw[0],s*this.xyzw[1]-i*t.xyzw[1],s*this.xyzw[2]-i*t.xyzw[2],e)}crossWeightedMinusPoint3d(t,e){const i=this.xyzw[3];return $.create(this.xyzw[0]-i*t.x,this.xyzw[1]-i*t.y,this.xyzw[2]-i*t.z,e)}plus(t,e){return Dt.create(this.xyzw[0]+t.xyzw[0],this.xyzw[1]+t.xyzw[1],this.xyzw[2]+t.xyzw[2],this.xyzw[3]+t.xyzw[3],e)}get isAlmostZero(){return Q.isSmallMetricDistance(this.maxAbs())}static createZero(){return new Dt(0,0,0,0)}static createPlanePointPointZ(t,e,i){return Dt.create(t.y*e.w-t.w*e.y,t.w*e.x-t.x*e.w,0,t.x*e.y-t.y*e.x,i)}static createFromPackedXYZ(t,e=0,i){if(e>=0&&e+2<t.length)return Dt.create(t[e],t[e+1],t[e+2],1,i)}static createFromPacked(t,e=0,i){if(e>=0&&e+3<t.length)return Dt.create(t[e],t[e+1],t[e+2],t[e+3],i)}static createFromPackedXYZW(t,e=0,i){return Dt.create(t[e],t[e+1],t[e+2],t[e+3],i)}static createFromPointAndWeight(t,e){return new Dt(t.x,t.y,t.z,e)}static createFromPoint(t){if(t instanceof H)return new Dt(t.x,t.y,0,1);if(t instanceof j)return new Dt(t.x,t.y,t.z,1);if(t instanceof Dt)return t.clone();if(Array.isArray(t)){const e=t.length>0?t[0]:0,i=t.length>1?t[1]:0,s=t.length>2?t[2]:0,n=t.length>3?t[3]:1;return new Dt(e,i,s,n)}const e=t.x,i=t.y,s=t.hasOwnProperty("z")?t.z:0,n=t.hasOwnProperty("w")?t.w:1;return new Dt(e,i,s,n)}plusScaled(t,e,i){return Dt.create(this.xyzw[0]+t.xyzw[0]*e,this.xyzw[1]+t.xyzw[1]*e,this.xyzw[2]+t.xyzw[2]*e,this.xyzw[3]+t.xyzw[3]*e,i)}interpolate(t,e,i){const s=1-t;return Dt.create(this.xyzw[0]*s+e.xyzw[0]*t,this.xyzw[1]*s+e.xyzw[1]*t,this.xyzw[2]*s+e.xyzw[2]*t,this.xyzw[3]*s+e.xyzw[3]*t,i)}plus2Scaled(t,e,i,s,n){return Dt.create(this.xyzw[0]+t.xyzw[0]*e+i.xyzw[0]*s,this.xyzw[1]+t.xyzw[1]*e+i.xyzw[1]*s,this.xyzw[2]+t.xyzw[2]*e+i.xyzw[2]*s,this.xyzw[3]+t.xyzw[3]*e+i.xyzw[3]*s,n)}plus3Scaled(t,e,i,s,n,r,o){return Dt.create(this.xyzw[0]+t.xyzw[0]*e+i.xyzw[0]*s+n.xyzw[0]*r,this.xyzw[1]+t.xyzw[1]*e+i.xyzw[1]*s+n.xyzw[1]*r,this.xyzw[2]+t.xyzw[2]*e+i.xyzw[2]*s+n.xyzw[2]*r,this.xyzw[3]+t.xyzw[3]*e+i.xyzw[3]*s+n.xyzw[3]*r,o)}static createAdd2Scaled(t,e,i,s,n){return Dt.create(t.xyzw[0]*e+i.xyzw[0]*s,t.xyzw[1]*e+i.xyzw[1]*s,t.xyzw[2]*e+i.xyzw[2]*s,t.xyzw[3]*e+i.xyzw[3]*s,n)}static createAdd3Scaled(t,e,i,s,n,r,o){return Dt.create(t.xyzw[0]*e+i.xyzw[0]*s+n.xyzw[0]*r,t.xyzw[1]*e+i.xyzw[1]*s+n.xyzw[1]*r,t.xyzw[2]*e+i.xyzw[2]*s+n.xyzw[2]*r,t.xyzw[3]*e+i.xyzw[3]*s+n.xyzw[3]*r,o)}dotVectorsToTargets(t,e){return(t.xyzw[0]-this.xyzw[0])*(e.xyzw[0]-this.xyzw[0])+(t.xyzw[1]-this.xyzw[1])*(e.xyzw[1]-this.xyzw[1])+(t.xyzw[2]-this.xyzw[2])*(e.xyzw[2]-this.xyzw[2])+(t.xyzw[3]-this.xyzw[3])*(e.xyzw[3]-this.xyzw[3])}dotProduct(t){return this.xyzw[0]*t.xyzw[0]+this.xyzw[1]*t.xyzw[1]+this.xyzw[2]*t.xyzw[2]+this.xyzw[3]*t.xyzw[3]}dotProductXYZW(t,e,i,s){return this.xyzw[0]*t+this.xyzw[1]*e+this.xyzw[2]*i+this.xyzw[3]*s}altitude(t){return this.xyzw[0]*t.x+this.xyzw[1]*t.y+this.xyzw[2]*t.z+this.xyzw[3]}altitudeXYZ(t,e,i){return this.xyzw[0]*t+this.xyzw[1]*e+this.xyzw[2]*i+this.xyzw[3]}weightedAltitude(t){return this.xyzw[0]*t.x+this.xyzw[1]*t.y+this.xyzw[2]*t.z+this.xyzw[3]*t.w}velocity(t){return this.xyzw[0]*t.x+this.xyzw[1]*t.y+this.xyzw[2]*t.z}velocityXYZ(t,e,i){return this.xyzw[0]*t+this.xyzw[1]*e+this.xyzw[2]*i}normalX(){return this.x}normalY(){return this.y}normalZ(){return this.z}static unitX(){return new Dt(1,0,0,0)}static unitY(){return new Dt(0,1,0,0)}static unitZ(){return new Dt(0,0,1,0)}static unitW(){return new Dt(0,0,0,1)}safeDivideOrNull(t,e){if(0!==t)return this.scale(1/t,e)}projectPointToPlane(t,e){const i=this.altitude(t),s=this.magnitudeSquaredXYZ(),n=Q.conditionalDivideCoordinate(-i,s,Q.largeFractionResult*Q.largeFractionResult);return void 0===n?t.clone(e):t.plusXYZ(n*this.x,n*this.y,n*this.z,e)}scale(t,e){return(e=e||new Dt).xyzw[0]=this.xyzw[0]*t,e.xyzw[1]=this.xyzw[1]*t,e.xyzw[2]=this.xyzw[2]*t,e.xyzw[3]=this.xyzw[3]*t,e}negate(t){return(t=t||new Dt).xyzw[0]=-this.xyzw[0],t.xyzw[1]=-this.xyzw[1],t.xyzw[2]=-this.xyzw[2],t.xyzw[3]=-this.xyzw[3],t}normalizeWeight(t){const e=Q.correctSmallFraction(this.xyzw[3]);return t=t||new Dt,this.safeDivideOrNull(e,t)}realPoint(t){const e=Q.correctSmallFraction(this.xyzw[3]);if(0===e)return;const i=1/e;return j.create(this.xyzw[0]*i,this.xyzw[1]*i,this.xyzw[2]*i,t)}realPointOrVector(){const t=Q.correctSmallFraction(this.xyzw[3]);if(0===t)return $.create(this.x,this.y,this.z);const e=1/t;return j.create(this.x*e,this.y*e,this.z*e)}static createRealPoint3dDefault000(t,e,i,s,n){const r=Q.correctSmallFraction(s),o=0===r?0:1/r;return j.create(t*o,e*o,i*o,n)}static createRealDerivativeRay3dDefault000(t,e,i,s,n,r,o,a,c){const l=Q.correctSmallFraction(s),h=0===l?0:1/l,d=h*h;return bt.createXYZUVW(t*h,e*h,i*h,(n*s-a*t)*d,(r*s-a*e)*d,(o*s-a*i)*d,c)}static createRealDerivativePlane3dByOriginAndVectorsDefault000(t,e,i,s,n,r,o,a,c,l,h,d,u){const f=Q.correctSmallFraction(s),g=0===f?0:1/f,p=g*g,m=t*g,x=e*g,_=i*g,y=(n*s-a*t)*p,v=(r*s-a*e)*p,P=(o*s-a*i)*p;return Et.createOriginAndVectorsXYZ(m,x,_,y,v,P,Rt(c,a,d,m,y,g),Rt(l,a,d,x,v,g),Rt(h,a,d,_,P,g),u)}realPointDefault000(t){const e=Q.correctSmallFraction(this.xyzw[3]);if(0===e)return j.create(0,0,0,t);t=t||new j;const i=1/e;return j.create(this.xyzw[0]*i,this.xyzw[1]*i,this.xyzw[2]*i,t)}normalizeXYZW(t){const e=Q.correctSmallFraction(this.magnitudeXYZW());return t=t||new Dt,this.safeDivideOrNull(e,t)}static determinantIndexed3X3(t,e,i,s,n,r){return Q.tripleProduct(t.xyzw[s],t.xyzw[n],t.xyzw[r],e.xyzw[s],e.xyzw[n],e.xyzw[r],i.xyzw[s],i.xyzw[n],i.xyzw[r])}static perpendicularPoint4dPlane(t,e,i){return Dt.create(Dt.determinantIndexed3X3(t,e,i,1,2,3),-Dt.determinantIndexed3X3(t,e,i,2,3,0),Dt.determinantIndexed3X3(t,e,i,3,0,1),-Dt.determinantIndexed3X3(t,e,i,0,1,2))}toPlane3dByOriginAndUnitNormal(t){return _t.createFrom(this,t)}normalizeQuaternion(){const t=Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);if(t>0){const e=1/t;this.x*=e,this.y*=e,this.z*=e,this.w*=e}return t}static interpolateQuaternions(t,e,i,s){if(s||(s=new Dt),0===e)return t;if(1===e)return i;if(.5===e)return t.plus(i,s),s.normalizeQuaternion(),s;const n=t.clone(),r=i.clone();let o=t.dotProduct(i);if(o<0&&(r.negate(r),o=-o),o>.9995)return n.interpolate(e,r,s),s.normalizeQuaternion(),s;o<-1?o=-1:o>1&&(o=1);const a=new Dt;r.plusScaled(n,-o,a),a.normalizeQuaternion();const c=Math.acos(o)*e;return Dt.createAdd2Scaled(n,Math.cos(c),a,Math.sin(c))}radiansToPoint4dXYZW(t){const e=this.magnitudeXYZW(),i=t.magnitudeXYZW(),s=this.dotProduct(t),n=Q.conditionalDivideFraction(s,e*i);if(void 0!==n)return Math.acos(n)}}class Xt{constructor(){this._coffs=new Float64Array(16)}setFrom(t){for(let e=0;e<16;e++)this._coffs[e]=t._coffs[e]}clone(t){if(t===this)return this;void 0===t&&(t=new Xt);for(let e=0;e<16;e++)t._coffs[e]=this._coffs[e];return t}setZero(){for(let t=0;t<16;t++)this._coffs[t]=0}setIdentity(){for(let t=0;t<16;t++)this._coffs[t]=0;this._coffs[0]=this._coffs[5]=this._coffs[10]=this._coffs[15]=1}static is1000(t,e,i,s,n){return Math.abs(t-1)<=n&&Math.abs(e)<=n&&Math.abs(i)<=n&&Math.abs(s)<=n}isIdentity(t=1e-10){return Xt.is1000(this._coffs[0],this._coffs[1],this._coffs[2],this._coffs[3],t)&&Xt.is1000(this._coffs[5],this._coffs[6],this._coffs[7],this._coffs[4],t)&&Xt.is1000(this._coffs[10],this._coffs[11],this._coffs[8],this._coffs[9],t)&&Xt.is1000(this._coffs[15],this._coffs[12],this._coffs[13],this._coffs[14],t)}static createZero(t){return t?(t.setZero(),t):new Xt}static createRowValues(t,e,i,s,n,r,o,a,c,l,h,d,u,f,g,p,m){return(m=m||new Xt)._coffs[0]=t,m._coffs[1]=e,m._coffs[2]=i,m._coffs[3]=s,m._coffs[4]=n,m._coffs[5]=r,m._coffs[6]=o,m._coffs[7]=a,m._coffs[8]=c,m._coffs[9]=l,m._coffs[10]=h,m._coffs[11]=d,m._coffs[12]=u,m._coffs[13]=f,m._coffs[14]=g,m._coffs[15]=p,m}static createRows(t,e,i,s,n){return this.createRowValues(t.x,t.y,t.z,t.w,e.x,e.y,e.z,e.w,i.x,i.y,i.z,i.w,s.x,s.y,s.z,s.w,n)}setOriginAndVectors(t,e,i,s){this._coffs[0]=e.x,this._coffs[1]=i.x,this._coffs[2]=s.x,this._coffs[3]=t.x,this._coffs[4]=e.y,this._coffs[5]=i.y,this._coffs[6]=s.y,this._coffs[7]=t.y,this._coffs[8]=e.z,this._coffs[9]=i.z,this._coffs[10]=s.z,this._coffs[11]=t.z,this._coffs[12]=0,this._coffs[13]=0,this._coffs[14]=0,this._coffs[15]=1}static createTransform(t,e){const i=t.matrix,s=t.origin;return Xt.createRowValues(i.coffs[0],i.coffs[1],i.coffs[2],s.x,i.coffs[3],i.coffs[4],i.coffs[5],s.y,i.coffs[6],i.coffs[7],i.coffs[8],s.z,0,0,0,1,e)}static createIdentity(t){return(t=Xt.createZero(t))._coffs[0]=1,t._coffs[5]=1,t._coffs[10]=1,t._coffs[15]=1,t}static createTranslationXYZ(t,e,i,s){return(s=Xt.createZero(s))._coffs[0]=1,s._coffs[5]=1,s._coffs[10]=1,s._coffs[15]=1,s._coffs[3]=t,s._coffs[7]=e,s._coffs[11]=i,s}plusScaled(t,e,i){i=this.clone(i);for(let s=0;s<16;s++)i._coffs[s]+=e*t._coffs[s];return i}static createTranslationAndScaleXYZ(t,e,i,s,n,r,o){return Xt.createRowValues(s,0,0,t,0,n,0,e,0,0,r,i,0,0,0,1,o)}static createBoxToBox(t,e,i,s,n){const r=e.x-t.x,o=e.y-t.y,a=e.z-t.z,c=s.x-i.x,l=s.y-i.y,h=s.z-i.z,d=Q.conditionalDivideFraction(c,r),u=Q.conditionalDivideFraction(l,o),f=Q.conditionalDivideFraction(h,a);if(void 0!==d&&void 0!==u&&void 0!==f)return Xt.createTranslationAndScaleXYZ(i.x-d*t.x,i.y-u*t.y,i.z-f*t.z,d,u,f,n)}setFromJSON(t){if(Q.isArrayOfNumberArray(t,4,4))for(let e=0;e<4;++e)for(let i=0;i<4;++i)this._coffs[4*e+i]=t[e][i];else this.setZero()}maxDiff(t){let e=0;for(let i=0;i<16;i++)e=Math.max(e,Math.abs(this._coffs[i]-t._coffs[i]));return e}maxAbs(){let t=0;for(let e=0;e<16;e++)t=Math.max(t,Math.abs(this._coffs[e]));return t}isAlmostEqual(t){return Q.isSmallMetricDistance(this.maxDiff(t))}isExactEqual(t){return 0===this.maxDiff(t)}toJSON(){const t=[];for(let e=0;e<4;++e){const i=4*e;t.push([this._coffs[i],this._coffs[i+1],this._coffs[i+2],this._coffs[i+3]])}return t}static fromJSON(t){const e=new Xt;return e.setFromJSON(t),e}getSteppedPoint(t,e,i){return Dt.create(this._coffs[t],this._coffs[t+e],this._coffs[t+2*e],this._coffs[t+3*e],i)}columnX(){return this.getSteppedPoint(0,4)}columnY(){return this.getSteppedPoint(1,4)}columnZ(){return this.getSteppedPoint(2,4)}columnW(){return this.getSteppedPoint(3,4)}rowX(){return this.getSteppedPoint(0,1)}rowY(){return this.getSteppedPoint(4,1)}rowZ(){return this.getSteppedPoint(8,1)}rowW(){return this.getSteppedPoint(12,1)}get hasPerspective(){return 0!==this._coffs[12]||0!==this._coffs[13]||0!==this._coffs[14]||1!==this._coffs[15]}diagonal(){return this.getSteppedPoint(0,5)}weight(){return this._coffs[15]}matrixPart(){return xt.createRowValues(this._coffs[0],this._coffs[1],this._coffs[2],this._coffs[4],this._coffs[5],this._coffs[6],this._coffs[8],this._coffs[9],this._coffs[10])}get asTransform(){if(!this.hasPerspective)return pt.createRowValues(this._coffs[0],this._coffs[1],this._coffs[2],this._coffs[3],this._coffs[4],this._coffs[5],this._coffs[6],this._coffs[7],this._coffs[8],this._coffs[9],this._coffs[10],this._coffs[11])}multiplyMatrixMatrix(t,e){e=e&&e!==this&&e!==t?e:new Xt;for(let i=0;i<16;i+=4)for(let s=0;s<4;s++)e._coffs[i+s]=this._coffs[i]*t._coffs[s]+this._coffs[i+1]*t._coffs[s+4]+this._coffs[i+2]*t._coffs[s+8]+this._coffs[i+3]*t._coffs[s+12];return e}multiplyMatrixMatrixTranspose(t,e){e=e&&e!==this&&e!==t?e:new Xt;let i=0;for(let s=0;s<16;s+=4)for(let n=0;n<16;n+=4)e._coffs[i++]=this._coffs[s]*t._coffs[n]+this._coffs[s+1]*t._coffs[n+1]+this._coffs[s+2]*t._coffs[n+2]+this._coffs[s+3]*t._coffs[n+3];return e}multiplyMatrixTransposeMatrix(t,e){e=e&&e!==this&&e!==t?e:new Xt;let i=0;for(let s=0;s<4;s+=1)for(let n=0;n<4;n+=1)e._coffs[i++]=this._coffs[s]*t._coffs[n]+this._coffs[s+4]*t._coffs[n+4]+this._coffs[s+8]*t._coffs[n+8]+this._coffs[s+12]*t._coffs[n+12];return e}cloneTransposed(t){return Xt.createRowValues(this._coffs[0],this._coffs[4],this._coffs[8],this._coffs[12],this._coffs[1],this._coffs[5],this._coffs[9],this._coffs[13],this._coffs[2],this._coffs[6],this._coffs[10],this._coffs[14],this._coffs[3],this._coffs[7],this._coffs[11],this._coffs[15],t)}multiplyXYZW(t,e,i,s,n){return(n=n||Dt.createZero()).set(this._coffs[0]*t+this._coffs[1]*e+this._coffs[2]*i+this._coffs[3]*s,this._coffs[4]*t+this._coffs[5]*e+this._coffs[6]*i+this._coffs[7]*s,this._coffs[8]*t+this._coffs[9]*e+this._coffs[10]*i+this._coffs[11]*s,this._coffs[12]*t+this._coffs[13]*e+this._coffs[14]*i+this._coffs[15]*s)}multiplyBlockedFloat64ArrayInPlace(t){const e=t.length;let i,s,n,r;for(let o=0;o+3<e;o+=4)i=t[o],s=t[o+1],n=t[o+2],r=t[o+3],t[o]=this._coffs[0]*i+this._coffs[1]*s+this._coffs[2]*n+this._coffs[3]*r,t[o+1]=this._coffs[4]*i+this._coffs[5]*s+this._coffs[6]*n+this._coffs[7]*r,t[o+2]=this._coffs[8]*i+this._coffs[9]*s+this._coffs[10]*n+this._coffs[11]*r,t[o+3]=this._coffs[12]*i+this._coffs[13]*s+this._coffs[14]*n+this._coffs[15]*r}multiplyPoint3d(t,e,i){return this.multiplyXYZW(t.x,t.y,t.z,e,i)}multiplyPoint3dArray(t,e,i=1){t.forEach(((t,s)=>{e[s]=this.multiplyXYZW(t.x,t.y,t.z,i,e[s])}))}multiplyTransposeXYZW(t,e,i,s,n){return(n=n||Dt.createZero()).set(this._coffs[0]*t+this._coffs[4]*e+this._coffs[8]*i+this._coffs[12]*s,this._coffs[1]*t+this._coffs[5]*e+this._coffs[9]*i+this._coffs[13]*s,this._coffs[2]*t+this._coffs[6]*e+this._coffs[10]*i+this._coffs[14]*s,this._coffs[3]*t+this._coffs[7]*e+this._coffs[11]*i+this._coffs[15]*s)}rowDotColumn(t,e,i){const s=4*t,n=i;return this._coffs[s]*e._coffs[n]+this._coffs[s+1]*e._coffs[n+4]+this._coffs[s+2]*e._coffs[n+8]+this._coffs[s+3]*e._coffs[n+12]}rowDotXYZW(t,e,i,s,n){const r=4*t;return this._coffs[r]*e+this._coffs[r+1]*i+this._coffs[r+2]*s+this._coffs[r+3]*n}rowDotRow(t,e,i){const s=4*t,n=4*i;return this._coffs[s]*e._coffs[n]+this._coffs[s+1]*e._coffs[n+1]+this._coffs[s+2]*e._coffs[n+2]+this._coffs[s+3]*e._coffs[n+3]}columnDotColumn(t,e,i){const s=t,n=i;return this._coffs[s]*e._coffs[n]+this._coffs[s+4]*e._coffs[n+4]+this._coffs[s+8]*e._coffs[n+8]+this._coffs[s+12]*e._coffs[n+12]}columnDotRow(t,e,i){const s=t,n=4*i;return this._coffs[s]*e._coffs[n]+this._coffs[s+4]*e._coffs[n+1]+this._coffs[s+8]*e._coffs[n+2]+this._coffs[s+12]*e._coffs[n+3]}atIJ(t,e){return this._coffs[4*t+e]}setAtIJ(t,e,i){this._coffs[4*t+e]=i}multiplyXYZWQuietRenormalize(t,e,i,s,n){(n=n||j.createZero()).set(this._coffs[0]*t+this._coffs[1]*e+this._coffs[2]*i+this._coffs[3]*s,this._coffs[4]*t+this._coffs[5]*e+this._coffs[6]*i+this._coffs[7]*s,this._coffs[8]*t+this._coffs[9]*e+this._coffs[10]*i+this._coffs[11]*s);const r=this._coffs[12]*t+this._coffs[13]*e+this._coffs[14]*i+this._coffs[15]*s,o=Q.conditionalDivideCoordinate(n.x,r),a=Q.conditionalDivideCoordinate(n.y,r),c=Q.conditionalDivideCoordinate(n.z,r);return void 0!==o&&void 0!==a&&void 0!==c&&(n.x=o,n.y=a,n.z=c),n}multiplyPoint4dArrayQuietRenormalize(t,e){t.forEach(((t,i)=>{e[i]=this.multiplyXYZWQuietRenormalize(t.x,t.y,t.z,t.w,e[i])}))}multiplyPoint4d(t,e){return this.multiplyXYZW(t.xyzw[0],t.xyzw[1],t.xyzw[2],t.xyzw[3],e)}multiplyTransposePoint4d(t,e){return this.multiplyTransposeXYZW(t.xyzw[0],t.xyzw[1],t.xyzw[2],t.xyzw[3],e)}multiplyPoint3dQuietNormalize(t,e){return this.multiplyXYZWQuietRenormalize(t.x,t.y,t.z,1,e)}multiplyPoint3dArrayQuietNormalize(t){t.forEach((t=>this.multiplyXYZWQuietRenormalize(t.x,t.y,t.z,1,t)))}addMomentsInPlace(t,e,i,s){this._coffs[0]+=t*t,this._coffs[1]+=t*e,this._coffs[2]+=t*i,this._coffs[3]+=t*s,this._coffs[4]+=e*t,this._coffs[5]+=e*e,this._coffs[6]+=e*i,this._coffs[7]+=e*s,this._coffs[8]+=i*t,this._coffs[9]+=i*e,this._coffs[10]+=i*i,this._coffs[11]+=i*s,this._coffs[12]+=s*t,this._coffs[13]+=s*e,this._coffs[14]+=s*i,this._coffs[15]+=s*s}addScaledInPlace(t,e=1){for(let i=0;i<16;i++)this._coffs[i]+=e*t._coffs[i]}rowOperation(t,e,i,s){if(0===s)return;let n=4*t+i,r=4*e+i;for(let t=i;t<4;t++,n++,r++)this._coffs[r]+=s*this._coffs[n]}determinant(){const t=this._coffs;return Q.determinant4x4(t[0],t[1],t[2],t[3],t[4],t[5],t[6],t[7],t[8],t[9],t[10],t[11],t[12],t[13],t[14],t[15])}createInverse(t){let e=this.columnX().maxAbs();if(0===e)return;const i=1/e;if(e=this.columnY().maxAbs(),0===e)return;const s=1/e;if(e=this.columnZ().maxAbs(),0===e)return;const n=1/e;if(e=this.columnW().maxAbs(),0===e)return;const r=1/e,o=this.columnX(),a=this.columnY(),c=this.columnZ(),l=this.columnW();o.scale(i,o),a.scale(s,a),c.scale(n,c),l.scale(r,l);const h=Dt.perpendicularPoint4dPlane(a,c,l),d=Dt.perpendicularPoint4dPlane(o,l,c),u=Dt.perpendicularPoint4dPlane(l,o,a),f=Dt.perpendicularPoint4dPlane(c,a,o);t=Xt.createRows(h,d,u,f,t);const g=h.dotProduct(o),p=d.dotProduct(a),m=u.dotProduct(c),x=f.dotProduct(l),_=t.maxAbs();if(g*p>0&&g*m>0&&g*x>0&&void 0!==Q.conditionalDivideCoordinate(_,g)){const e=1/g;return t.scaleRowsInPlace(i*e,s*e,n*e,r*e),t}}rowArrays(t){return t?[[t(this._coffs[0]),t(this._coffs[1]),t(this._coffs[2]),t(this._coffs[3])],[t(this._coffs[4]),t(this._coffs[5]),t(this._coffs[6]),t(this._coffs[7])],[t(this._coffs[8]),t(this._coffs[9]),t(this._coffs[10]),t(this._coffs[11])],[t(this._coffs[12]),t(this._coffs[13]),t(this._coffs[14]),t(this._coffs[15])]]:[[this._coffs[0],this._coffs[1],this._coffs[2],this._coffs[3]],[this._coffs[4],this._coffs[5],this._coffs[6],this._coffs[7]],[this._coffs[8],this._coffs[9],this._coffs[10],this._coffs[11]],[this._coffs[12],this._coffs[13],this._coffs[14],this._coffs[15]]]}scaleRowsInPlace(t,e,i,s){for(let e=0;e<4;e++)this._coffs[e]*=t;for(let t=4;t<8;t++)this._coffs[t]*=e;for(let t=8;t<12;t++)this._coffs[t]*=i;for(let t=12;t<16;t++)this._coffs[t]*=s}addScaledOuterProductInPlace(t,e,i){let s=t.x*i;this._coffs[0]+=s*e.x,this._coffs[1]+=s*e.y,this._coffs[2]+=s*e.z,this._coffs[3]+=s*e.w,s=t.y*i,this._coffs[4]+=s*e.x,this._coffs[5]+=s*e.y,this._coffs[6]+=s*e.z,this._coffs[7]+=s*e.w,s=t.z*i,this._coffs[8]+=s*e.x,this._coffs[9]+=s*e.y,this._coffs[10]+=s*e.z,this._coffs[11]+=s*e.w,s=t.w*i,this._coffs[12]+=s*e.x,this._coffs[13]+=s*e.y,this._coffs[14]+=s*e.z,this._coffs[15]+=s*e.w}addTranslationSandwichInPlace(t,e,i,s,n){const r=t._coffs[3],o=t._coffs[7],a=t._coffs[11],c=t._coffs[12],l=t._coffs[13],h=t._coffs[14],d=t._coffs[15],u=e*d,f=i*d,g=s*d;this._coffs[0]+=n*(t._coffs[0]+e*r+c*e+e*u),this._coffs[1]+=n*(t._coffs[1]+i*r+l*e+e*f),this._coffs[2]+=n*(t._coffs[2]+s*r+h*e+e*g),this._coffs[3]+=n*(r+u),this._coffs[4]+=n*(t._coffs[4]+e*o+c*i+i*u),this._coffs[5]+=n*(t._coffs[5]+i*o+l*i+i*f),this._coffs[6]+=n*(t._coffs[6]+s*o+h*i+i*g),this._coffs[7]+=n*(o+f),this._coffs[8]+=n*(t._coffs[8]+e*a+c*s+s*u),this._coffs[9]+=n*(t._coffs[9]+i*a+l*s+s*f),this._coffs[10]+=n*(t._coffs[10]+s*a+h*s+s*g),this._coffs[11]+=n*(a+g),this._coffs[12]+=n*(c+u),this._coffs[13]+=n*(l+f),this._coffs[14]+=n*(h+g),this._coffs[15]+=n*d}multiplyTranslationSandwichInPlace(t,e,i){const s=this._coffs[3],n=this._coffs[7],r=this._coffs[11],o=this._coffs[12],a=this._coffs[13],c=this._coffs[14],l=this._coffs[15],h=t*l,d=e*l,u=i*l;this._coffs[0]+=t*s+o*t+t*h,this._coffs[1]+=e*s+a*t+t*d,this._coffs[2]+=i*s+c*t+t*u,this._coffs[3]+=h,this._coffs[4]+=t*n+o*e+e*h,this._coffs[5]+=e*n+a*e+e*d,this._coffs[6]+=i*n+c*e+e*u,this._coffs[7]+=d,this._coffs[8]+=t*r+o*i+i*h,this._coffs[9]+=e*r+a*i+i*d,this._coffs[10]+=i*r+c*i+i*u,this._coffs[11]+=u,this._coffs[12]+=h,this._coffs[13]+=d,this._coffs[14]+=u}}class zt{constructor(t,e){this.xTest=t,this.yTest=e,this.u0=this.v0=this.u1=this.v1=0,this.numLeftCrossing=this.numRightCrossing=0,this.numHit=0}tryStartEdge(t,e,i,s){return e!==this.yTest&&(this.u0=t-this.xTest,this.v0=e-this.yTest,this.u1=i-this.xTest,this.v1=s-this.yTest,!0)}updateUV01(t,e){return this.u0=this.u1,this.v0=this.v1,this.u1=t,this.v1=e,!0}advance(t,e){const i=t-this.xTest,s=e-this.yTest,n=s*this.v1;if(n>0)return this.updateUV01(i,s);if(n<0){const t=-this.v1/(s-this.v1),e=this.u1+t*(i-this.u1);return 0===e?(this.numHit++,!1):(e>0?this.numRightCrossing++:this.numLeftCrossing++,this.updateUV01(i,s))}return 0===s?0===this.v1?i*this.u1<=0?(this.numHit++,!1):(this.u1=i,this.v1=s,!0):0===i?(this.numHit++,!1):this.updateUV01(i,s):0===this.u1?(this.numHit++,!1):(this.v0*s<0&&(this.u1>0?this.numRightCrossing++:this.numLeftCrossing++),this.updateUV01(i,s))}classifyCounts(){return this.numHit>0?0:1&~this.numLeftCrossing?-1:1}}class Nt{constructor(t,e,i,s,n){this.numStroke=t,this.curveLength=e,this.a0=i,this.a1=s,this.componentData=n}static createWithCurvePrimitive(t,e,i,s,n,r){const o=new Nt(e,i,s,n,r);return o.primitive=t,o}static createWithComponentIndex(t=0,e=0,i=0,s=0,n=0){const r=new Nt(e,i,s,n);return r.componentIndex=t,r}static createWithCurvePrimitiveAndOptionalParent(t,e,i){const s=e?e.a1:0,n=new Nt(0,0,s,s,i);return n.primitive=t,n}addToCountAndLength(t,e){const i=this.a1+e;this.componentData&&this.componentData.push(new Nt(t,e,this.a1,i)),this.numStroke+=t,this.curveLength+=e,this.a1=i}isCompatibleComponentStructure(t,e){if(e&&this.numStroke!==t.numStroke)return!1;if(void 0===this.componentData&&void 0===t.componentData)return!0;if(this.componentData&&t.componentData){if(this.componentData.length!==t.componentData.length)return!1;const i=this.componentData.length;for(let s=0;s<i;s++)if(!this.componentData[s].isCompatibleComponentStructure(t.componentData[s],e))return!1;return!0}return!1}clone(){const t=new Nt(this.numStroke,this.curveLength,this.a0,this.a1);if(this.componentData){t.componentData=[];for(const e of this.componentData)t.componentData.push(e.clone())}return t}fractionToA(t){return Q.interpolate(this.a0,t,this.a1)}}class Ot{range(t,e){e&&e.setNull();const i=e||ut.createNull();return this.extendRange(i,t),i}tryTranslateInPlace(t,e=0,i=0){return this.tryTransformInPlace(pt.createTranslationXYZ(t,e,i))}get children(){}isAlmostEqual(t){if(this.isSameGeometryClass(t)){const e=this.children,i=t.children;if(e&&i){if(e.length!==i.length)return!1;for(let t=0;t<e.length;t++)if(!e[t].isAlmostEqual(i[t]))return!1;return!0}return!e&&!i}return!1}static areAlmostEqual(t,e){return t instanceof Ot&&e instanceof Ot?t.isAlmostEqual(e):void 0===t&&void 0===e}}class Yt{static getRow(t){const e=Yt._allRows;for(0===e.length&&(e.push(new Float64Array([1])),e.push(new Float64Array([1,1])),e.push(new Float64Array([1,2,1])),e.push(new Float64Array([1,3,3,1])),e.push(new Float64Array([1,4,6,4,1])),e.push(new Float64Array([1,5,10,10,5,1])),e.push(new Float64Array([1,6,15,20,15,6,1])),e.push(new Float64Array([1,7,21,35,35,21,7,1])));e.length<=t;){const t=e.length,i=e[t-1],s=new Float64Array(t+1);s[0]=1;for(let e=1;e<t;e++)s[e]=i[e-1]+i[e];s[t]=1,e.push(s)}return e[t]}static getBezierBasisValues(t,e,i){const s=t-1,n=Yt.getRow(s);(void 0===i||i.length<t)&&(i=new Float64Array(t));for(let e=0;e<t;e++)i[e]=n[e];let r=e;for(let s=1;s<t;s++,r*=e)i[s]*=r;const o=1-e;r=o;for(let e=t-2;e>=0;e--,r*=o)i[e]*=r;return i}static getBezierBasisDerivatives(t,e,i){(void 0===i||i.length<t)&&(i=new Float64Array(t));const s=t-1;(i=this.getBezierBasisValues(t-1,e,i))[t-1]=s*i[t-2];for(let e=t-2;e>0;e--)i[e]=s*(i[e-1]-i[e]);return i[0]=-s*i[0],i}}Yt._allRows=[];class Bt{constructor(t){if(t instanceof Float64Array)this.coffs=t.slice();else if(Array.isArray(t)){this.coffs=new Float64Array(t.length);let e=0;for(const i of t)this.coffs[e++]=i}else this.coffs=new Float64Array(t)}allocateToOrder(t){this.coffs.length!==t?this.coffs=new Float64Array(t):this.coffs.fill(0)}createPeer(){return new Lt(this.order)}get order(){return this.coffs.length}copyFrom(t){if(this.order===t.order)for(let e=0;e<this.coffs.length;e++)this.coffs[e]=t.coffs[e];else this.coffs=t.coffs.slice()}scaleInPlace(t){for(let e=0;e<this.coffs.length;e++)this.coffs[e]*=t}addInPlace(t){for(let e=0;e<this.coffs.length;e++)this.coffs[e]+=t}roots(t,e){const i=Lt.create(this);i.addInPlace(-t);const s=Lt.deflateRoots(i);return this.filter01(s,!0)}filter01(t,e=!1){if(!t||!e)return t;let i=!1;for(const e of t)if(Q.isIn01(e)){i=!0;break}if(i){const e=[];for(const i of t)Q.isIn01(i)&&e.push(i);return e}}zero(){this.coffs.fill(0)}subdivide(t,e,i){const s=this.order;if(e.order!==s||i.order!==s)return!1;const n=1-t;i.copyFrom(this);let r=s-1;for(let o=0;o<s;o++){e.coffs[o]=i.coffs[0];for(let e=0;e<r;e++)i.coffs[e]=n*i.coffs[e]+t*i.coffs[e+1];r--}return!0}static maxAbsDiff(t,e){const i=t.order;if(e.order!==i)return;let s,n=0;for(let r=0;r<i;r++)s=Math.abs(t.coffs[r]-e.coffs[r]),s>n&&(n=s);return n}}class Vt{static accumulateScaledShiftedComponentTimesComponentDelta(t,e,i,s,n,r,o,a){const c=s-1,l=s,h=s+c-1;if(t.length!==h)return;const d=Yt.getRow(l-1),u=Yt.getRow(c-1),f=Yt.getRow(h-1);let g;for(let s=0;s<l;s++){g=n*(o+e[r+s*i])*d[s];for(let n=0,r=a;n<c;n++,r+=i)t[s+n]+=g*u[n]*(e[r+i]-e[r])/f[s+n]}}static scaledComponentSum(t,e,i,s,n,r,o,a){const c=s;if(t.length===c)for(let s=0,l=0;s<c;s++,l+=i)t[s]=r*e[l+n]+a*e[l+o]}static componentDifference(t,e,i,s,n){const r=s-1;if(t.length===r)for(let s=0,o=n;s<r;o+=i,s++)t[s]=e[o+i]-e[o]}static accumulateProduct(t,e,i,s=1){const n=e.length,r=i.length,o=n+r-1;if(t.length!==o)return;let a,c,l;const h=Yt.getRow(n-1),d=Yt.getRow(r-1),u=Yt.getRow(o-1);for(a=0;a<n;a++)for(l=s*h[a]*e[a],c=0;c<r;c++)t[a+c]+=l*d[c]*i[c]/u[a+c]}static accumulateProductWithDifferences(t,e,i,s=1){const n=e.length-1,r=i.length,o=n+r-1;if(t.length!==o)return;let a,c,l;const h=Yt.getRow(n-1),d=Yt.getRow(r-1),u=Yt.getRow(o-1);for(a=0;a<n;a++)for(l=s*h[a]*(e[a+1]-e[a]),c=0;c<r;c++)t[a+c]+=l*d[c]*i[c]/u[a+c]}static univariateDifference(t,e){const i=e.length;if(e.length+1!==i)for(let s=0;s<i;s++)e[s]=t[s+1]-t[s]}static accumulate(t,e,i){if(i.length===e)for(let s=0;s<e;s++)i[s]+=t[s]}}class Lt extends Bt{get order(){return this._order}constructor(t){super(t),this._order=super.order}allocateOrder(t){this._order!==t&&(super.allocateToOrder(t),this._order=t),this.coffs.fill(0)}clone(t=!1){if(t){const t=new Lt(this.order);return t.coffs=this.coffs.slice(0,this.order),t}const e=new Lt(this.coffs.length);return e._order=this._order,e.coffs=this.coffs.slice(),e}static create(t){const e=new Lt(t.order);return e.coffs=t.coffs.slice(),e}static createCoffs(t){return new Lt(t)}static createArraySubset(t,e,i,s){s?s.order!==i&&s.allocateToOrder(i):s=new Lt(i);for(let n=0;n<i;n++)s.coffs[n]=t[e+n];return s}static createProduct(t,e){const i=new Lt(t.order+e.order-1),s=Yt.getRow(t.order-1),n=Yt.getRow(e.order-1),r=Yt.getRow(t.order+e.order-2);for(let o=0;o<t.order;o++){const a=t.coffs[o]*s[o];for(let t=0;t<e.order;t++){const s=e.coffs[t]*n[t],c=o+t,l=r[c];i.coffs[c]+=a*s/l}}return i}addSquaredSquaredBezier(t,e){const i=t.length,s=this.order;if(2*i!==s+1)return!1;const n=Yt.getRow(i-1),r=Yt.getRow(s-1),o=this.coffs;for(let s=0;s<i;s++){const a=t[s]*n[s]*e;for(let e=0;e<i;e++){const i=t[e]*n[e],c=s+e,l=r[c];o[c]+=a*i/l}}return!0}addConstant(t){for(let e=0;e<this.coffs.length;e++)this.coffs[e]+=t}basisFunctions(t,e){this._basisValues=Yt.getBezierBasisValues(this.order,t,this._basisValues),(!e||e.length<this.order)&&(e=new Float64Array(this.order));let i=0;for(const t of this._basisValues)e[i++]=t;return e}static sumWeightedBlocks(t,e,i,s,n){for(let t=0;t<s;t++)n[t]=0;let r,o=0;for(let a=0;a<e;a++){const e=t[a];for(r=0;r<s;r++)n[r]+=e*i[o++]}}sumBasisFunctions(t,e,i,s){return(!s||s.length<i)&&(s=new Float64Array(i)),this._basisValues=Yt.getBezierBasisValues(this.order,t,this._basisValues),Lt.sumWeightedBlocks(this._basisValues,this.order,e,i,s),s}sumBasisFunctionDerivatives(t,e,i,s){return(!s||s.length<i)&&(s=new Float64Array(i)),this._basisValues=Yt.getBezierBasisDerivatives(this.order,t,this._basisValues),Lt.sumWeightedBlocks(this._basisValues,this.order,e,i,s),s}evaluate(t){this._basisValues=Yt.getBezierBasisValues(this.order,t,this._basisValues);let e=0;for(let t=0;t<this.order;t++)e+=this._basisValues[t]*this.coffs[t];return e}deflateLeft(){const t=this.order,e=t-1,i=Yt.getRow(e-1),s=Yt.getRow(t-1);let n;for(let t=0;t<e;t++)n=this.coffs[t+1],this.coffs[t]=n*s[t+1]/i[t];this._order--}deflateRight(){const t=this.order,e=t-1,i=Yt.getRow(e-1),s=Yt.getRow(t-1);let n,r;for(let t=0;t<e;t++)n=this.coffs[t],r=n*s[t]/i[t],this.coffs[t]=r;this._order--}deflateRoot(t){const e=this.order,i=e-1;if(1===e)return this._order=0,this.coffs[0];if(e<1)return this._order=0,0;const s=Yt.getRow(e-1),n=Yt.getRow(i-1),r=-t,o=1-t;let a=0;if(t>.5){let t,c,l=this.coffs[0]/r;this.coffs[0]=l;for(let e=1;e<i;e++)c=this.coffs[e]*s[e],t=(c-l*o)/r,this.coffs[e]=t/n[e],l=t;a=this.coffs[e-1]-l*o}else{let t,c,l=this.coffs[e-1]/o;this.coffs[e-1]=l;for(let i=e-2;i>0;i--)c=this.coffs[i]*s[i],t=(c-l*r)/o,this.coffs[i]=t/n[i-1],l=t;a=this.coffs[0]-l*r;for(let t=0;t<i;t++)this.coffs[t]=this.coffs[t+1]}return this._order=i,a}runNewton(t,e=1e-11){const i=this.order-1;let s,n,r=0,o=t;const a=this.order,c=this.coffs,l=a-1;for(let t=0;t++<10;){Lt._basisBuffer=Yt.getBezierBasisValues(a,o,Lt._basisBuffer),s=0;for(let t=0;t<a;t++)s+=c[t]*Lt._basisBuffer[t];Lt._basisBuffer1=Yt.getBezierBasisValues(l,o,Lt._basisBuffer1),n=0;for(let t=0;t<l;t++)n+=(c[t+1]-c[t])*Lt._basisBuffer1[t];if(n*=i,Math.abs(s)>10*Math.abs(n))return;const t=s/n;if(Math.abs(t)<e){if(r++,r>=2)return o-t}else r=0;o-=t}}static deflateRoots(t){const e=[],i=t.coffs;let s,n,r,o,a;for(;t.order>1;){const c=t.order;if(0===i[0]){t.deflateLeft(),e.push(0);continue}let l=0,h=0;for(let d=1;d<c;d++)if(s=i[d-1],n=i[d],s*n<=0&&(l++,r=-s/(n-s),o=(d-1+r)/(c-1),a=t.runNewton(o,1e-10),void 0!==a)){e.push(a),t.deflateRoot(a),h++;break}if(!h)return e}return e}}class Ut extends Bt{constructor(t=0,e=0){super(2),this.coffs[0]=t,this.coffs[1]=e}clone(){return new Ut(this.coffs[0],this.coffs[1])}static solveCoffs(t,e){return Q.conditionalDivideFraction(-t,e-t)}basisFunctions(t,e){return(!e||e.length<2)&&(e=new Float64Array(2)),e[0]=1-t,e[1]=t,e}sumBasisFunctions(t,e,i,s){(!s||s.length<i)&&(s=new Float64Array(i));const n=1-t;for(let r=0;r<i;r++)s[r]=n*e[r]+t*e[r+i];return s}sumBasisFunctionDerivatives(t,e,i,s){(!s||s.length<i)&&(s=new Float64Array(i));for(let t=0;t<i;t++)s[t]=e[t+i]-e[t];return s}evaluate(t){return(1-t)*this.coffs[0]+t*this.coffs[1]}solve(t){const e=this.coffs[1]-this.coffs[0];return Q.conditionalDivideFraction(t-this.coffs[0],e)}roots(t,e){const i=this.solve(t);if(void 0!==i)return!e||Q.isIn01(i)?[i]:void 0}}class Zt{constructor(t=1e-11,e=2,i=15){this._numAccepted=0,this.numIterations=0,this._stepSizeTolerance=t,this._successiveConvergenceTarget=e,this._maxIterations=i}testConvergence(t){return Math.abs(t)<this._stepSizeTolerance?(this._numAccepted++,this._numAccepted>=this._successiveConvergenceTarget):(this._numAccepted=0,!1)}runIterations(){for(this._numAccepted=0,this.numIterations=0;this.numIterations++<this._maxIterations&&this.computeStep();){if(this.testConvergence(this.currentStepSize())&&this.applyCurrentStep(!0))return!0;this.applyCurrentStep(!1)}return!1}}class qt{}class Wt extends Zt{constructor(t,e){super(void 0,void 0,e),this._func=t,this.setTarget(0)}setX(t){return this._currentX=t,!0}getX(){return this._currentX}setTarget(t){this._target=t}applyCurrentStep(){return this.setX(this._currentX-this._currentStep)}computeStep(){if(this._func.evaluate(this._currentX)){const t=Q.conditionalDivideFraction(this._func.currentF-this._target,this._func.currentdFdX);if(void 0!==t)return this._currentStep=t,!0}return!1}currentStepSize(){return Math.abs(this._currentStep/(1+Math.abs(this._currentX)))}}class Gt{}class Ht extends Zt{constructor(t,e){super(void 0,void 0,e),this._func=t,this.derivativeH=1e-8}setX(t){return this._currentX=t,!0}getX(){return this._currentX}applyCurrentStep(){return this.setX(this._currentX-this._currentStep)}computeStep(){if(this._func.evaluate(this._currentX)){const t=this._func.currentF;if(this._func.evaluate(this._currentX+this.derivativeH)){const e=this._func.currentF,i=Q.conditionalDivideFraction(t,(e-t)/this.derivativeH);if(void 0!==i)return this._currentStep=i,!0}}return!1}currentStepSize(){return Math.abs(this._currentStep/(1+Math.abs(this._currentX)))}}class Jt{constructor(){this.currentF=Et.createXYPlane()}}class Qt extends Zt{constructor(t,e){super(void 0,void 0,e),this._func=t,this._currentStep=J.createZero(),this._currentUV=H.createZero()}setUV(t,e){return this._currentUV.set(t,e),!0}getU(){return this._currentUV.x}getV(){return this._currentUV.y}applyCurrentStep(){return this.setUV(this._currentUV.x-this._currentStep.x,this._currentUV.y-this._currentStep.y)}computeStep(){if(!this._func.evaluate(this._currentUV.x,this._currentUV.y))return!1;const t=this._func.currentF,e=t.vectorU,i=t.vectorV,s=t.origin;return!!Mt.linearSystem2d(e.x,i.x,e.y,i.y,s.x,s.y,this._currentStep)}currentStepSize(){return Q.maxAbsXY(this._currentStep.x/(1+Math.abs(this._currentUV.x)),this._currentStep.y/(1+Math.abs(this._currentUV.y)))}}class Kt extends Jt{constructor(t,e){super(),this._curveP=t,this._curveQ=e,this._rayP=bt.createZero(),this._rayQ=bt.createZero()}evaluate(t,e){return this._curveP.fractionToPointAndDerivative(t,this._rayP),this._curveQ.fractionToPointAndDerivative(e,this._rayQ),this.currentF.setOriginAndVectorsXYZ(this._rayP.origin.x-this._rayQ.origin.x,this._rayP.origin.y-this._rayQ.origin.y,0,this._rayP.direction.x,this._rayP.direction.y,0,-this._rayQ.direction.x,-this._rayQ.direction.y,0),!0}}class jt extends qt{constructor(t,e){super(),this._curveP=t,this._pointQ=e,this._planeP=Et.createXYPlane()}evaluate(t){this._curveP.fractionToPointAnd2Derivatives(t,this._planeP);const e=this._planeP.origin.x-this._pointQ.x,i=this._planeP.origin.y-this._pointQ.y,s=this._planeP.vectorU.x,n=this._planeP.vectorU.y,r=this._planeP.vectorV.x,o=this._planeP.vectorV.y;return this.currentF=s*e+n*i,this.currentdFdX=r*e+s*s+o*i+n*n,!0}}class $t extends Jt{constructor(t,e){super(),this._curveP=t,this._curveQ=e,this._planeP=Et.createXYPlane(),this._planeQ=Et.createXYPlane()}evaluate(t,e){this._curveP.fractionToPointAnd2Derivatives(t,this._planeP),this._curveQ.fractionToPointAnd2Derivatives(e,this._planeQ);const i=this._planeP.origin.x-this._planeQ.origin.x,s=this._planeP.origin.y-this._planeQ.origin.y,n=this._planeP.vectorU.x,r=this._planeP.vectorU.y,o=this._planeQ.vectorU.x,a=this._planeQ.vectorU.y,c=this._planeP.vectorV.x,l=this._planeP.vectorV.y,h=this._planeQ.vectorV.x,d=this._planeQ.vectorV.y;return this.currentF.setOriginAndVectorsXYZ(n*i+r*s,o*i+a*s,0,c*i+l*s+n*n+r*r,o*n+a*r,0,-(n*o+r*a),h*i+d*s-o*o-a*a,0),!0}}class te extends Gt{constructor(){super(),this._parentCurvePrimitive=void 0}startParentCurvePrimitive(t){this._parentCurvePrimitive=t}endParentCurvePrimitive(t){this._parentCurvePrimitive=void 0}}class ee extends te{effectiveCurve(){return this._parentCurvePrimitive?this._parentCurvePrimitive:this._curve}get getDerivativeB(){return this._derivativeB}constructor(t,e){super(),this._fractionA=0,this._functionA=0,this._functionB=0,this._fractionB=0,this._derivativeB=0,this._numThisCurve=0,this._plane=t,this._intersections=e,this.startCurvePrimitive(void 0),this._ray=bt.createZero(),this._newtonSolver=new Ht(this)}startCurvePrimitive(t){this._curve=t,this._fractionA=0,this._numThisCurve=0,this._functionA=0}endCurvePrimitive(){}announceIntervalForUniformStepStrokes(t,e,i,s){this.startCurvePrimitive(t),e<1&&(e=1);const n=1/e;for(let r=0;r<=e;r++){const e=Q.interpolate(i,r*n,s);t.fractionToPointAndDerivative(e,this._ray),this.announcePointTangent(this._ray.origin,e,this._ray.direction)}}announceSegmentInterval(t,e,i,s,n,r){const o=this._plane.altitude(e),a=this._plane.altitude(i);if(o*a>0)return;const c=Ut.solveCoffs(o,a);if(void 0!==c){const t=Q.interpolate(n,c,r);this._newtonSolver.setX(t),this._newtonSolver.runIterations()&&this.announceSolutionFraction(this._newtonSolver.getX())}}announceSolutionFraction(t){const e=this.effectiveCurve();e&&(this._ray=e.fractionToPointAndDerivative(t,this._ray),this._intersections.push(vt.createCurveFractionPoint(e,t,this._ray.origin)))}evaluate(t){const e=this.effectiveCurve();return!!e&&(this.currentF=this._plane.altitude(e.fractionToPoint(t)),!0)}searchInterval(){if(!(this._functionA*this._functionB>0)&&(0===this._functionA&&this.announceSolutionFraction(this._fractionA),0===this._functionB&&this.announceSolutionFraction(this._fractionB),this._functionA*this._functionB<0)){const t=Q.inverseInterpolate(this._fractionA,this._functionA,this._fractionB,this._functionB);t&&(this._newtonSolver.setX(t),this._newtonSolver.runIterations()&&this.announceSolutionFraction(this._newtonSolver.getX()))}}evaluateB(t,e,i){this._functionB=this._plane.altitude(t),this._derivativeB=this._plane.velocity(i),this._fractionB=e}announcePointTangent(t,e,i){this.evaluateB(t,e,i),this._numThisCurve++>0&&this.searchInterval(),this._functionA=this._functionB,this._fractionA=this._fractionB}}!function(t){t[t.None=0]="None",t[t.OnTangent=1]="OnTangent",t[t.OnCurve=2]="OnCurve"}(S||(S={}));class ie{static resolveVariantCurveExtendParameterToCurveExtendMode(t,e){return!1===t?S.None:!0===t?S.OnCurve:Array.isArray(t)?t.length>e?t[e]:S.None:t}static correctFraction(t,e){return e<0?ie.resolveVariantCurveExtendParameterToCurveExtendMode(t,0)===S.None&&(e=0):e>1&&ie.resolveVariantCurveExtendParameterToCurveExtendMode(t,1)===S.None&&(e=1),e}static resolveRadiansToSweepFraction(t,e,i){let s=i.radiansToSignedPeriodicFraction(e);if(!i.isRadiansInSweep(e)){const n=i.fractionPeriod(),r=ie.resolveVariantCurveExtendParameterToCurveExtendMode(t,0),o=ie.resolveVariantCurveExtendParameterToCurveExtendMode(t,1);r!==S.None?o!==S.None?s=i.radiansToSignedPeriodicFraction(e):s>1&&(s-=n):o!==S.None?s<0&&(s+=n):s=Q.clamp(s,0,1)}return s}}class se extends te{constructor(t,e,i){super(),this._fractionA=0,this._functionA=0,this._functionB=0,this._fractionB=0,this._numThisCurve=0,this._spacePoint=t,this._workPoint=j.create(),this._workRay=bt.createZero(),this._closestPoint=i,this._extend=e,this.startCurvePrimitive(void 0),this._newtonSolver=new Ht(this)}claimResult(){if(this._closestPoint&&(this._newtonSolver.setX(this._closestPoint.fraction),this._curve=this._closestPoint.curve,this._newtonSolver.runIterations())){let t=this._newtonSolver.getX();t=ie.correctFraction(this._extend,t),this.announceSolutionFraction(t)}return this._closestPoint}needPrimaryGeometryForStrokes(){return!0}startCurvePrimitive(t){this._curve=t,this._fractionA=0,this._numThisCurve=0,this._functionA=0}endCurvePrimitive(){}announceIntervalForUniformStepStrokes(t,e,i,s){this.startCurvePrimitive(t),this.announceSolutionFraction(0),this.announceSolutionFraction(1),e<1&&(e=1);const n=1/e;for(let r=0;r<=e;r++){const e=Q.interpolate(i,r*n,s);t.fractionToPointAndDerivative(e,this._workRay),this.announceRay(e,this._workRay)}}announceCandidate(t,e,i){const s=this._spacePoint.distance(i);this._closestPoint&&s>this._closestPoint.a||(this._closestPoint=vt.createCurveFractionPoint(t,e,i,this._closestPoint),this._closestPoint.a=s,void 0!==this._parentCurvePrimitive&&(this._closestPoint.curve=this._parentCurvePrimitive))}announceSegmentInterval(t,e,i,s,n,r){let o=this._spacePoint.fractionOfProjectionToLine(e,i,0);this._extend?(0!==n&&(o=Math.max(o,0)),1!==r&&(o=Math.min(o,1))):o=Q.clampToStartEnd(o,0,1),this._workPoint=e.interpolate(o,i);const a=Q.interpolate(n,o,r);this.announceCandidate(t,a,this._workPoint)}searchInterval(){if(!(this._functionA*this._functionB>0)&&(0===this._functionA&&this.announceSolutionFraction(this._fractionA),0===this._functionB&&this.announceSolutionFraction(this._fractionB),this._functionA*this._functionB<0)){const t=Q.inverseInterpolate(this._fractionA,this._functionA,this._fractionB,this._functionB);t&&(this._newtonSolver.setX(t),this._newtonSolver.runIterations()&&this.announceSolutionFraction(this._newtonSolver.getX()))}}evaluateB(t,e){this._functionB=e.dotProductToPoint(this._spacePoint),this._fractionB=t}announceSolutionFraction(t){this._curve&&this.announceCandidate(this._curve,t,this._curve.fractionToPoint(t))}evaluate(t){let e=this._curve;return this._parentCurvePrimitive&&(e=this._parentCurvePrimitive),!!e&&(this._workRay=e.fractionToPointAndDerivative(t,this._workRay),this.currentF=this._workRay.dotProductToPoint(this._spacePoint),!0)}announceRay(t,e){this.evaluateB(t,e),this._numThisCurve++>0&&this.searchInterval(),this._functionA=this._functionB,this._fractionA=this._fractionB}announcePointTangent(t,e,i){this._workRay.set(t,i),this.announceRay(e,this._workRay)}}class ne{static mapWeights(t,e,i,s,n,r){const o=i.length;for(let a=0;a<o;a++)n[a]=t+e*i[a],r[a]=e*s[a];return o}static setupGauss1(t,e,i,s){return ne.mapWeights(t,e-t,ne.gaussX1Interval01,ne.gaussW1Interval01,i,s)}static setupGauss2(t,e,i,s){return ne.mapWeights(t,e-t,ne.gaussX2Interval01,ne.gaussW2Interval01,i,s)}static setupGauss3(t,e,i,s){return ne.mapWeights(t,e-t,ne.gaussX3Interval01,ne.gaussW3Interval01,i,s)}static setupGauss5(t,e,i,s){return ne.mapWeights(t,e-t,ne.gaussX5Interval01,ne.gaussW5Interval01,i,s)}static setupGauss4(t,e,i,s){return ne.mapWeights(t,e-t,ne.gaussX4Interval01,ne.gaussW4Interval01,i,s)}static sum1(t,e,i,s){let n=0;for(let r=0;r<i;r++)n+=e[r]*s(t[r]);return n}static doGaussIntegral(t,e,i,s,n=5){const r=new re(n);s<1&&(s=1);const o=1/s;let a=0;for(let n=1;n<=s;n++){const c=Q.interpolate(t,(n-1)*o,e),l=n===s?e:Q.interpolate(t,n*o,e),h=r.mapXAndW(c,l);for(let t=0;t<h;t++)a+=r.gaussW[t]*i(r.gaussX[t])}return a}}ne.gaussX1Interval01=new Float64Array([.5]),ne.gaussW1Interval01=new Float64Array([1]),ne.gaussX2Interval01=new Float64Array([.21132486540518708,.7886751345948129]),ne.gaussW2Interval01=new Float64Array([.5,.5]),ne.gaussX3Interval01=new Float64Array([.1127016653792583,.5,.8872983346207417]),ne.gaussW3Interval01=new Float64Array([.2777777777777778,.4444444444444444,.2777777777777778]),ne.gaussX4Interval01=new Float64Array([.06943184420297371,.33000947820757187,.6699905217924281,.9305681557970262]),ne.gaussW4Interval01=new Float64Array([.17392742256872692,.3260725774312731,.3260725774312731,.17392742256872692]),ne.gaussX5Interval01=new Float64Array([.04691007703066802,.23076534494715845,.5,.7692346550528415,.9530899229693319]),ne.gaussW5Interval01=new Float64Array([.11846344252809454,.23931433524968324,.28444444444444444,.23931433524968324,.11846344252809454]);class re{mapXAndW(t,e){return this.mapXAndWFunction(t,e,this.gaussX,this.gaussW)}constructor(t){switch(this.gaussX=new Float64Array(7),this.gaussW=new Float64Array(7),(t>5||t<1)&&(t=5),t){case 1:this.mapXAndWFunction=(t,e,i,s)=>ne.setupGauss1(t,e,i,s);break;case 2:this.mapXAndWFunction=(t,e,i,s)=>ne.setupGauss2(t,e,i,s);break;case 3:this.mapXAndWFunction=(t,e,i,s)=>ne.setupGauss3(t,e,i,s);break;case 4:this.mapXAndWFunction=(t,e,i,s)=>ne.setupGauss4(t,e,i,s);break;default:this.mapXAndWFunction=(t,e,i,s)=>ne.setupGauss5(t,e,i,s)}}}class oe{tangentMagnitude(t){return this._ray=this._curve.fractionToPointAndDerivative(t,this._ray),this._ray.direction.magnitude()}get getFraction0(){return this._fraction0}get getFraction1(){return this._fraction1}getSum(){return this._summedLength}constructor(t=0,e=1,i=5){this.startCurvePrimitive(void 0),this._summedLength=0,this._ray=bt.createZero(),t<e?(this._fraction0=t,this._fraction1=e):(this._fraction0=e,this._fraction1=t),this._gaussMapper=new re(i)}startCurvePrimitive(t){this._curve=t}startParentCurvePrimitive(t){}endParentCurvePrimitive(t){}endCurvePrimitive(){}announceIntervalForUniformStepStrokes(t,e,i,s){const n=ft.createXX(i,s);if(n.intersectRangeXXInPlace(this._fraction0,this._fraction1),!n.isNull){this.startCurvePrimitive(t),e<1&&(e=1);const i=1/e;for(let t=1;t<=e;t++){const s=n.fractionToPoint((t-1)*i),r=t===e?n.high:n.fractionToPoint(t*i),o=this._gaussMapper.mapXAndW(s,r);for(let t=0;t<o;t++)this._summedLength+=this._gaussMapper.gaussW[t]*this.tangentMagnitude(this._gaussMapper.gaussX[t])}}}announceSegmentInterval(t,e,i,s,n,r){const o=e.distance(i);if(this._fraction0<=n&&r<=this._fraction1)this._summedLength+=o;else{const t=ft.createXX(n,r);t.intersectRangeXXInPlace(this._fraction0,this._fraction1),t.isNull||(this._summedLength+=o*t.length()/(r-n))}}announcePointTangent(t,e,i){}}class ae extends Ot{constructor(){super(),this.geometryCategory="curvePrimitive"}fractionToPointAndUnitTangent(t,e){const i=this.fractionToPointAndDerivative(t,e);return i.trySetDirectionMagnitudeInPlace(1),i}fractionToCurvature(t){const e=this.fractionToPointAnd2Derivatives(t),i=e.vectorU.crossProduct(e.vectorV).magnitude(),s=e.vectorU.magnitude();return Q.conditionalDivideFraction(i,s*s*s)}fractionToFrenetFrame(t,e){const i=this.fractionToPointAnd2Derivatives(t);if(!i)return;let s=xt.createRigidFromColumns(i.vectorU,i.vectorV,g.XYZ);if(s)return pt.createRefs(i.origin,s,e);const n=xt.createPerpendicularVectorFavorXYPlane(i.vectorU,i.vectorV);return s=xt.createRigidFromColumns(i.vectorU,n,g.XYZ),s?pt.createRefs(i.origin,s,e):void 0}fractionToSignedXYRadiusOfCurvature(t){const e=this.fractionToPointAnd2Derivatives(t);if(!e)return 0;const i=e.vectorU.crossProductXY(e.vectorV),s=e.vectorU.magnitude();if(0===s)return 0;const n=Q.conditionalDivideCoordinate(s*s*s,i);return void 0!==n?n:0}fractionAndDistanceToPointOnTangent(t,e){return this.fractionToPointAndUnitTangent(t).fractionToPoint(e)}curveLength(){const t=new oe;return this.emitStrokableParts(t),t.getSum()}curveLengthBetweenFractions(t,e){if(t===e)return 0;if(void 0!==this.getFractionToDistanceScale()){const i=this.curveLength();return Math.abs((e-t)*i)}const i=new oe(t,e);return this.emitStrokableParts(i),Math.abs(i.getSum())}rangeBetweenFractions(t,e,i){return this.rangeBetweenFractionsByClone(t,e,i)}rangeBetweenFractionsByClone(t,e,i){if(t===e)return ut.create(this.fractionToPoint(t));const s=this.clonePartialCurve(t,e);return s?s.range(i):ut.createNull()}rangeBetweenFractionsByCount(t,e,i,s,n=0){const r=ut.createNull(),o=j.create();r.extendPoint(this.startPoint(o)),r.extendPoint(this.endPoint(o));const a=(t,e,i)=>{let n=t;for(let t=0;t<i;t++,n+=e)this.fractionToPoint(n,o),s?r.extendTransformedPoint(s,o):r.extendPoint(o)},c=i-2;if(c>0){const i=1/(c+1)*(e-t);a(t+i,i,c)}if(n>0){const i=r.clone(),s=c+1,o=.5/s*2*(e-t);a(t+.5*o,o,s),r.extendWhenLarger(i,n)}return r}curveLengthWithFixedIntervalCountQuadrature(t,e,i,s=5){if(t>e){const i=t;t=e,e=i}const n=new oe(t,e,s);return n.announceIntervalForUniformStepStrokes(this,i,t,e),Math.abs(n.getSum())}moveSignedDistanceFromFraction(t,e,i,s){if(void 0!==this.getFractionToDistanceScale()){const n=this.curveLength(),r=Q.conditionalDivideFraction(e,n);return void 0===r?vt.createCurveFractionPointDistanceCurveSearchStatus(this,t,this.fractionToPoint(t),0,A.error):vt.createConditionalMoveSignedDistance(i,this,t,t+r,e,s)}return this.moveSignedDistanceFromFractionGeneric(t,e,i,s)}moveSignedDistanceFromFractionGeneric(t,i,s,n){let r;if(0===i)return vt.createCurveEvaluatedFraction(this,t,n);if(i>0){if(r=1,t>=1){const e=.9;i+=this.curveLengthBetweenFractions(e,t),t=e}}else if(r=0,t<=0){const e=.1;i-=this.curveLengthBetweenFractions(t,e),t=e}const o=this.curveLengthBetweenFractions(t,r);e(o>0);const a=Math.abs(i);if(o<a&&!s)return vt.createConditionalMoveSignedDistance(s,this,t,r,i,n);const c=Q.conditionalDivideCoordinate(a,o);if(void 0===c)return(n=vt.createCurveEvaluatedFraction(this,t,n)).curveSearchStatus=A.error,n;const l=i<0?-1:1;let h=Q.interpolate(t,c,r),d=t,u=0;const f=1e-12*o;let g=0;const p=bt.createXAxis();for(let t=0;t<10;t++){const t=u+(h>d?l:-l)*this.curveLengthBetweenFractions(d,h),e=a-t;if(Math.abs(e)<f){if(g++,g>1)break}else g=0;if(this.fractionToPointAndDerivative(h,p),d=h,h=d+l*e/p.direction.magnitude(),d===h){g=100;break}u=t}return g>1?vt.createConditionalMoveSignedDistance(s,this,t,h,i,n):((n=vt.createCurveEvaluatedFraction(this,t,n)).curveSearchStatus=A.error,n)}get isExtensibleFractionSpace(){return!1}closestPoint(t,e,i){const s=new se(t,e,i);return this.emitStrokableParts(s),s.claimResult()}announceClipIntervals(t,e){return!1}clonePartialCurve(t,e){}getFractionToDistanceScale(){}appendPlaneIntersectionPoints(t,e){const i=new ee(t,e),s=e.length;return this.emitStrokableParts(i),e.length-s}static snapAndRestrictDetails(t,e=!0,i=!1,s=Q.smallAngleRadians,n=Q.smallMetricDistance){const r=t.length;let o=0;const a=j.create(),c=j.create();let l;for(let h=0;h<r;h++){l=void 0;const r=t[h];let d=r.fraction,u=e||Q.isIn01(d);r.curve&&(r.curve.startPoint(a),r.curve.endPoint(c)),s>0&&(Math.abs(d)<s&&(d=0,u=!0,r.intervalRole=P.isolatedAtVertex,l=a),Math.abs(d-1)<s&&(d=1,u=!0,r.intervalRole=P.isolatedAtVertex,l=c,r.curve&&(l=r.curve.startPoint(c)))),n>0&&void 0!==r.curve&&(r.point.distance(a)<=n?(d=0,r.intervalRole=P.isolatedAtVertex,l=a):r.point.distance(c)<=n&&(d=1,r.intervalRole=P.isolatedAtVertex,l=c)),u&&(i&&(r.fraction=d,void 0!==l&&r.point.setFrom(l)),o<h&&(t[o]=r),o++)}o<r&&(t.length=o)}startPoint(t){return this.fractionToPoint(0,t)}endPoint(t){return this.fractionToPoint(1,t)}computeAndAttachRecursiveStrokeCounts(t,e){const i=this.computeStrokeCountForOptions(t),s=this.curveLength();ae.installStrokeCountMap(this,Nt.createWithCurvePrimitive(this,i,s,0,s),e)}addMappedStrokesToLineString3D(t,e){const i=e.numPoints();if(t.primitive&&t.primitive===this&&t.numStroke>0)for(let i=0;i<=t.numStroke;i++){const s=i/t.numStroke;e.appendFractionToPoint(this,s)}return e.numPoints()-i}static installStrokeCountMap(t,e,i){i&&i.addToCountAndLength(e.numStroke,e.curveLength),t.strokeData=e}collectCurvePrimitivesGo(t,e,i=!1){t.push(this)}collectCurvePrimitives(t,e=!1,i=!1){const s=void 0===t?[]:t;return this.collectCurvePrimitivesGo(s,e,i),s}projectedParameterRange(t,e){}}class ce extends st{constructor(t){super(),this.data=t}isValidIndex(t){return t>=0&&t<this.data.length}getPoint3dAtCheckedPointIndex(t,e){if(this.isValidIndex(t)){const i=this.data[t];return j.create(i.x,i.y,i.z,e)}}getPoint3dAtUncheckedPointIndex(t,e){const i=this.data[t];return j.create(i.x,i.y,i.z,e)}getVector3dAtCheckedVectorIndex(t,e){if(this.isValidIndex(t)){const i=this.data[t];return $.create(i.x,i.y,i.z,e)}}getXAtUncheckedPointIndex(t){return this.data[t].x}getYAtUncheckedPointIndex(t){return this.data[t].y}getZAtUncheckedPointIndex(t){return this.data[t].z}vectorIndexIndex(t,e,i){if(this.isValidIndex(t)&&this.isValidIndex(e))return $.createStartEnd(this.data[t],this.data[e],i)}vectorXYAndZIndex(t,e,i){if(this.isValidIndex(e))return $.createStartEnd(t,this.data[e],i)}crossProductXYAndZIndexIndex(t,e,i,s){if(this.isValidIndex(e)&&this.isValidIndex(i))return $.createCrossProductToPoints(t,this.data[e],this.data[i],s)}crossProductIndexIndexIndex(t,e,i,s){if(this.isValidIndex(t)&&this.isValidIndex(e)&&this.isValidIndex(i))return $.createCrossProductToPoints(this.data[t],this.data[e],this.data[i],s)}accumulateCrossProductIndexIndexIndex(t,e,i,s){const n=this.data;this.isValidIndex(t)&&this.isValidIndex(e)&&this.isValidIndex(i)&&s.addCrossProductToTargetsInPlace(n[t].x,n[t].y,n[t].z,n[e].x,n[e].y,n[e].z,n[i].x,n[i].y,n[i].z)}accumulateScaledXYZ(t,e,i){if(this.isValidIndex(t)){const s=this.data[t];i.x+=e*s.x,i.y+=e*s.y,i.z+=e*s.z}}get length(){return this.data.length}push(t){this.data.push(t.clone())}pushXYZ(t,e,i){this.data.push(j.create(void 0===t?0:t,void 0===e?0:e,void 0===i?0:i))}back(t){if(this.data.length>0)return this.data[this.data.length-1].clone(t)}front(t){if(this.data.length>0)return this.data[0].clone(t)}pop(){this.data.length>0&&this.data.pop()}clear(){this.data.length=0}reverseInPlace(){this.data.reverse()}distanceSquaredIndexIndex(t,e){const i=this.data.length;if(t>=0&&t<i&&e>=0&&e<i)return this.data[t].distanceSquared(this.data[e])}distanceIndexIndex(t,e){const i=this.data.length;if(t>=0&&t<i&&e>=0&&e<i)return this.data[t].distance(this.data[e])}cyclicIndex(t){return t%this.data.length}}function le(t,e,i){if(void 0!==e){const s=e*i;if(s>=0&&s<=t)return s}return t}class he{static preciseSum(t){const e=t.length;if(0===e)return 0;let i,s,n=t[0],r=0;for(let o=1;o<e;o++)i=t[o]-r,s=n+i,r=s-n-i,n=s;return n}static isExactEqual(t,e){if(t&&e){if(t.length!==e.length)return!1;for(let i=0;i<t.length;i++)if(t[i]!==e[i])return!1;return!0}return void 0===t&&void 0===e}static isAlmostEqual(t,e,i=Q.smallMetricDistance){if(t&&e){if(t.length!==e.length)return!1;for(let s=0;s<t.length;s++)if(Math.abs(t[s]-e[s])>i)return!1;return!0}return void 0===t&&void 0===e}static sum(t){let e=0;for(const i of t)e+=i;return e}static isCoordinateInArray(t,e){if(e)for(const i of e)if(Q.isSameCoordinate(t,i))return!0;return!1}static maxAbsArray(t){const e=t.length;if(0===e)return 0;let i=Math.abs(t[0]);for(let s=1;s<e;s++){const e=Math.abs(t[s]);i<e&&(i=e)}return i}static maxAbsTwo(t,e){return(t=Math.abs(t))>(e=Math.abs(e))?t:e}static maxAbsDiff(t,e){let i=0;const s=Math.min(t.length,e.length);for(let n=0;n<s;n++)i=Math.max(i,Math.abs(t[n]-e[n]));return i}static maxAbsDiffFloat64(t,e){let i=0;const s=Math.min(t.length,e.length);for(let n=0;n<s;n++)i=Math.max(i,Math.abs(t[n]-e[n]));return i}static createArrayWithMaxStepSize(t,e,i){if(t===e)return[t];const s=e-t,n=Math.max(1,Math.floor(Math.abs(s/i))),r=[];r.push(t);for(let e=1;e<n;e++)r.push(t+e/n*s);return r.push(e),r}static create(t){const e=[];for(const i of t)e.push(i);return e}static copy2d(t){const e=[];for(const i of t){const t=[];for(const e of i)t.push(e);e.push(t)}return e}static copy3d(t){const e=[];for(const i of t){const t=[];for(const e of i){const i=[];for(const t of e)i.push(t);t.push(i)}e.push(t)}return e}static unpack2d(t,e){if(!(e<1))return ue.unpackNumbersToNestedArrays(t,e)}static unpack3d(t,e,i){if(!(i<1||e<1))return ue.unpackNumbersToNestedArraysIJK(t,i,e)}static pack(t){const e=t.length;let i=0,s=0,n=0;e>0&&(n=e,Array.isArray(t[0])&&(i=t[0].length,i>0&&(n*=i,Array.isArray(t[0][0])&&(s=t[0][0].length,s>0&&(n*=s)))));const r=new Float64Array(n);if(s>0){const n=t;for(let t=0,o=0;t<e;++t)for(let e=0;e<i;++e)for(let i=0;i<s;++i)r[o++]=n[t][e][i]}else if(i>0){const s=t;for(let t=0,n=0;t<e;++t)for(let e=0;e<i;++e)r[n++]=s[t][e]}else if(e>0){const i=t;for(let t=0,s=0;t<e;++t)r[s++]=i[t]}return r}static cloneWithStartAndEndMultiplicity(t,e,i){const s=[];if(void 0===t||0===t.length)return s;let n=1;const r=t[0],o=t[t.length-1];for(;n<t.length&&t[n]===r;)n++;let a=1;const c=t.length-1;for(;c-a>=0&&t[c-a]===o;)a++;for(let t=0;t<e;t++)s.push(r);for(let e=n;e+a<t.length;e++)s.push(t[e]);for(let t=0;t<i;t++)s.push(o);return s}static linearCombination(t,e){const i=Math.min(t.length,e.length);let s=0;for(let n=0;n<i;++n)s+=e[n]*t[n];return s}static linearCombinationOfColors(t,e){const i=Math.min(t.length,e.length),s=[0,0,0,0];for(let n=0,r=0;n<4;++n,r+=8){for(let o=0;o<i;++o){const i=Q.clamp(e[o],0,1),a=t[o]>>>r&255;s[n]+=i*a}s[n]=(255&Math.floor(s[n]))<<r}return s[0]|s[1]|s[2]|s[3]}}class de{static packPointsAndWeightsToFloat64Array(t,e,i){let s;if(Array.isArray(t)&&t[0]instanceof j){if(s=t,s.length!==e.length)return;const n=4*s.length;(!i||i.length<n)&&(i=new Float64Array(n));for(let t=0,n=0;n<s.length;n++)i[t++]=s[n].x,i[t++]=s[n].y,i[t++]=s[n].z,i[t++]=e[n];return i}s=t;const n=e.length;if(s.length!==3*n)return;const r=4*n;(!i||i.length<r)&&(i=new Float64Array(r));for(let t=0,r=0;r<n;r++){const n=3*r;i[t++]=s[n],i[t++]=s[n+1],i[t++]=s[n+2],i[t++]=e[r]}return i}static packToFloat64Array(t,e){const i=4*t.length;(!e||e.length<i)&&(e=new Float64Array(i));let s=0;for(const i of t)e[s++]=i.x,e[s++]=i.y,e[s++]=i.z,e[s++]=i.w;return e}static unpackToPoint4dArray(t){const e=[];for(let i=0;i+3<t.length;i+=4)e.push(Dt.create(t[i],t[i+1],t[i+2],t[i+3]));return e}static unpackFloat64ArrayToPointsAndWeights(t,e,i,s=(t,e,i)=>j.create(t,e,i)){e.length=0,i.length=0;for(let n=0;n+3<t.length;n+=4)e.push(s(t[n],t[n+1],t[n+2])),i.push(t[n+3])}static multiplyInPlace(t,e){const i=e.length,s=de._workPoint4d;for(let n=0;n+3<i;n+=4)t.multiplyXYZW(e[n],e[n+1],e[n+2],e[n+3],s),e[n]=s.x,e[n+1]=s.y,e[n+2]=s.z,e[n+3]=s.w}static isAlmostEqual(t,e){if(t&&e){if(t instanceof Float64Array&&e instanceof Float64Array){if(t.length!==e.length)return!1;for(let i=0;i<t.length;i++)if(!Q.isSameCoordinate(t[i],e[i]))return!1}else if(Array.isArray(t)&&Array.isArray(e)){if(t.length!==e.length)return!1;for(let i=0;i<t.length;i++)if(!t[i].isAlmostEqual(e[i]))return!1}else{const i=t instanceof Float64Array?e:t,s=t instanceof Float64Array?t:e;if(s.length!==4*i.length)return!1;for(let t=0;t<i.length;++t)if(!(Q.isSameCoordinate(i[t].x,s[4*t])&&Q.isSameCoordinate(i[t].y,s[4*t+1])&&Q.isSameCoordinate(i[t].z,s[4*t+2])&&Q.isSameCoordinate(i[t].w,s[4*t+3])))return!1}return!0}return void 0===t&&void 0===e}static isCloseToPlane(t,e,i=Q.smallMetricDistance){if(Array.isArray(t)){for(const s of t)if(Math.abs(e.altitudeXYZW(s.x,s.y,s.z,s.w))>i)return!1}else if(t instanceof Float64Array){const s=t.length;for(let n=0;n+2<s;n+=4)if(Math.abs(e.altitudeXYZW(t[n],t[n+1],t[n+2],t[n+3]))>i)return!1}return!0}}de._workPoint4d=Dt.create();class ue{static packToFloat64Array(t,e){const i=3*t.length;(!e||e.length<i)&&(e=new Float64Array(i));let s=0;for(const i of t)e[s++]=i.x,e[s++]=i.y,e[s++]=i.z;return e}static packToNumberArray(t,e){const i=3*t.length;e||(e=Array(i)),e.length=i;let s=0;for(const i of t)e[s++]=i.x,e[s++]=i.y,e[s++]=i.z;return e}static evaluateTrilinearWeights(t,e,i,s,n,r,o){t[0]=e*s*r,t[1]=i*s*r,t[2]=e*n*r,t[3]=i*n*r,t[4]=e*s*o,t[5]=i*s*o,t[6]=e*n*o,t[7]=i*n*o}static sumWeightedX(t,e){let i=0;const s=t.length;for(let n=0;n<s;n++)i+=t[n]*e[n].x;return i}static sumWeightedY(t,e){let i=0;const s=t.length;for(let n=0;n<s;n++)i+=t[n]*e[n].y;return i}static sumWeightedZ(t,e){let i=0;const s=t.length;for(let n=0;n<s;n++)i+=t[n]*e[n].z;return i}static evaluateTrilinearPoint(t,e,i,s,n){let r;n||(n=j.create(0,0,0)),this.evaluateTrilinearWeights(this._weightUVW,1-e,e,1-i,i,1-s,s);for(let e=0;e<8;e++)r=this._weightUVW[e],n.x+=r*t[e].x,n.y+=r*t[e].y,n.z+=r*t[e].z;return n}static evaluateTrilinearDerivativeTransform(t,e,i,s,n){return this.evaluateTrilinearWeights(this._weightUVW,1-e,e,1-i,i,1-s,s),this.evaluateTrilinearWeights(this._weightDU,-1,1,1-i,i,1-s,s),this.evaluateTrilinearWeights(this._weightDV,1-e,e,-1,1,1-s,s),this.evaluateTrilinearWeights(this._weightDW,1-e,e,1-i,i,-1,1),pt.createRowValues(this.sumWeightedX(this._weightDU,t),this.sumWeightedX(this._weightDV,t),this.sumWeightedX(this._weightDW,t),this.sumWeightedX(this._weightUVW,t),this.sumWeightedY(this._weightDU,t),this.sumWeightedY(this._weightDV,t),this.sumWeightedY(this._weightDW,t),this.sumWeightedY(this._weightUVW,t),this.sumWeightedZ(this._weightDU,t),this.sumWeightedZ(this._weightDV,t),this.sumWeightedZ(this._weightDW,t),this.sumWeightedZ(this._weightUVW,t),n)}static unpackNumbersToPoint3dArray(t){const e=[];for(let i=0;i+2<t.length;i+=3)e.push(j.create(t[i],t[i+1],t[i+2]));return e}static unpackNumbersToNestedArrays(t,e){const i=[],s=t.length;let n=0,r=0;for(;n<s;){const o=[];for(r=n+e,r>s&&(r=s);n<r;n++)o.push(t[n]);i.push(o)}return i}static unpackNumbersToNestedArraysIJK(t,e,i){const s=[],n=t.length;let r,o=0,a=0;for(;o<n;){const c=[];for(r=o+e*i;o<r;){const i=[];for(a=o+e,a>n&&(a=n);o<a;o++)i.push(t[o]);c.push(i)}s.push(c)}return s}static multiplyInPlace(t,e){const i=j.create(),s=e.length;for(let n=0;n+2<s;n+=3)t.multiplyXYZ(e[n],e[n+1],e[n+2],i),e[n]=i.x,e[n+1]=i.y,e[n+2]=i.z}static isAlmostEqual(t,e){if(t&&e){if(t instanceof Float64Array&&e instanceof Float64Array){if(t.length!==e.length)return!1;for(let i=0;i<t.length;i++)if(!Q.isSameCoordinate(t[i],e[i]))return!1}else if(Array.isArray(t)&&Array.isArray(e)){if(t.length!==e.length)return!1;for(let i=0;i<t.length;i++)if(!t[i].isAlmostEqual(e[i]))return!1}else{const i=t instanceof Float64Array?e:t,s=t instanceof Float64Array?t:e;if(s.length!==3*i.length)return!1;for(let t=0;t<i.length;++t)if(!Q.isSameCoordinate(i[t].x,s[3*t])||!Q.isSameCoordinate(i[t].y,s[3*t+1])||!Q.isSameCoordinate(i[t].z,s[3*t+2]))return!1}return!0}return void 0===t&&void 0===e}static centroid(t,e){if(t instanceof it){e=j.create(0,0,0,e);const i=j.create();if(t.length>0){for(let s=0;s<t.length;s++)t.getPoint3dAtCheckedPointIndex(s,i),e.x+=i.x,e.y+=i.y,e.z+=i.z;e.scaleInPlace(1/t.length)}return e}const i=new ce(t);return this.centroid(i)}static indexOfMostDistantPoint(t,e,i){if(0===t.length)return;let s,n=-1,r=-1;for(let o=0;o<t.length;o++)s=e.distance(t[o]),s>n&&(e.vectorTo(t[o],i),n=s,r=o);return r}static indexOfPointWithMaxCrossProductMagnitude(t,e,i,s){if(0===t.length)return;let n,r,o=-1,a=-1;for(let c=0;c<t.length;c++)r=e.vectorTo(t[c],r),n=r.crossProductMagnitude(i),n>o&&(s.setFrom(r),o=n,a=c);return a}static closestPointIndex(t,e){let i,s=-1,n=Number.MAX_VALUE;const r=e.x,o=e.y,a=e.z;for(let e=0;e<t.length;e++)i=Q.distanceXYZXYZ(r,o,a,t[e].x,t[e].y,t[e].z),i<n&&(s=e,n=i);return s}static isCloseToPlane(t,e,i=Q.smallMetricDistance){if(Array.isArray(t)){let s;for(s of t)if(Math.abs(e.altitude(s))>i)return!1}else if(t instanceof Float64Array){const s=t.length;for(let n=0;n+2<s;n+=3)if(Math.abs(e.altitudeXYZ(t[n],t[n+1],t[n+2]))>i)return!1}return!0}static sumEdgeLengths(t,e=!1,i){let s=0;if(Array.isArray(t)){const n=le(t.length,i,1)-1;for(let e=0;e<n;e++)s+=t[e].distance(t[e+1]);e&&n>0&&(s+=t[0].distance(t[n]))}else if(t instanceof Float64Array){const n=le(t.length,i,3);let r=0;for(;r+5<n;r+=3)s+=Q.hypotenuseXYZ(t[r+3]-t[r],t[r+4]-t[r+1],t[r+5]-t[r+2]);e&&r>=3&&(s+=Q.hypotenuseXYZ(t[0]-t[r],t[1]-t[r+1],t[2]-t[r+2]))}return s}static countNonDuplicates(t,e=Q.smallMetricDistance){let i=t.length;for(;i>1&&t[0].isAlmostEqual(t[i-1],e);)i--;for(let s=0;s+1<i;s++)if(t[s].isAlmostEqual(t[s+1],e))return 0;return i}static clonePoint3dArray(t){const e=[];if(0===t.length)return e;if(t instanceof Float64Array){for(let i=0;i+2<t.length;i+=3)e.push(j.create(t[i],t[i+1],t[i+2]));return e}for(const i of t)Array.isArray(i)?e.push(j.create(i[0],i[1],i[2])):e.push(j.create(i.x,i.y,i.z));return e}static clonePoint2dArray(t){return t.map((t=>H.create(t.x,t.y)))}static cloneWithMaxEdgeLength(t,e){if(0===t.length)return[];const i=[t[0]];for(let s=1;s<t.length;s++){const n=t[s-1].distance(t[s]),r=Q.stepCount(e,n,1);for(let e=1;e<r;e++)i.push(t[s-1].interpolate(e/r,t[s]));i.push(t[s])}return i}static xyzToArray(t,e,i){return[t,e,i]}static cloneDeepJSONNumberArrays(t){const e=new lt(((t,e,i)=>this.xyzToArray(t,e,i)));return ht.streamXYZ(t,e),e.claimResult()}static cloneXYZPropsAsNumberArray(t){const e=[];for(const i of t)if(i instanceof j)e.push([i.x,i.y,i.z]);else if(Array.isArray(i)){const t=i.length>0?i[0]:0,s=i.length>1?i[1]:0,n=i.length>2?i[2]:0;e.push([t,s,n])}else{const t=void 0!==i.x?i.x:0,s=void 0!==i.y?i.y:0,n=void 0!==i.z?i.z:0;e.push([t,s,n])}return e}static cloneXYZPropsAsFloat64Array(t){const e=new Float64Array(3*t.length);let i=0;for(const s of t)s instanceof j?(e[i++]=s.x,e[i++]=s.y,e[i++]=s.z):Array.isArray(s)?(e[i++]=s.length>0?s[0]:0,e[i++]=s.length>1?s[1]:0,e[i++]=s.length>2?s[2]:0):(e[i++]=void 0!==s.x?s.x:0,e[i++]=void 0!==s.y?s.y:0,e[i++]=void 0!==s.z?s.z:0);return e}static cloneDeepXYZPoint3dArrays(t){const e=new lt(((t,e,i)=>j.create(t,e,i)));return ht.streamXYZ(t,e),e.claimResult()}static distanceIndexedPointBToSegmentAC(t,e,i,s,n){const r=$.createStartEnd(t[e],t[s]),o=$.createStartEnd(t[e],t[i]),a=r.dotProduct(r),c=r.dotProduct(o),l=Q.conditionalDivideFraction(c,a);if(void 0===l)return o.magnitude();if(!n){if(l>1)return t[i].distance(t[s]);if(l<0)return o.magnitude()}const h=o.magnitudeSquared()-l*l*a;return h<=0?0:Math.sqrt(h)}static computeConvexHullXY(t,e,i,s=!1){e.length=0,i.length=0;let n=t.length;const r=t.slice(0,n);if(r.sort(((t,e)=>Q.lexicalXYLessThan(t,e))),n<3){for(const t of r)e.push(t);return void(s&&r.length>0&&e.push(r[0]))}e.push(r[0]),e.push(r[1]);let o=0;for(let t=2;t<n;t++){const i=r[t];let s=e.length-1;for(;s>=1&&e[s-1].crossProductToPointsXY(e[s],i)<=0;)r[o++]=e[s],s--,e.pop();e.push(i)}const a=e.length-1;r.length=o,r.push(e[0]),r.sort(((t,e)=>Q.lexicalXYLessThan(t,e))),n=r.length,e.push(r[n-1]);for(let t=n-1;t-- >0;){const s=r[t];let n=e.length-1;for(;n>a&&e[n-1].crossProductToPointsXY(e[n],s)<=0;)i.push(e[n]),n--,e.pop();t>0&&e.push(s)}s&&e.push(e[0])}static minMaxPoints(t){if(0===t.length)return;const e={minXPoint:t[0].clone(),maxXPoint:t[0].clone(),minYPoint:t[0].clone(),maxYPoint:t[0].clone()};let i;for(let s=1;s<t.length;s++)i=t[s],i.x<e.minXPoint.x&&e.minXPoint.setFromPoint3d(i),i.x>e.maxXPoint.x&&e.maxXPoint.setFromPoint3d(i),i.y<e.minYPoint.y&&e.minYPoint.setFromPoint3d(i),i.y>e.maxYPoint.y&&e.maxYPoint.setFromPoint3d(i);return e}}ue._weightUVW=new Float64Array(8),ue._weightDU=new Float64Array(8),ue._weightDV=new Float64Array(8),ue._weightDW=new Float64Array(8);class fe{static decomposeLU(t,e,i){const s=t-1,n=Math.floor(e/2);let r;for(let t=0;t<=s;t++){const o=Math.min(s,t+n);for(let s=t;s<=o;s++){r=0;for(let o=Math.max(0,s-n);o<t;o++)r+=i[t*e+o-t+n]*i[o*e+s-o+n];i[t*e+s-t+n]-=r}for(let s=t+1;s<=o;s++){r=0;for(let o=Math.max(0,s-n);o<t;o++)r+=i[s*e+o-s+n]*i[o*e+t-o+n];if(Math.abs(i[t*e+n])<1e-9)return!1;i[s*e+t-s+n]=(i[s*e+t-s+n]-r)/i[t*e+n]}}return!0}static arrayAddScaledBlock(t,e,i,s){const n=t.length;let r=n*i;for(let i=0;i<n;i++,r++)t[i]+=e[r]*s}static blockAssignBlockMinusArray(t,e,i,s,n){const r=n.length;let o=e*r,a=s*r;for(let e=0;e<r;e++,a++,o++)t[o]=i[a]-n[e]}static blockSumOfScaledBlockScaledArray(t,e,i,s,n,r,o){const a=r.length;let c=e*a,l=s*a;for(let e=0;e<a;e++,l++,c++)t[c]=i[l]*n+r[e]*o}static solveBandedSystemMultipleRHS(t,e,i,s,n){if(!this.decomposeLU(t,e,i))return;const r=t-1,o=Math.floor(e/2),a=new Float64Array(s),c=new Float64Array(s*t),l=new Float64Array(s*t);for(let t=0;t<=r;t++){a.fill(0);for(let s=Math.max(0,t-o);s<t;s++)this.arrayAddScaledBlock(a,c,s,i[t*e+s-t+o]);this.blockAssignBlockMinusArray(c,t,n,t,a)}for(let t=r;t>=0;t--){const s=Q.conditionalDivideCoordinate(1,i[t*e+o]);if(void 0===s)return;a.fill(0);const n=Math.min(r,t+o);for(let s=t+1;s<=n;s++)this.arrayAddScaledBlock(a,l,s,i[t*e+s-t+o]);this.blockSumOfScaledBlockScaledArray(l,t,c,t,s,a,-s)}return l}static multiplyBandedTimesFull(t,e,i,s,n){const r=new Float64Array(n.length),o=Math.floor(e/2);let a,c,l,h;for(let d=0;d<t;d++){c=d-o,c<0&&(c=0),l=d+o+1,l>t&&(l=t),h=o+d*(e-1);for(let t=0;t<s;t++){a=0;for(let e=c;e<l;e++)a+=i[h+e]*n[e*s+t];r[d*s+t]=a}}return r}}!function(t){t[t.None=0]="None",t[t.OpenByAddingControlPoints=1]="OpenByAddingControlPoints",t[t.OpenByRemovingKnots=2]="OpenByRemovingKnots"}(w||(w={}));class ge{get leftKnot(){return this._knot0}get rightKnot(){return this._knot1}get leftKnotIndex(){return this.degree-1}get rightKnotIndex(){return this.knots.length-this.degree}get wrappable(){return void 0===this._wrapMode?w.None:this._wrapMode}set wrappable(t){this._wrapMode=t}get numSpans(){return this.rightKnotIndex-this.leftKnotIndex}constructor(t,e,i){this.degree=e,this._wrapMode=i,this._knot0=0,this._knot1=1,Array.isArray(t)?(this.knots=new Float64Array(t.length),this.setKnots(t),this.setupFixedValues()):t instanceof Float64Array?(this.knots=t.slice(),this.setupFixedValues()):this.knots=new Float64Array(t)}clone(){return new ge(this.knots,this.degree,this.wrappable)}setupFixedValues(){this.degree>0&&this.knots.length>this.degree&&(this._knot0=this.knots[this.degree-1],this._knot1=this.knots[this.knots.length-this.degree])}get knotLength01(){return this._knot1-this._knot0}testClosable(t){void 0===t&&(t=this.wrappable);const e=this.degree,i=this.leftKnotIndex,s=this.rightKnotIndex;if(t===w.OpenByAddingControlPoints){const t=this.rightKnot-this.leftKnot,n=s-i;for(let s=0;s<i+e;s++){const e=s+n;if(Math.abs(this.knots[s]+t-this.knots[e])>=ge.knotTolerance)return!1}return!0}if(t===w.OpenByRemovingKnots){const t=e-1,n=this.leftKnot,r=this.rightKnot;for(let e=0;e<t;e++){if(Math.abs(n-this.knots[i-e-1])>=ge.knotTolerance)return!1;if(Math.abs(r-this.knots[s+e+1])>=ge.knotTolerance)return!1}return!0}return!1}isAlmostEqual(t){return this.degree===t.degree&&he.isAlmostEqual(this.knots,t.knots,ge.knotTolerance)}getKnotMultiplicity(t){let e=0;for(const i of this.knots)if(Math.abs(i-t)<ge.knotTolerance)++e;else if(t<i)break;return e}getKnotMultiplicityAtIndex(t){let e=0;if(t>=0&&t<this.knots.length){const i=this.knots[t];++e;for(let s=t-1;s>=0;--s){const t=this.knots[s];if(Math.abs(t-i)<ge.knotTolerance)++e;else if(i>t)break}for(let s=t+1;s<this.knots.length;++s){const t=this.knots[s];if(Math.abs(t-i)<ge.knotTolerance)++e;else if(i<t)break}}return e}normalize(){if(this.knotLength01<ge.knotTolerance)return!1;const t=1/this.knotLength01,e=this.leftKnot;for(let i=0;i<this.knots.length;++i)this.knots[i]=(this.knots[i]-e)*t;for(let t=this.rightKnotIndex-1;t>this.leftKnotIndex&&this.knots[t]===this.knots[this.rightKnotIndex];--t)this.knots[t]=1;for(let t=this.rightKnotIndex+1;t<this.knots.length&&this.knots[t]===this.knots[this.rightKnotIndex];++t)this.knots[t]=1;return this.knots[this.rightKnotIndex]=1,this.setupFixedValues(),!0}setKnots(t,e){const i=e?t.length-2:t.length;if(i!==this.knots.length&&(this.knots=new Float64Array(i)),e)for(let e=1;e+1<t.length;e++)this.knots[e-1]=t[e];else for(let e=0;e<t.length;e++)this.knots[e]=t[e];this.setupFixedValues()}setKnotsCapture(t){this.knots=t,this.setupFixedValues()}static createUniformClamped(t,e,i,s){const n=new ge(t+e-1,e);let r=0;for(let t=0;t<e;t++)n.knots[r++]=i;const o=1/(t-e);for(let a=1;a+e<t;a++)n.knots[r++]=i+a*o*(s-i);for(let t=0;t<e;t++)n.knots[r++]=s;return n.setupFixedValues(),n}static createUniformWrapped(t,e,i,s){const n=new ge(t+2*e-1,e),r=1/t;for(let o=1-e,a=0;o<t+e;o++,a++)n.knots[a]=Q.interpolate(i,o*r,s);return n.setupFixedValues(),n}static create(t,e,i){const s=i?t.length-2:t.length,n=new ge(s,e);return n.setKnots(t,i),n}grevilleKnot(t){if(t<0)return this.leftKnot;if(t>this.rightKnotIndex)return this.rightKnot;let e=0;for(let i=t;i<t+this.degree;i++)e+=this.knots[i];return e/this.degree}createBasisArray(){return new Float64Array(this.degree+1)}baseKnotFractionToKnot(t,e){const i=this.knots[t];return i+(e=Q.clamp(e,0,1))*(this.knots[t+1]-i)}spanFractionToKnot(t,e){const i=this.spanIndexToLeftKnotIndex(t);return e=Q.clamp(e,0,1),this.knots[i]+e*(this.knots[i+1]-this.knots[i])}spanFractionToFraction(t,e){return(this.spanFractionToKnot(t,e)-this.leftKnot)/(this.rightKnot-this.leftKnot)}fractionToKnot(t){return t=Q.clamp(t,0,1),Q.interpolate(this.knots[this.degree-1],t,this.knots[this.knots.length-this.degree])}evaluateBasisFunctions(t,e,i){if(i.length<this.degree+1)return!1;if(i[0]=1,this.degree<1)return!0;const s=this.knots[t],n=this.knots[t+1];if(i[1]=(e-s)/(n-s),i[0]=1-i[1],this.degree<2)return!0;for(let s=1;s<this.degree;s++){let n=t-s,r=n+s+1,o=0;for(let t=0;t<=s;t++){const s=this.knots[n++],a=(e-s)/(this.knots[r++]-s),c=i[t]*a,l=i[t]*(1-a);i[t]=o+l,o=c}i[s+1]=o}return!0}evaluateBasisFunctions1(t,e,i,s,n){if(i.length<this.degree+1)return!1;if(s.length<this.degree+1)return!1;if(n&&n.length<this.degree+1)return!1;if(i[0]=1,s[0]=0,this.degree<1)return!0;const r=this.knots[t];let o=1/(this.knots[t+1]-r);if(i[1]=(e-r)*o,i[0]=1-i[1],s[0]=-o,s[1]=o,n&&(n[0]=0,n[1]=0),this.degree<2)return!0;for(let r=1;r<this.degree;r++){let a=t-r,c=a+r+1,l=0,h=0,d=0;for(let t=0;t<=r;t++){const r=this.knots[a++];o=1/(this.knots[c++]-r);const u=(e-r)*o,f=1-u,g=i[t]*u,p=i[t]*f,m=s[t]*u+i[t]*o,x=s[t]*f-i[t]*o,_=2*s[t]*o;if(i[t]=l+p,s[t]=h+x,l=g,h=m,n){const e=n[t]*u+_,i=n[t]*f-_;n[t]=d+i,d=e}}i[r+1]=l,s[r+1]=h,n&&(n[r+1]=d)}return!0}knotToLeftKnotIndex(t){for(let e=this.leftKnotIndex;e<this.rightKnotIndex;++e)if(t<this.knots[e+1])return e;for(let t=this.rightKnotIndex;t>this.leftKnotIndex;--t)if(this.knots[t]-this.knots[t-1]>=ge.knotTolerance)return t-1;return this.rightKnotIndex-1}spanIndexToLeftKnotIndex(t){const e=this.degree;return t<=0?e-1:Math.min(t+e-1,this.knots.length-e-1)}spanIndexToSpanLength(t){const e=this.spanIndexToLeftKnotIndex(t);return this.knots[e+1]-this.knots[e]}isIndexOfRealSpan(t){return t>=0&&t<this.numSpans&&!Q.isSmallMetricDistance(this.spanIndexToSpanLength(t))}reflectKnots(){const t=this.leftKnot,e=this.rightKnot,i=this.knots.length;for(let s=0;s<i;s++)this.knots[s]=t+(e-this.knots[s]);this.knots.reverse()}static copyKnots(t,e,i,s){const n=i&&s===w.OpenByAddingControlPoints,r=e-1,o=t.length-e,a=t[r],c=t[o]-a,l=[];i&&(n?l.push(t[o-e]-c):l.push(t[0]));for(const e of t)l.push(e);return i&&(n?l.push(t[r+e]+c):l.push(t[t.length-1])),l}copyKnots(t){const e=t&&this.testClosable()?this.wrappable:void 0;return ge.copyKnots(this.knots,this.degree,t,e)}}ge.knotTolerance=1e-9;class pe{static createThroughPoints(t,e){const i=t.length;if(e>i||e<2)return;const s=e-1,n=1+2*s,r=new Float64Array(n*i),o=new Float64Array(e),a=new nt,c=ge.createUniformClamped(i,e-1,0,1),l=j.create();for(let h=0;h<i;h++){const d=c.grevilleKnot(h),u=c.knotToLeftKnotIndex(d);c.evaluateBasisFunctions(u,d,o);let f=0;for(let t=1;t<e;t++)o[t]>o[f]&&(f=t);const g=s-f,p=h*n;for(let t=0;t<e;t++){const e=h-s+g+t;p+e>=0&&e<i&&(r[p+g+t]=o[t])}t instanceof it?a.push(t.getPoint3dAtUncheckedPointIndex(h,l)):a.push(t[h].clone())}const h=fe.solveBandedSystemMultipleRHS(i,n,r,3,a.float64Data());return h?Be.create(h,c.knots,e):void 0}static createThroughPointsC2Cubic(t){const e=t.clone();if(!this.C2CubicFit.validateOptions(e))return;const i=this.C2CubicFit.constructPoles(e);if(void 0===i)return;const s=this.C2CubicFit.convertFitParamsToCubicKnotVector(e.knots,e.closed);if(void 0===s)return;const n=Be.create(i,s,e.order);return e.closed&&n?.setWrappable(w.OpenByAddingControlPoints),n}}!function(t){t.C2CubicFit=class{static normalizeKnots(t){if(void 0===t||t.length<2)return t=void 0,!1;const e=ge.create(t,1,!1);if(!e.normalize())return t=void 0,!1;for(let i=0;i<t.length;++i)t[i]=e.knots[i];return!0}static constructChordLengthParameters(t){if(t.length<2)return;const e=[0];for(let i=1;i<t.length;++i)e[i]=e[i-1]+t[i].distance(t[i-1]);return this.normalizeKnots(e)?e:void 0}static constructUniformParameters(t){if(t<2)return;const e=ge.createUniformClamped(t+2,3,0,1),i=[];for(let t=e.leftKnotIndex;t<=e.rightKnotIndex;++t)i.push(e.knots[t]);return i}static removeDuplicateFitPoints(t){void 0!==t.knots&&t.knots.length!==t.fitPoints.length&&(t.knots=void 0);const e=nt.create(t.fitPoints),i=e.findOrderedDuplicates();e.clear();for(let s=0,n=0;s<t.fitPoints.length;++s)s===i[n]?++n:e.push(t.fitPoints[s].clone());if(t.fitPoints=e.getPoint3dArray(),void 0!==t.knots){const e=[];for(let s=0,n=0;s<t.knots.length;++s)s===i[n]?++n:e.push(t.knots[s]);t.knots=e.slice()}return!0}static constructFitParametersFromPoints(t,e,i){let s;return!e&&i||(s=this.constructChordLengthParameters(t)),void 0===s&&(s=this.constructUniformParameters(t.length)),s}static constructFitParameters(t){return void 0===t.knots&&(t.knots=this.constructFitParametersFromPoints(t.fitPoints,t.isChordLenKnots,t.closed)),t.knots?.length===t.fitPoints.length}static computeAlphaBetaGamma(t,e,i,s,n,r,o,a){let c=1/(a+o+r);t[s]=r*r*c,e[s]=r*(a+o)*c,c=1/(o+r+n),e[s]+=o*(r+n)*c,i[s]=o*o*c,c=1/(o+r),t[s]*=c,e[s]*=c,i[s]*=c}static setUpSystem2Points(t,e,i){return 2===t.length&&2===e.length&&2===i.length&&(t[0]=t[1]=i[0]=i[1]=0,e[0]=e[1]=1,!0)}static setUpSystem3Points(t,e,i,s,n,r){if(void 0===s.knots)return!1;if(3!==t.length||3!==e.length||3!==i.length)return!1;if(3!==s.knots.length||3!==s.fitPoints.length)return!1;let o=0,a=0,c=0,l=0,h=0,d=0;return n?(t[0]=0,a=s.knots[1]-s.knots[0],o=s.knots[2]-s.knots[1],h=a+o,d=1/h,e[0]=(a+h)*d,i[0]=-a*d):(t[0]=i[0]=0,e[0]=1),c=s.knots[1]-s.knots[0],a=s.knots[2]-s.knots[1],d=1/(c+a),d*=d,t[1]=a*a*d,e[1]=a*c*2*d,i[1]=c*c*d,r?(c=s.knots[2]-s.knots[1],l=s.knots[1]-s.knots[0],h=l+c,d=1/h,t[2]=-c*d,e[2]=(c+h)*d,i[2]=0):(t[2]=i[2]=0,e[2]=1),!0}static setUpSystem4PointsOrMore(t,e,i,s,n,r){if(void 0===s.knots)return!1;if(t.length!==e.length||t.length!==i.length||t.length!==s.knots.length)return!1;if(s.knots.length!==s.fitPoints.length)return!1;const o=s.fitPoints.length-1,a=o-1;let c=0,l=0,h=0,d=0,u=0,f=0;s.closed?(l=s.knots[1]-s.knots[0],d=s.knots[a]-s.knots[a-1],h=s.knots[a+1]-s.knots[a],c=s.knots[2]-s.knots[1],this.computeAlphaBetaGamma(t,e,i,0,c,l,h,d),d=h,h=l,l=s.knots[2]-s.knots[1],c=s.knots[3]-s.knots[2],this.computeAlphaBetaGamma(t,e,i,1,c,l,h,d),c=h,l=s.knots[a+1]-s.knots[a],d=s.knots[a-1]-s.knots[a-2],h=s.knots[a]-s.knots[a-1],this.computeAlphaBetaGamma(t,e,i,a,c,l,h,d)):(n?(t[0]=0,l=s.knots[1]-s.knots[0],c=s.knots[2]-s.knots[1],u=l+c,f=1/u,e[0]=(l+u)*f,i[0]=-l*f):(t[0]=i[0]=0,e[0]=1),l=s.knots[2]-s.knots[1],h=s.knots[1]-s.knots[0],d=0,c=s.knots[3]-s.knots[2],this.computeAlphaBetaGamma(t,e,i,1,c,l,h,d),l=s.knots[a+1]-s.knots[a],h=s.knots[a]-s.knots[a-1],d=s.knots[a-1]-s.knots[a-2],c=0,this.computeAlphaBetaGamma(t,e,i,a,c,l,h,d),r?(h=s.knots[o]-s.knots[o-1],d=s.knots[o-1]-s.knots[o-2],u=d+h,f=1/u,t[o]=-h*f,e[o]=(h+u)*f,i[o]=0):(t[o]=i[o]=0,e[o]=1));for(let n=2;n<a;++n)l=s.knots[n+1]-s.knots[n],d=s.knots[n-1]-s.knots[n-2],h=s.knots[n]-s.knots[n-1],c=s.knots[n+2]-s.knots[n+1],this.computeAlphaBetaGamma(t,e,i,n,c,l,h,d);return!0}static setUpSystem(t,e,i,s){let n=!1,r=!1;s.isNaturalTangents&&!s.closed&&(n=void 0===s.startTangent,r=void 0===s.endTangent);let o=!1;return 2===s.fitPoints.length?o=this.setUpSystem2Points(t,e,i):3===s.fitPoints.length?o=this.setUpSystem3Points(t,e,i,s,n,r):4<=s.fitPoints.length&&(o=this.setUpSystem4PointsOrMore(t,e,i,s,n,r)),o}static setBesselEndCondition(t,e,i){if(t.length!==e.fitPoints.length+2)return!1;if(void 0===e.knots)return!1;const s=1/3,n=e.fitPoints.length-1;if(1===n)return i?t[0].interpolate(s,t[3],t[1]):t[3].interpolate(s,t[0],t[2]),!0;if(2===n){const n=(e.knots[2]-e.knots[1])/(e.knots[2]-e.knots[0]),r=1-n,o=t[2].plus2Scaled(t[0],-n*n,t[4],-r*r);return i?j.createAdd2Scaled(o,1/(2*n),t[0],n).interpolate(s,t[0],t[1]):j.createAdd2Scaled(o,1/(2*r),t[4],r).interpolate(s,t[4],t[3]),!0}if(i){const i=(e.knots[2]-e.knots[1])/(e.knots[2]-e.knots[0]),n=1-i,r=t[2].plus2Scaled(t[0],-i*i,t[3],-n*n);j.createAdd2Scaled(r,1/(2*i),t[0],i).interpolate(s,t[0],t[1])}else{const i=(e.knots[n]-e.knots[n-1])/(e.knots[n]-e.knots[n-2]),r=1-i,o=t[n].plus2Scaled(t[n-1],-i*i,t[n+2],-r*r);j.createAdd2Scaled(o,1/(2*r),t[n+2],r).interpolate(s,t[n+2],t[n+1])}return!0}static setNaturalEndCondition(t,e,i){return t.length===e.fitPoints.length+2&&(1==e.fitPoints.length-1?this.setBesselEndCondition(t,e,i):(i?t[1]=t[0]:t[t.length-2]=t[t.length-1],!0))}static setChordLengthScaledEndCondition(t,e,i){if(t.length!==e.fitPoints.length+2)return!1;const s=i?e.startTangent:e.endTangent;if(void 0===s)return!1;let n=0,r=0,o=0;const a=e.fitPoints.length-1;1===a?i?(n=0,r=1,o=3):(n=3,r=2,o=0):i?(n=0,r=1,o=2):(n=a+2,r=a+1,o=a);const c=t[o].distance(t[n]);return t[n].plusScaled(s,c/3,t[r]),!0}static setBesselLengthScaledEndCondition(t,e,i){if(t.length!==e.fitPoints.length+2)return!1;const s=i?e.startTangent:e.endTangent;if(void 0===s)return!1;if(!this.setBesselEndCondition(t,e,i))return!1;const n=e.fitPoints.length-1,r=i?0:n+2,o=i?1:n+1;return t[r].plusScaled(s,t[r].distance(t[o]),t[o]),!0}static setPhysicallyClosedEndCondition(t,e){const i=e.fitPoints.length-1;if(!e.isColinearTangents||i<=2||void 0!==e.startTangent&&void 0!==e.endTangent||e.isNaturalTangents||!t[0].isAlmostEqual(t[i+2]))return!0;if(void 0!==e.startTangent){const e=$.createStartEnd(t[1],t[0]).normalize();if(void 0!==e){const s=t[i+2].distance(t[i+1]);t[i+2].plusScaled(e,s,t[i+1])}}else if(void 0!==e.endTangent){const e=$.createStartEnd(t[i+1],t[i+2]).normalize();if(void 0!==e){const i=t[0].distance(t[1]);t[0].plusScaled(e,i,t[1])}}else{const e=$.createStartEnd(t[i+1],t[1]).normalize();if(void 0!==e){const s=t[0].distance(t[1]);t[0].plusScaled(e,s,t[1]);const n=t[i+2].distance(t[i+1]);t[i+2].plusScaled(e,-n,t[i+1])}}return!0}static setEndConditions(t,e){if(t.length!==e.fitPoints.length)return!1;const i=j.createZero(),s=j.createZero();t.splice(1,0,i),t.splice(t.length-1,0,s);let n=!1;return n=void 0===e.startTangent?e.isNaturalTangents?this.setNaturalEndCondition(t,e,!0):this.setBesselEndCondition(t,e,!0):e.isChordLenTangents?this.setChordLengthScaledEndCondition(t,e,!0):this.setBesselLengthScaledEndCondition(t,e,!0),n=void 0===e.endTangent?e.isNaturalTangents?this.setNaturalEndCondition(t,e,!1):this.setBesselEndCondition(t,e,!1):e.isChordLenTangents?this.setChordLengthScaledEndCondition(t,e,!1):this.setBesselLengthScaledEndCondition(t,e,!1),n&&(n=this.setPhysicallyClosedEndCondition(t,e)),n}static solveNearTridiagonal(t,e,i,s){if(e.length!==i.length||e.length!==s.length||e.length!==t.length)return;const n=[],r=t.length-1,o=t.slice(0,-1);let a=0;for(let t=1;t<r;++t){if(void 0===(a=Q.conditionalDivideFraction(-e[t],i[t-1])))return;i[t]+=a*s[t-1],e[t]=a*e[t-1],o[t].addScaledInPlace(o[t-1],a)}if(void 0!==(a=Q.conditionalDivideFraction(1,i[r-1]+e[r-1]))){s[r-1]*=a,o[r-1].scaleInPlace(a);for(let t=r-2;t>=0;--t){if(void 0===(a=Q.conditionalDivideFraction(1,i[t])))return;j.createScale(o[t].plus2Scaled(o[t+1],-s[t],o[r-1],-e[t]),a,o[t]),s[t]=-(s[t]*s[t+1]+e[t]*s[r-1])*a}if(void 0!==(a=Q.conditionalDivideFraction(1,1+s[0]))){n.push(j.createScale(o[0],a));for(let t=1;t<r;++t)n.push(o[t].plusScaled(n[0],-s[t]));return n}}}static validateOptions(t){if(t.order=4,t.knots=this.convertCubicKnotVectorToFitParams(t.knots,t.fitPoints.length,!0),!this.removeDuplicateFitPoints(t))return!1;let e=t.fitPoints[0].isAlmostEqual(t.fitPoints[t.fitPoints.length-1]);if(3===t.fitPoints.length&&e&&(t.fitPoints.pop(),void 0!==t.knots&&t.knots.pop(),e=t.fitPoints[0].isAlmostEqual(t.fitPoints[t.fitPoints.length-1])),t.fitPoints.length<=2){if(e)return!1;t.closed=!1}return t.closed&&(e||(t.fitPoints.push(t.fitPoints[0].clone()),void 0!==t.knots&&t.knots.push(t.knots[t.knots.length-1]+(t.knots[t.knots.length-1]-t.knots[0])/(t.knots.length-1))),t.fitPoints.length<=4&&(t.closed=!1)),!(t.fitPoints.length<2||(void 0!==t.startTangent&&(t.startTangent.isAlmostZero?t.startTangent=void 0:t.startTangent.normalizeInPlace()),void 0!==t.endTangent&&(t.endTangent.isAlmostZero?t.endTangent=void 0:t.endTangent.normalizeInPlace()),0))}static convertCubicKnotVectorToFitParams(t,e,i){let s=t?.slice();if(void 0!==s){const t=s.length-e;switch(t){case 0:break;case 4:case 6:for(let e=0;e<t/2;++e)s.pop(),s.shift();break;default:s=void 0}i&&!this.normalizeKnots(s)&&(s=void 0)}return s}static convertFitParamsToCubicKnotVector(t,e,i){const s=t?.slice();if(void 0!==s){const t=i?6:4;if(e){const e=s.length-2;for(let i=2;i<=t;i+=2)s.unshift(s[e]-1),s.push(1+s[i])}else for(let e=0;e<t/2;++e)s.unshift(0),s.push(1)}return s}static convertToJsonKnots(t){void 0!==t.knots?(t.knots=this.convertCubicKnotVectorToFitParams(t.knots,t.fitPoints.length,!1),t.knots=this.convertFitParamsToCubicKnotVector(t.knots,t.closed,!0)):(t.knots=this.constructFitParametersFromPoints(ue.clonePoint3dArray(t.fitPoints),t.isChordLenKnots,t.closed),t.knots=this.convertFitParamsToCubicKnotVector(t.knots,t.closed,!0))}static constructPoles(t){if(!this.constructFitParameters(t)||void 0===t.knots)return;const e=t.fitPoints.length,i=Array(e),s=Array(e),n=Array(e);if(!this.setUpSystem(i,s,n,t))return;let r=[];if(t.closed){if(void 0!==(r=this.solveNearTridiagonal(t.fitPoints,i,s,n))&&r.length>2){r.unshift(r.pop());for(let e=0;e<t.order-1;++e)r.push(r[e].clone())}}else{const o=t.fitPoints.slice();if(!this.setEndConditions(o,t))return;if(o.length!==e+2)return;const a=new Float64Array(3*e),c=new Float64Array(3*e);for(let t=0,r=0,l=0;t<e;++t)a[r++]=i[t],a[r++]=s[t],a[r++]=n[t],c[l++]=o[t+1].x,c[l++]=o[t+1].y,c[l++]=o[t+1].z;const l=fe.solveBandedSystemMultipleRHS(e,3,a,3,c);if(void 0===l)return;r=new Float64Array(3+l.length+3);let h=0;r[h++]=t.fitPoints[0].x,r[h++]=t.fitPoints[0].y,r[h++]=t.fitPoints[0].z;for(let t=0;t<l.length;)r[h++]=l[t++];r[h++]=t.fitPoints[t.fitPoints.length-1].x,r[h++]=t.fitPoints[t.fitPoints.length-1].y,r[h++]=t.fitPoints[t.fitPoints.length-1].z}return r}}}(pe||(pe={}));class me extends ae{dispatchToGeometryHandler(t){return this._proxyCurve.dispatchToGeometryHandler(t)}constructor(t){super(),this._proxyCurve=t}get proxyCurve(){return this._proxyCurve}computeStrokeCountForOptions(t){return this._proxyCurve.computeStrokeCountForOptions(t)}emitStrokableParts(t,e){this._proxyCurve.emitStrokableParts(t,e)}cloneTransformed(t){const e=this.clone();if(e.tryTransformInPlace(t))return e}clonePartialCurve(t,e){return this._proxyCurve.clonePartialCurve(t,e)}emitStrokes(t,e){this._proxyCurve.emitStrokes(t,e)}extendRange(t,e){this._proxyCurve.extendRange(t,e)}range(t,e){return this._proxyCurve.range(t,e)}fractionToPoint(t,e){return this._proxyCurve.fractionToPoint(t,e)}fractionToPointAndDerivative(t,e){return this._proxyCurve.fractionToPointAndDerivative(t,e)}fractionToPointAnd2Derivatives(t,e){return this._proxyCurve.fractionToPointAnd2Derivatives(t,e)}isInPlane(t){return this._proxyCurve.isInPlane(t)}quickLength(){return this._proxyCurve.quickLength()}constructOffsetXY(t){return this._proxyCurve.constructOffsetXY(t)}projectedParameterRange(t,e){return this._proxyCurve.projectedParameterRange(t,e)}}class xe{constructor(t,e){this._fitPoints=t||[],this._knots=e}get order(){return Q.resolveNumber(this._order,4)}set order(t){this._order=t}get closed(){return Q.resolveValue(this._closed,!1)}set closed(t){this._closed=t}get isChordLenKnots(){return Q.resolveNumber(this._isChordLenKnots,0)}set isChordLenKnots(t){this._isChordLenKnots=t}get isColinearTangents(){return Q.resolveNumber(this._isColinearTangents,0)}set isColinearTangents(t){this._isColinearTangents=t}get isChordLenTangents(){return Q.resolveNumber(this._isChordLenTangents,0)}set isChordLenTangents(t){this._isChordLenTangents=t}get isNaturalTangents(){return Q.resolveNumber(this._isNaturalTangents,0)}set isNaturalTangents(t){this._isNaturalTangents=t}get startTangent(){return this._startTangent}set startTangent(t){this._startTangent=t}get endTangent(){return this._endTangent}set endTangent(t){this._endTangent=t}get fitPoints(){return this._fitPoints}set fitPoints(t){this._fitPoints=t}get knots(){return this._knots}set knots(t){this._knots=t}captureOptionalProps(t,e,i,s,n,r,o,a){this._order=Q.resolveToUndefined(t,0),this._closed=Q.resolveToUndefined(e,!1),this._isChordLenKnots=Q.resolveToUndefined(i,0),this._isColinearTangents=Q.resolveToUndefined(s,0),this._isChordLenTangents=Q.resolveToUndefined(n,0),this._isNaturalTangents=Q.resolveToUndefined(r,0),this._startTangent=o,this._endTangent=a}cloneAsInterpolationCurve3dProps(){const t={fitPoints:ue.cloneDeepJSONNumberArrays(this.fitPoints),knots:this._knots?.slice()};return void 0!==this._order&&(t.order=this._order),void 0!==this._closed&&(t.closed=this._closed),void 0!==this._isChordLenKnots&&(t.isChordLenKnots=this._isChordLenKnots),void 0!==this._isColinearTangents&&(t.isColinearTangents=this._isColinearTangents),void 0!==this._isChordLenTangents&&(t.isChordLenTangents=this._isChordLenTangents),void 0!==this._isNaturalTangents&&(t.isNaturalTangents=this._isNaturalTangents),void 0!==this._startTangent&&(t.startTangent=this._startTangent?.toArray()),void 0!==this._endTangent&&(t.endTangent=this._endTangent?.toArray()),t}clone(){const t=new xe(ue.clonePoint3dArray(this.fitPoints),this.knots?.slice());return t._order=this.order,t._closed=this.closed,t._isChordLenKnots=this.isChordLenKnots,t._isColinearTangents=this.isColinearTangents,t._isChordLenTangents=this.isChordLenTangents,t._isNaturalTangents=this.isNaturalTangents,t._startTangent=this._startTangent?.clone(),t._endTangent=this._endTangent?.clone(),t}static create(t){const e=new xe(ue.clonePoint3dArray(t.fitPoints),t.knots?.slice());return e._order=t.order,e._closed=t.closed,e._isChordLenKnots=t.isChordLenKnots,e._isColinearTangents=t.isColinearTangents,e._isChordLenTangents=t.isChordLenTangents,e._isNaturalTangents=t.isNaturalTangents,e._startTangent=t.startTangent?$.fromJSON(t.startTangent):void 0,e._endTangent=t.endTangent?$.fromJSON(t.endTangent):void 0,e}static areAlmostEqualAllow000AsUndefined(t,e){return void 0!==t&&0===t.maxAbs()&&(t=void 0),void 0!==e&&0===e.maxAbs()&&(e=void 0),void 0!==t&&void 0!==e?t.isAlmostEqual(e):void 0===t&&void 0===e}static areAlmostEqual(t,e){if(void 0===t&&void 0===e)return!0;if(void 0!==t&&void 0!==e&&Q.areEqualAllowUndefined(t.order,e.order)&&Q.areEqualAllowUndefined(t.closed,e.closed)&&Q.areEqualAllowUndefined(t.isChordLenKnots,e.isChordLenKnots)&&Q.areEqualAllowUndefined(t.isColinearTangents,e.isColinearTangents)&&Q.areEqualAllowUndefined(t.isNaturalTangents,e.isNaturalTangents)&&this.areAlmostEqualAllow000AsUndefined(t.startTangent,e.startTangent)&&this.areAlmostEqualAllow000AsUndefined(t.endTangent,e.endTangent)&&Q.almostEqualArrays(t.fitPoints,e.fitPoints,((t,e)=>t.isAlmostEqual(e)))){if(Q.almostEqualNumberArrays(t.knots,e.knots,((t,e)=>t===e)))return!0;if(void 0===t.knots&&void 0===e.knots)return!0;let i=t.knots,s=e.knots;return void 0===t.knots?i=pe.C2CubicFit.constructFitParametersFromPoints(t.fitPoints,t.isChordLenKnots,t.closed):void 0===e.knots&&(s=pe.C2CubicFit.constructFitParametersFromPoints(e.fitPoints,e.isChordLenKnots,e.closed)),i=pe.C2CubicFit.convertCubicKnotVectorToFitParams(i,t.fitPoints.length,!1),s=pe.C2CubicFit.convertCubicKnotVectorToFitParams(s,e.fitPoints.length,!1),Q.almostEqualNumberArrays(i,s,((t,e)=>Q.isAlmostEqualNumber(t,e)))}return!1}reverseInPlace(){this.fitPoints.reverse(),this.knots&&this.knots.reverse();const t=this._startTangent;this._startTangent=this.endTangent,this._endTangent=t}}class _e extends me{constructor(t,e){super(e),this.curvePrimitiveType="interpolationCurve",this._options=t}dispatchToGeometryHandler(t){let e=t.handleInterpolationCurve3d(this);return void 0===e&&(e=this._proxyCurve.dispatchToGeometryHandler(t)),e}static create(t){let e;return e=t instanceof xe?t.clone():xe.create(t),_e.createCapture(e)}static createCapture(t){const e=Be.createFromInterpolationCurve3dOptions(t);if(e)return new _e(t,e)}copyFitPointsFloat64Array(){return ue.cloneXYZPropsAsFloat64Array(this._options.fitPoints)}toJSON(){return this._options.cloneAsInterpolationCurve3dProps()}cloneProps(){return this._options.cloneAsInterpolationCurve3dProps()}get options(){return this._options}reverseInPlace(){this._proxyCurve.reverseInPlace(),this._options.reverseInPlace()}tryTransformInPlace(t){const e=this._proxyCurve.tryTransformInPlace(t);return e&&(t.multiplyPoint3dArrayInPlace(this._options.fitPoints),this._options.startTangent&&t.multiplyVectorInPlace(this._options.startTangent),this._options.endTangent&&t.multiplyVectorInPlace(this._options.endTangent)),e}clone(){return new _e(this._options.clone(),this._proxyCurve.clone())}isAlmostEqual(t){return t instanceof _e&&xe.areAlmostEqual(this._options,t._options)}isSameGeometryClass(t){return t instanceof _e}}class ye{constructor(t,e){this._p0=j.createZero(),this._p1=j.createZero(),this._v0=$.createZero(),this._v1=$.createZero(),this._r0=bt.createZero(),this._offsetDistance=e,this._fitOptions=new xe;const i=t.fractionToPointAndUnitTangent(0,this._r0).direction.clone(),s=t.fractionToPointAndUnitTangent(1,this._r0).direction.negate();this._fitOptions.startTangent=i,this._fitOptions.endTangent=s,(this._fitOptions.closed=t.startPoint(this._p0).isAlmostEqual(t.endPoint(this._p1))&&i.isParallelTo(s,!0))&&(this._fitOptions.isChordLenKnots=1)}pushOffsetPoint(t,e){Q.isSmallMetricDistance(e.x)&&Q.isSmallMetricDistance(e.y)||this._fitOptions.fitPoints.push(t.plusScaled(e.unitPerpendicularXY(this._v0),this._offsetDistance))}needPrimaryGeometryForStrokes(){return!0}startParentCurvePrimitive(t){}startCurvePrimitive(t){}endCurvePrimitive(t){}endParentCurvePrimitive(t){}announceIntervalForUniformStepStrokes(t,e,i,s){for(let n=0;n<=e;++n){const r=Q.interpolate(i,n/e,s),o=t.fractionToPointAndDerivative(r,this._r0);this.pushOffsetPoint(o.origin,o.direction)}}announceSegmentInterval(t,e,i,s,n,r){if(s>0){const t=$.createStartEnd(e,i,this._v1);for(let n=0;n<=s;++n)this.pushOffsetPoint(e.interpolate(n/s,i,this._p0),t)}}announcePointTangent(t,e,i){this.pushOffsetPoint(t,i)}claimResult(){return pe.createThroughPointsC2Cubic(this._fitOptions)}}class ve{handleCurveCollection(t){}handlePath(t){return this.handleCurveCollection(t)}handleLoop(t){return this.handleCurveCollection(t)}handleParityRegion(t){return this.handleCurveCollection(t)}handleUnionRegion(t){return this.handleCurveCollection(t)}handleBagOfCurves(t){return this.handleCurveCollection(t)}handleCurveChainWithDistanceIndex(t){return this.handlePath(t.path)}}class Pe extends ve{handleLineSegment3d(t){}handleLineString3d(t){}handleArc3d(t){}handleCurveCollection(t){}handleCurveChainWithDistanceIndex(t){}handleBSplineCurve3d(t){}handleInterpolationCurve3d(t){}handleAkimaCurve3d(t){}handleBSplineCurve3dH(t){}handleBSplineSurface3d(t){}handleCoordinateXYZ(t){}handleBSplineSurface3dH(t){}handleIndexedPolyface(t){}handleTransitionSpiral(t){}handlePath(t){}handleLoop(t){}handleParityRegion(t){}handleUnionRegion(t){}handleBagOfCurves(t){}handleSphere(t){}handleCone(t){}handleBox(t){}handleTorusPipe(t){}handleLinearSweep(t){}handleRotationalSweep(t){}handleRuledSweep(t){}handlePointString3d(t){}handleBezierCurve3d(t){}handleBezierCurve3dH(t){}}class Ae extends ve{handleLineSegment3d(t){}handleLineString3d(t){}handleArc3d(t){}handleBSplineCurve3d(t){}handleInterpolationCurve3d(t){}handleAkimaCurve3d(t){}handleBSplineCurve3dH(t){}handleBSplineSurface3d(t){}handleCoordinateXYZ(t){}handleBSplineSurface3dH(t){}handleIndexedPolyface(t){}handleTransitionSpiral(t){}handleChildren(t){const e=t.children;if(e)for(const t of e)t.dispatchToGeometryHandler(this)}handleCurveCollection(t){return this.handleChildren(t)}handleSphere(t){}handleCone(t){}handleBox(t){}handleTorusPipe(t){}handleLinearSweep(t){}handleRotationalSweep(t){}handleRuledSweep(t){}handlePointString3d(t){}handleBezierCurve3d(t){}handleBezierCurve3dH(t){}}class Ie{constructor(){this.shouldTriangulate=!1,this.defaultCircleStrokes=16}get needParams(){return void 0!==this._needParams&&this._needParams}set needParams(t){this._needParams=t}get needNormals(){return void 0!==this._needNormals&&this._needNormals}set needNormals(t){this._needNormals=t}get needTwoSided(){return void 0!==this._needTwoSided&&this._needTwoSided}set needTwoSided(t){this._needTwoSided=t}get hasAngleTol(){return void 0!==this.angleTol&&Math.abs(this.angleTol.radians)>0}get hasChordTol(){return void 0!==this.chordTol&&this.chordTol>0}get hasMaxEdgeLength(){return void 0!==this.maxEdgeLength&&this.maxEdgeLength>0}get maximizeConvexFacets(){return this._maximizeConvexFacets??!1}set maximizeConvexFacets(t){this._maximizeConvexFacets=t,t&&(this.shouldTriangulate=t)}clone(){const t=new Ie;return t.chordTol=this.chordTol,t.angleTol=this.angleTol?.clone(),t.maxEdgeLength=this.maxEdgeLength,t.minStrokesPerPrimitive=this.minStrokesPerPrimitive,t.shouldTriangulate=this.shouldTriangulate,t._needNormals=this._needNormals,t._needTwoSided=this._needTwoSided,t._needParams=this._needParams,t.needColors=this.needColors,t.defaultCircleStrokes=this.defaultCircleStrokes,t._maximizeConvexFacets=this._maximizeConvexFacets,t}applyMaxEdgeLength(t,e){return e=Math.abs(e),this.maxEdgeLength&&this.maxEdgeLength>0&&t*this.maxEdgeLength<e&&(t=Q.stepCount(this.maxEdgeLength,e,t)),t}applyAngleTol(t,e,i){return Ie.applyAngleTol(this,t,e,i)}static applyAngleTol(t,e,i,s){i=Math.abs(i);let n=s||Math.PI/8;return t&&t.angleTol&&t.angleTol.radians>0&&(n=t.angleTol.radians),e*n<i&&(e=Q.stepCount(n,i,e)),e}static applyMaxEdgeLength(t,e,i){return i<0&&(i=-i),e<1&&(e=1),t&&t.maxEdgeLength&&t.maxEdgeLength*e<i&&(e=Q.stepCount(t.maxEdgeLength,i,e)),e}applyTolerancesToArc(t,e=2*Math.PI){let i=1;return i=this.applyAngleTol(i,e,.25*Math.PI),i=this.applyMaxEdgeLength(i,e*t),i=this.applyChordTol(i,t,e),i=this.applyMinStrokesPerPrimitive(i),i}applyChordTol(t,e,i){if(this.chordTol&&this.chordTol>0&&this.chordTol<e){const s=this.chordTol,n=2*Math.acos(1-s/e);t=Q.stepCount(n,i,t)}return t}applyChordTolToLengthAndRadians(t,e,i){if(this.chordTol&&this.chordTol>0){const s=Q.conditionalDivideFraction(e,i);if(void 0!==s)return this.applyChordTol(t,s,i)}return t}applyMinStrokesPerPrimitive(t){return void 0!==this.minStrokesPerPrimitive&&Number.isFinite(this.minStrokesPerPrimitive)&&this.minStrokesPerPrimitive>t&&(t=this.minStrokesPerPrimitive),t}static createForCurves(){const t=new Ie;return t.angleTol=W.createDegrees(15),t}static createForFacets(){const t=new Ie;return t.angleTol=W.createDegrees(22.5),t}}class Se{constructor(t,e=180,i=91,s=!1,n=!1){this.minArcDegrees=180,this.maxChamferTurnDegrees=91,this.allowSharpestCorners=!1,this.leftOffsetDistance=0,this.preserveEllipticalArcs=!1,this.leftOffsetDistance=t,this.minArcDegrees=e,this.maxChamferTurnDegrees=i,this.preserveEllipticalArcs=s,this.allowSharpestCorners=n}clone(){return new Se(this.leftOffsetDistance,this.minArcDegrees,this.maxChamferTurnDegrees,this.preserveEllipticalArcs,this.allowSharpestCorners)}setFrom(t){this.leftOffsetDistance=t.leftOffsetDistance,this.minArcDegrees=t.minArcDegrees,this.maxChamferTurnDegrees=t.maxChamferTurnDegrees,this.preserveEllipticalArcs=t.preserveEllipticalArcs,this.allowSharpestCorners=t.allowSharpestCorners}static create(t){return t instanceof Se?t:new Se(t)}needArc(t){return Math.abs(t.degrees)>=this.minArcDegrees-Q.smallAngleDegrees}numChamferPoints(t){const e=Math.abs(t.degrees);let i=120;this.allowSharpestCorners&&(i=this.maxChamferTurnDegrees);const s=Q.clamp(this.maxChamferTurnDegrees,10,i);return e<=s+Q.smallAngleDegrees?1:Math.ceil(e/s)}}class we{constructor(t,e){this.jointOptions=Se.create(t),this.strokeOptions=void 0!==e?e:Ie.createForCurves()}get minArcDegrees(){return this.jointOptions.minArcDegrees}set minArcDegrees(t){this.jointOptions.minArcDegrees=t}get maxChamferTurnDegrees(){return this.jointOptions.maxChamferTurnDegrees}set maxChamferTurnDegrees(t){this.jointOptions.maxChamferTurnDegrees=t}get allowSharpestCorners(){return this.jointOptions.allowSharpestCorners}set allowSharpestCorners(t){this.jointOptions.allowSharpestCorners=t}get leftOffsetDistance(){return this.jointOptions.leftOffsetDistance}set leftOffsetDistance(t){this.jointOptions.leftOffsetDistance=t}get preserveEllipticalArcs(){return this.jointOptions.preserveEllipticalArcs}set preserveEllipticalArcs(t){this.jointOptions.preserveEllipticalArcs=t}static create(t){return t instanceof we?t:new we(t)}static getOffsetDistance(t){return"number"==typeof t?t:t.leftOffsetDistance}clone(){return new we(this.jointOptions.clone(),this.strokeOptions.clone())}}class Ce extends ae{isSameGeometryClass(t){return t instanceof Ce}get point0Ref(){return this._point0}get point1Ref(){return this._point1}get isExtensibleFractionSpace(){return!0}constructor(t,e){super(),this.curvePrimitiveType="lineSegment",this._point0=t,this._point1=e}setRefs(t,e){this._point0=t,this._point1=e}set(t,e){this._point0=t.clone(),this._point1=e.clone()}setFrom(t){this._point0.setFrom(t._point0),this._point1.setFrom(t._point1)}startPoint(t){return t?(t.setFrom(this._point0),t):this._point0.clone()}endPoint(t){return t?(t.setFrom(this._point1),t):this._point1.clone()}fractionToPointAndDerivative(t,e){return(e=e||bt.createZero()).direction.setStartEnd(this._point0,this._point1),this._point0.interpolate(t,this._point1,e.origin),e}fractionToPointAnd2Derivatives(t,e){return(e=e||Et.createXYPlane()).vectorU.setStartEnd(this._point0,this._point1),e.vectorV.set(0,0,0),this._point0.interpolate(t,this._point1,e.origin),e}clone(){return Ce.create(this._point0,this._point1)}cloneTransformed(t){const e=this.clone();return e.tryTransformInPlace(t),e}static create(t,e,i){return i?(i.set(t,e),i):new Ce(t.clone(),e.clone())}static createCapture(t,e){return new Ce(t,e)}static createXYXY(t,e,i,s,n=0,r){return r?(r._point0.set(t,e,n),r._point1.set(i,s,n),r):new Ce(j.create(t,e,n),j.create(i,s,n))}static createXYZXYZ(t,e,i,s,n,r,o){return o?(o._point0.set(t,e,i),o._point1.set(s,n,r),o):new Ce(j.create(t,e,i),j.create(s,n,r))}fractionToPoint(t,e){return this._point0.interpolate(t,this._point1,e)}curveLength(){return this._point0.distance(this._point1)}curveLengthBetweenFractions(t,e){return Math.abs(e-t)*this._point0.distance(this._point1)}quickLength(){return this.curveLength()}closestPoint(t,e,i){let s=t.fractionOfProjectionToLine(this._point0,this._point1,0);return s=ie.correctFraction(e,s),(i=vt.create(this,i)).fraction=s,this._point0.interpolate(s,this._point1,i.point),i.vectorInCurveLocationDetail=void 0,i.a=i.point.distance(t),i}static closestApproach(t,i,s,n,r){const o=J.create();if(void 0===r&&(r=Pt.createCapture(vt.create(),vt.create())),Mt.lineSegment3dClosestApproachUnbounded(t._point0,t._point1,s._point0,s._point1,o)){const e=ie.correctFraction(i,o.x),a=ie.correctFraction(n,o.y);if(e===o.x&&a===o.y)return vt.createCurveEvaluatedFraction(t,e,r.detailA),vt.createCurveEvaluatedFraction(s,a,r.detailB),r.detailA.a=r.detailB.a=r.detailA.point.distance(r.detailB.point),r;if(e!==o.x&&a!==o.y){const o=e<.5?t._point0:t._point1,c=a<.5?s._point0:s._point1;s.closestPoint(o,n,r.detailB),t.closestPoint(c,i,r.detailA),r.detailA.a<=r.detailB.a?vt.createCurveFractionPoint(s,a,c,r.detailB):vt.createCurveFractionPoint(t,e,o,r.detailA)}else if(a!==o.y){const e=a<.5?s._point0:s._point1;t.closestPoint(e,i,r.detailA),r.detailB.setCurve(s),r.detailB.point.setFrom(e),r.detailB.fraction=a}else{const i=e<.5?t._point0:t._point1;s.closestPoint(i,n,r.detailB),r.detailA.setCurve(t),r.detailA.point.setFrom(i),r.detailA.fraction=e}return r.detailA.a=r.detailB.a=r.detailA.point.distance(r.detailB.point),r}const a=[t.closestPoint(s._point0,i),t.closestPoint(s._point1,i),s.closestPoint(t._point0,n),s.closestPoint(t._point1,n)];let c=a[0].a,l=0;for(let t=1;t<4;t++)a[t].a<c&&(l=t,c=a[t].a);return 0===l?(a[0].clone(r.detailA),vt.createCurveEvaluatedFraction(s,0,r.detailB),r.detailB.a=r.detailA.a):1===l?(a[1].clone(r.detailA),vt.createCurveEvaluatedFraction(s,1,r.detailB),r.detailB.a=r.detailA.a):2===l?(a[2].clone(r.detailB),vt.createCurveEvaluatedFraction(t,0,r.detailA),r.detailA.a=r.detailB.a):(e(3===l),a[3].clone(r.detailB),vt.createCurveEvaluatedFraction(t,1,r.detailA),r.detailA.a=r.detailB.a),r}reverseInPlace(){const t=this._point0;this._point0=this._point1,this._point1=t}tryTransformInPlace(t){return this._point0=t.multiplyPoint3d(this._point0,this._point0),this._point1=t.multiplyPoint3d(this._point1,this._point1),!0}isInPlane(t){return Q.isSmallMetricDistance(t.altitude(this._point0))&&Q.isSmallMetricDistance(t.altitude(this._point1))}appendPlaneIntersectionPoints(t,e){const i=t.altitude(this._point0),s=t.altitude(this._point1),n=Ut.solveCoffs(i,s);let r=0;if(void 0!==n){r++;const t=vt.createCurveFractionPoint(this,n,this.fractionToPoint(n));t.intervalRole=P.isolated,e.push(t)}return r}extendRange(t,e){e?(t.extendTransformedPoint(e,this._point0),t.extendTransformedPoint(e,this._point1)):(t.extendPoint(this._point0),t.extendPoint(this._point1))}setFromJSON(t){if(!t)return this._point0.set(0,0,0),void this._point1.set(1,0,0);t.startPoint&&t.endPoint?(this._point0.setFromJSON(t.startPoint),this._point1.setFromJSON(t.endPoint)):Array.isArray(t)&&t.length>1&&(this._point0.setFromJSON(t[0]),this._point1.setFromJSON(t[1]))}getFractionToDistanceScale(){return this.curveLength()}toJSON(){return[this._point0.toJSON(),this._point1.toJSON()]}static fromJSON(t){const e=new Ce(j.createZero(),j.create());return e.setFromJSON(t),e}isAlmostEqual(t){if(t instanceof Ce){const e=t;return this._point0.isAlmostEqual(e._point0)&&this._point1.isAlmostEqual(e._point1)}return!1}emitStrokes(t,e){const i=this.computeStrokeCountForOptions(e);t.appendFractionalStrokePoints(this,i,0,1)}emitStrokableParts(t,e){t.startCurvePrimitive(this);const i=this.computeStrokeCountForOptions(e);t.announceSegmentInterval(this,this._point0,this._point1,i,0,1),t.endCurvePrimitive(this)}computeStrokeCountForOptions(t){let e=1;return t&&(t.maxEdgeLength&&(e=t.applyMaxEdgeLength(e,this.curveLength())),e=t.applyMinStrokesPerPrimitive(e)),e}dispatchToGeometryHandler(t){return t.handleLineSegment3d(this)}announceClipIntervals(t,e){return t.announceClippedSegmentIntervals(0,1,this._point0,this._point1,e?(t,i)=>e(t,i,this):void 0)}clonePartialCurve(t,e){return Ce.create(this.fractionToPoint(t),this.fractionToPoint(e))}rangeBetweenFractions(t,e,i){if(!i){const i=ut.create();return i.extendInterpolated(this._point0,t,this._point1),i.extendInterpolated(this._point0,e,this._point1),i}const s=this.fractionToPoint(t),n=this.fractionToPoint(e);return i&&(i.multiplyPoint3d(s,s),i.multiplyPoint3d(n,n)),ut.create(s,n)}constructOffsetXY(t){const e=$.createStartEnd(this._point0,this._point1);if(e.normalizeInPlace()){e.rotate90CCWXY(e);const i=we.getOffsetDistance(t);return Ce.create(this._point0.plusScaled(e,i),this._point1.plusScaled(e,i))}}projectedParameterRange(t,e){return Ee.findExtremeFractionsAlongDirection(this,t,e)}}class Te{getXAtUncheckedPointIndex(t){const e=this.getPoint2dAtCheckedPointIndex(t,Te._workPoint);return void 0===Te._workPoint&&(Te._workPoint=e),e?e.x:0}getYAtUncheckedPointIndex(t){const e=this.getPoint2dAtCheckedPointIndex(t,Te._workPoint);return void 0===Te._workPoint&&(Te._workPoint=e),e?e.y:0}linearCombination(t,e){const i=Math.min(this.length,t.length),s=e instanceof J?J.createZero(e):H.createZero(e);for(let e=0;e<i;++e)s.x+=t[e]*this.getXAtUncheckedPointIndex(e),s.y+=t[e]*this.getYAtUncheckedPointIndex(e);return s}}class Fe extends Te{constructor(t=8,e){super(),this._data=new Float64Array(2*t),this._xyInUse=0,this._xyCapacity=t,this._growthFactor=void 0!==e&&e>=1?e:1.5}copyData(t,e,i){let s=void 0!==i?2*i:0;if(s<0&&(s=0),s>=this._data.length)return{count:0,offset:0};let n=void 0!==e?2*e:t.length;return n>0&&(n>t.length&&(n=t.length),s+n>this._data.length&&(n=this._data.length-s),n%2!=0&&(n-=n%2)),n<=0?{count:0,offset:0}:(n===t.length?this._data.set(t,s):t instanceof Float64Array?this._data.set(t.subarray(0,n),s):this._data.set(t.slice(0,n),s),{count:n/2,offset:s/2})}get length(){return this._xyInUse}set length(t){this.resize(t,!0)}get float64Length(){return 2*this._xyInUse}float64Data(){return this._data}ensureCapacity(t,e=!0){if(t>this._xyCapacity){e&&(t*=this._growthFactor);const i=this._data;this._data=new Float64Array(2*t),this.copyData(i,this._xyInUse),this._xyCapacity=t}}resize(t,e){t>=0&&t<this._xyInUse?this._xyInUse=t:t>this._xyInUse&&(this.ensureCapacity(t,!1),e&&this._data.fill(0,2*this._xyInUse),this._xyInUse=t)}clone(){const t=new Fe(this.length);return t.copyData(this._data,this.length),t._xyInUse=this.length,t}static create(t,e){if(e)e.clear();else{const i="number"==typeof t[0]?t.length/2:t.length;e=new Fe(i)}return e.pushFrom(t),e}static createArrayOfGrowableXYZArray(t){return nt.createArrayOfGrowableXYZArray(t)}push(t){this.pushXY(t.x,t.y)}pushAll(t){this.ensureCapacity(this._xyInUse+t.length,!1);for(const e of t)this.push(e)}pushAllXYAndZ(t){if(this.ensureCapacity(this._xyInUse+t.length,!1),t instanceof nt){const e=t.float64Data(),i=3*t.length;for(let t=0;t+2<i;t+=3)this.pushXY(e[t],e[t+1])}else for(const e of t)this.pushXY(e.x,e.y)}pushFrom(t){if(t instanceof j)this.pushXY(t.x,t.y);else if(t instanceof nt)this.pushAllXYAndZ(t);else if(t instanceof H)this.pushXY(t.x,t.y);else if(Q.isNumberArray(t,3)||t instanceof Float64Array){const e=Math.trunc(t.length/2);this.ensureCapacity(this._xyInUse+e,!1),this.copyData(t,e,this._xyInUse),this._xyInUse+=e}else if(Q.isNumberArray(t,2))this.pushXY(t[0],t[1]);else if(Array.isArray(t))for(const e of t)this.pushFrom(e);else if(j.isXAndY(t))this.pushXY(t.x,t.y);else if(t instanceof Te){const e=t.length;this.ensureCapacity(this._xyInUse+e,!1);for(let i=0;i<e;i++)this.pushXY(t.getXAtUncheckedPointIndex(i),t.getYAtUncheckedPointIndex(i))}}pushWrap(t){if(this._xyInUse>=t){this.ensureCapacity(this._xyInUse+t,!1);for(let e=0;e<t;e++){const t=2*e;this.pushXY(this._data[t],this._data[t+1])}}}pushXY(t,e){this.ensureCapacity(this._xyInUse+1);const i=2*this._xyInUse;this._data[i]=t,this._data[i+1]=e,this._xyInUse++}pop(){this._xyInUse>0&&this._xyInUse--}isIndexValid(t){return!(t>=this._xyInUse||t<0)}clear(){this._xyInUse=0}getPoint2dAtUncheckedPointIndex(t,e){const i=2*t;return H.create(this._data[i],this._data[i+1],e)}getXAtUncheckedPointIndex(t){return this._data[2*t]}getYAtUncheckedPointIndex(t){return this._data[2*t+1]}getPoint2dArray(){const t=2*this._xyInUse,e=[],i=this._data;for(let s=0;s<t;s+=2)e.push(H.create(i[s],i[s+1]));return e}getPoint2dAtCheckedPointIndex(t,e){if(this.isIndexValid(t)){const i=2*t;return H.create(this._data[i],this._data[i+1],e)}}getVector2dAtCheckedVectorIndex(t,e){if(this.isIndexValid(t)){const i=2*t;return J.create(this._data[i],this._data[i+1],e)}}transferFromGrowableXYArray(t,e,i){if(this.isIndexValid(t)&&e.isIndexValid(i)){const s=2*t,n=2*i;return this._data[s]=e._data[n],this._data[s+1]=e._data[n+1],!0}return!1}pushFromGrowableXYArray(t,e){if(void 0===e){const e=t.length;return this.ensureCapacity(this.length+e,!1),this.copyData(t._data,e,this.length),this._xyInUse+=e,e}if(t.isIndexValid(e)){const i=2*e;return this.pushXY(t._data[i],t._data[i+1]),1}return 0}pushInterpolatedFromGrowableXYArray(t,e,i,s){if(t.isIndexValid(e)&&t.isIndexValid(s)){const n=1-i,r=t._data;e*=2,s*=2,this.pushXY(n*r[e]+i*r[s],n*r[e+1]+i*r[s+1])}}static createFromGrowableXYZArray(t,e,i){const s=t.length;if(i?(i.ensureCapacity(s,!1),i.clear()):i=new Fe(s),e){const n=t.float64Data(),r=3*s;let o,a,c;for(let t=0;t<r;t+=3)o=n[t],a=n[t+1],c=n[t+2],i.pushXY(e.multiplyComponentXYZ(0,o,a,c),e.multiplyComponentXYZ(1,o,a,c))}else i.pushAllXYAndZ(t);return i}front(t){if(0!==this._xyInUse)return this.getPoint2dAtUncheckedPointIndex(0,t)}back(t){if(!(this._xyInUse<1))return this.getPoint2dAtUncheckedPointIndex(this._xyInUse-1,t)}setAtCheckedPointIndex(t,e){if(!this.isIndexValid(t))return!1;const i=2*t;return this._data[i]=e.x,this._data[i+1]=e.y,!0}setXYAtCheckedPointIndex(t,e,i){if(!this.isIndexValid(t))return!1;const s=2*t;return this._data[s]=e,this._data[s+1]=i,!0}setXYZAtCheckedPointIndex(t,e,i){return this.setXYAtCheckedPointIndex(t,e,i)}getPoint3dArray(t=0){const e=2*this._xyInUse,i=[],s=this._data;for(let n=0;n<e;n+=2)i.push(j.create(s[n],s[n+1],t));return i}reverseInPlace(){const t=this.length;let e,i,s;const n=this._data;for(let r=0,o=t-1;r<o;r++,o--)e=2*r,i=2*o,s=n[e],n[e]=n[i],n[i]=s,e++,i++,s=n[e],n[e]=n[i],n[i]=s}multiplyTransformInPlace(t){const e=this._data,i=this.float64Length,s=t.matrix.coffs,n=t.origin,r=n.x,o=n.y;let a=0,c=0;for(let t=0;t+1<i;t+=2)a=e[t],c=e[t+1],e[t]=s[0]*a+s[1]*c+r,e[t+1]=s[3]*a+s[4]*c+o}multiplyMatrix3dInPlace(t){const e=this._data,i=this.float64Length,s=t.coffs;let n=0,r=0;for(let t=0;t+1<i;t+=2)n=e[t],r=e[t+1],e[t]=s[0]*n+s[1]*r,e[t+1]=s[3]*n+s[4]*r}tryTransformInverseInPlace(t){const e=this._data,i=this.float64Length,s=t.matrix;s.computeCachedInverse(!0);const n=s.inverseCoffs;if(!n)return!1;const r=t.origin,o=r.x,a=r.y;let c=0,l=0;for(let t=0;t+1<i;t+=2)c=e[t]-o,l=e[t+1]-a,e[t]=n[0]*c+n[1]*l,e[t+1]=n[3]*c+n[4]*l;return!0}extendRange(t,e){const i=this.float64Length,s=this._data;if(e)for(let n=0;n+1<i;n+=2)t.extendTransformedXY(e,s[n],s[n+1]);else for(let e=0;e+1<i;e+=2)t.extendXY(s[e],s[e+1])}sumLengths(){let t=0;const e=2*(this._xyInUse-1),i=this._data;for(let s=0;s<e;s+=2)t+=Q.hypotenuseXY(i[s+2]-i[s],i[s+3]-i[s+1]);return t}scaleInPlace(t){if(this._data){const e=this.float64Length;for(let i=0;i<e;i++)this._data[i]=this._data[i]*t}}interpolate(t,e,i,s){if(this.isIndexValid(t)&&this.isIndexValid(i)){const n=1-e,r=this._data;return t*=2,i*=2,H.create(n*r[t]+e*r[i],n*r[t+1]+e*r[i+1],s)}}areaXY(){let t=0;const e=2*this._xyInUse;if(e>4){const i=this._data[e-2],s=this._data[e-1];let n=this._data[0]-i,r=this._data[1]-s,o=0,a=0;for(let c=2;c<e;c+=2,n=o,r=a)o=this._data[c]-i,a=this._data[c+1]-s,t+=Q.crossProductXYXY(n,r,o,a)}return.5*t}vectorIndexIndex(t,e,i){if(!this.isIndexValid(t)||!this.isIndexValid(e))return;const s=this._data;return t*=2,e*=2,J.create(s[e]-s[t],s[e+1]-s[t+1],i)}vectorXAndYIndex(t,e,i){if(this.isIndexValid(e)){const s=this._data;return e*=2,J.create(s[e]-t.x,s[e+1]-t.y,i)}}crossProductIndexIndexIndex(t,e,i){if(this.isIndexValid(t)&&this.isIndexValid(e)&&this.isIndexValid(i)){const s=2*t,n=2*e,r=2*i,o=this._data;return Q.crossProductXYXY(o[n]-o[s],o[n+1]-o[s+1],o[r]-o[s],o[r+1]-o[s+1])}}crossProductXAndYIndexIndex(t,e,i){if(this.isIndexValid(e)&&this.isIndexValid(i)){const s=2*e,n=2*i,r=this._data;return Q.crossProductXYXY(r[s]-t.x,r[s+1]-t.y,r[n]-t.x,r[n+1]-t.y)}}distance(t,e){if(this.isIndexValid(t)&&this.isIndexValid(e)){const i=2*t,s=2*e;return Q.hypotenuseXY(this._data[s]-this._data[i],this._data[s+1]-this._data[i+1])}}distanceIndexToPoint(t,e){if(this.isIndexValid(t)){const i=2*t;return Q.hypotenuseXY(e.x-this._data[i],e.y-this._data[i+1])}}static isAlmostEqual(t,e){if(t&&e){if(t.length!==e.length)return!1;for(let i=0;i<t.length;i++)if(!t.getPoint2dAtUncheckedPointIndex(i).isAlmostEqual(e.getPoint2dAtUncheckedPointIndex(i)))return!1;return!0}return!t&&!e}sortIndicesLexical(){const t=this._xyInUse,e=new Uint32Array(t);for(let i=0;i<t;i++)e[i]=i;return e.sort(((t,e)=>this.compareLexicalBlock(t,e))),e}compareLexicalBlock(t,e){let i=0,s=0;for(let n=0;n<2;n++){if(i=this._data[2*t+n],s=this._data[2*e+n],i>s)return 1;if(i<s)return-1}return t-e}component(t,e){return this._data[2*t+e]}isAlmostEqual(t,e=Q.smallMetricDistance){const i=this._xyInUse;if(t._xyInUse!==i)return!1;const s=this._data,n=t._data;for(let t=0;t<2*i;t++)if(Math.abs(s[t]-n[t])>e)return!1;return!0}}function ke(t,e,i,s,n,r,o){const a=t.length;if(s>0){for(let s=i;s+1<a;s++)if(t.vectorIndexIndex(s,s+1,o),e.crossProduct(o,o),o.normalizeInPlace())return r.addScaledInPlace(o,n),r.isAlmostEqualXYZ(0,0,0,Q.smallFraction)&&o.scale(-n,r),!0}else{i+1>=a&&(i=a-2);for(let s=i;s>=0;s--)if(t.vectorIndexIndex(s,s+1,o),o.crossProduct(e,o),o.normalizeInPlace())return r.addScaledInPlace(o,n),r.isAlmostEqualXYZ(0,0,0,Q.smallFraction)&&o.scale(-n,r),!0}return!1}class Me extends ae{isSameGeometryClass(t){return t instanceof Me}get isExtensibleFractionSpace(){return!0}get points(){return this._points.getPoint3dArray()}get packedPoints(){return this._points}get fractions(){return this._fractions}get packedDerivatives(){return this._derivatives}get packedUVParams(){return this._uvParams}get packedSurfaceNormals(){return this._surfaceNormals}get normalIndices(){return this._normalIndices}get paramIndices(){return this._uvIndices}get pointIndices(){return this._pointIndices}constructor(t){super(),this.curvePrimitiveType="lineString",this._points=t||new nt}cloneTransformed(t){const e=this.clone();return e.tryTransformInPlace(t),e}static create(...t){const e=new Me;return e.addPoints(t),e}static createCapture(t){return new Me(t)}static createXY(t,e,i=!1){const s=new Me,n=s._points;for(const i of t)n.pushXYZ(i.x,i.y,e);if(i&&t.length>1){const t=n.distanceIndexIndex(0,n.length-1);if(void 0!==t&&0!==t&&Q.isSameCoordinate(0,t)){n.pop();const t=n.front();n.push(t)}}return s}addPoints(...t){this._points.pushFrom(t)}addSteppedPoints(t,e,i,s){this._points.addSteppedPoints(t,e,i,s)}addPoint(t){this._points.push(t)}addPointXYZ(t,e,i=0){this._points.pushXYZ(t,e,i)}addFraction(t){this._fractions||(this._fractions=new It),this._fractions.push(t)}ensureEmptyFractions(){const t=this.numPoints();return this._fractions?(this._fractions.clear(),this._fractions.ensureCapacity(t),this._fractions):(this._fractions=new It(t),this._fractions)}ensureEmptyUVParams(){const t=this.numPoints();return this._uvParams?(this._uvParams.clear(),this._uvParams.ensureCapacity(t),this._uvParams):(this._uvParams=new Fe(t),this._uvParams)}ensureEmptySurfaceNormals(){const t=this.numPoints();return this._surfaceNormals?(this._surfaceNormals.clear(),this._surfaceNormals.ensureCapacity(t),this._surfaceNormals):(this._surfaceNormals=new nt(t),this._surfaceNormals)}ensureEmptyDerivatives(){const t=this.numPoints();return this._derivatives?(this._derivatives.clear(),this._derivatives.ensureCapacity(t),this._derivatives):(this._derivatives=new nt(t),this._derivatives)}ensureEmptyNormalIndices(){const t=this.numPoints();return this._normalIndices?(this._normalIndices.clear(),this._normalIndices.ensureCapacity(t),this._normalIndices):(this._normalIndices=new It(t),this._normalIndices)}ensureEmptyUVIndices(){const t=this.numPoints();return this._uvIndices?(this._uvIndices.clear(),this._uvIndices.ensureCapacity(t),this._uvIndices):(this._uvIndices=new It(t),this._uvIndices)}ensureEmptyPointIndices(){const t=this.numPoints();return this._pointIndices?(this._pointIndices.clear(),this._pointIndices.ensureCapacity(t),this._pointIndices):(this._pointIndices=new It(t),this._pointIndices)}addUVParam(t){this._uvParams||(this._uvParams=new Fe),this._uvParams.pushXY(t.x,t.y)}addUVParamAsUV(t,e){this._uvParams||(this._uvParams=new Fe),this._uvParams.pushXY(t,e)}addDerivative(t){this._derivatives||(this._derivatives=new nt),this._derivatives.push(t)}addSurfaceNormal(t){this._surfaceNormals||(this._surfaceNormals=new nt),this._surfaceNormals.push(t)}addClosurePoint(){const t=this._points.distanceIndexIndex(0,this._points.length-1);void 0===t||Q.isSameCoordinate(t,0)||this._points.pushWrap(1)}popPoint(){this._points.pop()}computeUVFromXYZTransform(t){this._uvParams=Fe.createFromGrowableXYZArray(this._points,t)}static createRectangleXY(t,e,i,s=!0){const n=Me.create(),r=t.x,o=t.x+e,a=t.y,c=t.y+i,l=t.z;return n.addPointXYZ(r,a,l),n.addPointXYZ(o,a,l),n.addPointXYZ(o,c,l),n.addPointXYZ(r,c,l),s&&n.addClosurePoint(),n}static createRegularPolygonXY(t,e,i,s=!0){e<3&&(e=3);const n=Me.create(),r=s?0:-1,o=Math.PI/e;let a,c,l;s||(i/=Math.cos(o));for(let s=0;s<e;s++)l=(r+2*s)*o,a=W.cleanupTrigValue(Math.cos(l)),c=W.cleanupTrigValue(Math.sin(l)),n.addPointXYZ(t.x+i*a,t.y+i*c,t.z);return n.addClosurePoint(),n}setFrom(t){this._points=t._points.clone(this._points),t._derivatives?this._derivatives=t._derivatives.clone(this._derivatives):this._derivatives=void 0,t._fractions?this._fractions=t._fractions.clone(!1):this._fractions=void 0,t._surfaceNormals?this._surfaceNormals=t._surfaceNormals.clone(this._surfaceNormals):this._surfaceNormals=void 0,t._uvParams?this._uvParams=t._uvParams.clone():this._uvParams=void 0}static createPoints(t){const e=new Me;let i;for(i of t)e._points.push(i);return e}static createIndexedPoints(t,e,i=!1){const s=new Me;for(const i of e)s._points.push(t[i]);return i&&e.length>1&&s._points.push(t[e[0]]),s}static createFloat64Array(t){const e=new Me;for(let i=0;i+3<=t.length;i+=3)e._points.push(j.create(t[i],t[i+1],t[i+2]));return e}clone(){const t=new Me;return t.setFrom(this),t}setFromJSON(t){if(this._points.clear(),Array.isArray(t)){let e;for(e of t)this._points.push(j.fromJSON(e))}}toJSON(){const t=[];let e=0;for(;this._points.isIndexValid(e);)t.push(this._points.getPoint3dAtUncheckedPointIndex(e).toJSON()),e++;return t}static fromJSON(t){const e=new Me;return e.setFromJSON(t),e}fractionToPoint(t,e){const i=this._points.length;if(0===i)return j.createZero();if(1===i)return j.createFrom(this._points.getPoint3dAtUncheckedPointIndex(0),e);const s=1/(i-1);if(t<=s)return this._points.interpolate(0,t/s,1,e);if(t+s>=1)return this._points.interpolate(i-1,(1-t)/s,i-2,e);const n=Math.floor(t/s);return this._points.interpolate(n,(t-n*s)/s,n+1,e)}fractionToPointAndDerivative(t,e){e=e||bt.createZero();const i=this._points.length;if(i<=1)return e.direction.setZero(),1===i?e.origin.setFrom(this._points.getPoint3dAtUncheckedPointIndex(0)):e.origin.setZero(),e;const s=1/(i-1);if(t<=s)return e=e||bt.createZero(),this._points.interpolate(0,t/s,1,e.origin),this._points.vectorIndexIndex(0,1,e.direction),e.direction.scaleInPlace(1/s),e;if(t+s>=1)return e=e||bt.createZero(),this._points.interpolate(i-2,1-(1-t)/s,i-1,e.origin),this._points.vectorIndexIndex(i-2,i-1,e.direction),e.direction.scaleInPlace(1/s),e;e=e||bt.createZero();const n=Math.floor(t/s),r=(t-n*s)/s;return this._points.interpolate(n,r,n+1,e.origin),this._points.vectorIndexIndex(n,n+1,e.direction),e.direction.scaleInPlace(1/s),e}fractionToPointAnd2Derivatives(t,e){const i=this.fractionToPointAndDerivative(t);return Et.createCapture(i.origin,i.direction,$.createZero(),e)}static mapLocalToGlobalFraction(t,e,i){return i<1?0:(t+e)/i}segmentIndexAndLocalFractionToGlobalFraction(t,e){return Me.mapLocalToGlobalFraction(t,e,this._points.length-1)}static mapGlobalToLocalFraction(t,e){if(e<1)return{index:0,fraction:0};const i=t*e;let s;return s=t<=0?0:t>=1?e-1:Math.floor(i),{index:s,fraction:i-s}}globalFractionToSegmentIndexAndLocalFraction(t){return Me.mapGlobalToLocalFraction(t,this._points.length-1)}fractionToFrenetFrame(t,e){const i=this._points.length;if(i<=1)return 1===i?pt.createTranslation(this._points.getPoint3dAtUncheckedPointIndex(0),e):pt.createIdentity(e);if(2===i)return pt.createRefs(this._points.interpolate(0,t,1),xt.createRigidHeadsUp(this._points.vectorIndexIndex(0,1),g.XYZ));const s=i-1,n=1/s;let r=0,o=0;t<=n?(o=t/n,r=0):t+n>=1?(r=i-2,o=1-(1-t)/n):(r=Math.floor(t/n),o=t*s-r);const a=this._points.interpolate(r,o,r+1),c=this._points.vectorIndexIndex(r,r+1),l=$.create(),h=$.create();0===r?ke(this._points,c,r+1,1,1,l,h):r+2>=i?ke(this._points,c,r-1,-1,1,l,h):(ke(this._points,c,r-1,-1,1-o,l,h),ke(this._points,c,r+1,1,o,l,h));const d=xt.createRigidFromColumns(l,c,g.ZXY);return d?pt.createOriginAndMatrix(a,d,e):pt.createTranslation(a,e)}startPoint(){return 0===this._points.length?j.createZero():this._points.getPoint3dAtUncheckedPointIndex(0)}pointAt(t,e){if(this._points.isIndexValid(t))return this._points.getPoint3dAtUncheckedPointIndex(t,e)}vectorBetween(t,e,i){return this._points.vectorIndexIndex(t,e,i)}derivativeAt(t,e){if(this._derivatives&&this._derivatives.isIndexValid(t))return this._derivatives.getVector3dAtCheckedVectorIndex(t,e)}surfaceNormalAt(t,e){if(this._surfaceNormals&&this._surfaceNormals.isIndexValid(t))return this._surfaceNormals.getVector3dAtCheckedVectorIndex(t,e)}numPoints(){return this._points.length}numEdges(){return this._points.length>0?this._points.length-1:0}endPoint(){return 0===this._points.length?j.createZero():this._points.getPoint3dAtUncheckedPointIndex(this._points.length-1)}reverseInPlace(){this._points.length>=2&&(this._points.reverseInPlace(),this._uvParams&&this._uvParams.reverseInPlace())}tryTransformInPlace(t){return this._points.multiplyTransformInPlace(t),this._derivatives&&this._derivatives.multiplyMatrix3dInPlace(t.matrix),this._surfaceNormals&&this._surfaceNormals.multiplyAndRenormalizeMatrix3dInverseTransposeInPlace(t.matrix),!0}curveLength(){return this._points.sumLengths()}curveLengthBetweenFractions(t,e){const i=this._points.length-1;if(e===t||i<1)return 0;if(e<t)return this.curveLengthBetweenFractions(e,t);const s=t*i,n=e*i,r=Math.max(1,Math.ceil(s)),o=Math.min(Math.floor(n),i-1),a=r-s,c=n-o;if(r>o)return Math.abs(n-s)*this._points.distanceIndexIndex(r-1,r);{let t=a*this._points.distanceIndexIndex(r-1,r)+c*this._points.distanceIndexIndex(o,o+1);for(let e=r;e<o;e++)t+=this._points.distanceIndexIndex(e,e+1);return t}}rangeBetweenFractions(t,e,i){const s=ut.create();if(this.points.length<1)return s;if(e<t)return this.rangeBetweenFractions(e,t,i);const n=this._points.length-1,r=t*n,o=Math.max(0,Math.floor(r)),a=r-o,c=j.create();if(this._points.interpolate(o,a,o+1,c),s.extendPoint(c,i),e===t)return s;const l=e*n,h=Math.min(Math.floor(l),n-1),d=l-h;this._points.interpolate(h,d,h+1,c),s.extendPoint(c,i);for(let t=o+1;t<=h;t++)this._points.getPoint3dAtUncheckedPointIndex(t,c),s.extendPoint(c,i);return s}moveSignedDistanceFromFraction(t,e,i,s){const n=this._points.length-1,r=t*n;let o=Q.restrictToInterval(Math.floor(r),0,n-1);const a=r-o,c=this._points.interpolate(o,a,o+1,Me._workPointA),l=Me._workPointB,h=new be(c,t,e);if(e>0){for(;o<=n;)if(o++,this._points.getPoint3dAtCheckedPointIndex(o,l),h.announcePoint(l,o/n))return vt.createCurveFractionPointDistanceCurveSearchStatus(this,h.fraction0,h.point0,e,A.success,s);return i&&h.announceExtrapolation(this._points,n-1,n,(n-1)/n,1),vt.createCurveFractionPointDistanceCurveSearchStatus(this,h.fraction0,h.point0,e,h.distanceStatus(),s)}for(a<=0&&o--;o>=0;o--)if(this._points.getPoint3dAtCheckedPointIndex(o,l),h.announcePoint(l,o/n))return vt.createCurveFractionPointDistanceCurveSearchStatus(this,h.fraction0,h.point0,e,A.success,s);return i&&h.announceExtrapolation(this._points,1,0,1/n,0),vt.createCurveFractionPointDistanceCurveSearchStatus(this,h.fraction0,h.point0,-h.distance0,h.distanceStatus(),s)}quickLength(){return this.curveLength()}quickUnitNormal(t){let e=Math.floor(this._points.length/3);if(e<1&&(e=1),(t=this._points.crossProductIndexIndexIndex(0,e,e+e))&&t.normalizeInPlace())return t}closestPoint(t,e,i){i=vt.create(this,i);const s=ie.resolveVariantCurveExtendParameterToCurveExtendMode(e,0),n=ie.resolveVariantCurveExtendParameterToCurveExtendMode(e,1),r=this._points.length;if(r>0){const e=r-1;if(i.setFP(1,this._points.getPoint3dAtUncheckedPointIndex(e),void 0),i.setDistanceTo(t),r>1){let o=0,a=0;for(let c=1;c<r;c++)o=t.fractionOfProjectionToLine(this._points.getPoint3dAtUncheckedPointIndex(c-1),this._points.getPoint3dAtUncheckedPointIndex(c)),o<0?(!s||c>1)&&(o=0):o>1&&(!n||c<e)&&(o=1),this._points.getPoint3dAtUncheckedPointIndex(c-1).interpolate(o,this._points.getPoint3dAtUncheckedPointIndex(c),i.pointQ),a=i.pointQ.distance(t),a<i.a&&i.setFP(this.segmentIndexAndLocalFractionToGlobalFraction(c-1,o),i.pointQ,void 0,a)}}return i}isInPlane(t){return this._points.isCloseToPlane(t,Q.smallMetricDistance)}static pushVertexHit(t,e,i,s,n){const r=vt.createCurveFractionPoint(i,s,n);t.push(r),0===e?r.setIntervalRole(P.isolatedAtVertex):1===e?(t[t.length-2].setIntervalRole(P.intervalStart),r.setIntervalRole(P.intervalEnd)):(t[t.length-2].setIntervalRole(P.intervalInterior),r.setIntervalRole(P.intervalEnd))}appendPlaneIntersectionPoints(t,e){if(this._points.length<1)return 0;const i=e.length,s=this._points.length,n=1===s?1:s-1,r=Me._workPointA,o=Me._workPointB,a=Me._workPointC;this._points.getPoint3dAtUncheckedPointIndex(0,r);let c=0,l=0,h=0,d=0;for(let i=0;i<this._points.length;i++,r.setFrom(o),h=c)if(this._points.getPoint3dAtUncheckedPointIndex(i,o),c=Q.correctSmallMetricDistance(t.altitude(o)),0===c)Me.pushVertexHit(e,l++,this,i/n,o);else if(h*c<0){d=h/(h-c),r.interpolate(d,o,a);const t=vt.createCurveFractionPoint(this,(i-1+d)/n,a);t.setIntervalRole(P.isolated),e.push(t),l=0}return e.length-i}extendRange(t,e){this._points.extendRange(t,e)}isAlmostEqual(t){return t instanceof Me&&!!nt.isAlmostEqual(this._points,t._points)}appendStrokePoint(t,e){const i=this._points.length;let s=!0;const n=void 0!==e&&void 0!==this._fractions;i>0&&(n&&Q.isSameCoordinate(e,this._fractions.back())&&(s=!1),t.isAlmostEqual(this._points.getPoint3dAtUncheckedPointIndex(i-1))&&(s=!1)),s&&(this._points.push(t),n&&this.addFraction(e))}removeDuplicatePoints(t=Q.smallMetricDistance){const e=this._points.length;if(e<2)return;let i=1;for(let s=1;s<e;s++){const e=this._points.distanceIndexIndex(s,i-1);void 0!==e&&e>t&&(this._points.moveIndexToIndex(s,i),void 0!==this._fractions&&this._fractions.setAtUncheckedIndex(i,this._fractions.atUncheckedIndex(s)),this._derivatives&&this._derivatives.moveIndexToIndex(s,i),i++)}this._points.resize(i),this._fractions&&this._fractions.resize(i),this._derivatives&&this._derivatives.resize(i)}appendFractionToPoint(t,e){if(this._derivatives){const i=t.fractionToPointAndDerivative(e,Me._workRay);this._fractions&&this._fractions.push(e),this._points.push(i.origin),this._derivatives&&this._derivatives.push(i.direction)}else{const i=t.fractionToPoint(e,Me._workPointA);this._fractions&&this._fractions.push(e),this._points.push(i)}}clear(){this._points.clear(),this._fractions&&this._fractions.clear(),this._derivatives&&this._derivatives.clear()}static createForStrokes(t=0,e){const i=Me.create();return t>0&&i._points.ensureCapacity(t),e&&(e.needParams&&(i._fractions=new It(t),i._uvParams=new Fe(t)),e.needNormals&&(i._derivatives=new nt(t),i._surfaceNormals=new nt(t))),i}appendFractionalStrokePoints(t,e,i=0,s=1,n=!0){let r=1,o=e-1;if(n&&(r=0,o=e),e>=1){const n=(s-i)/e;for(let e=r;e<=o;e++)this.appendFractionToPoint(t,i+e*n)}}appendInterpolatedStrokePoints(t,e,i,s){if(s&&this.appendStrokePoint(e,0),t>1){const s=1/t;for(let n=1;n<t;n++){const t=n*s;this.appendStrokePoint(e.interpolate(t,i),t)}}s&&this.appendStrokePoint(i,1)}emitStrokes(t,e){const i=this._points.length,s=Me._workPointA,n=Me._workPointB;if(i>0)if(e&&e.hasMaxEdgeLength){t.appendStrokePoint(this._points.getPoint3dAtUncheckedPointIndex(0));for(let r=1;r<i;r++){this._points.getPoint3dAtUncheckedPointIndex(r-1,s),this._points.getPoint3dAtUncheckedPointIndex(r,n);const i=e.applyMaxEdgeLength(1,s.distance(n));i>1&&t.appendInterpolatedStrokePoints(i,s,n,!1),t.appendStrokePoint(n)}}else for(let e=0;e<i;e++)t.appendStrokePoint(this._points.getPoint3dAtUncheckedPointIndex(e))}emitStrokableParts(t,e){const i=this._points.length;if(t.startCurvePrimitive(this),i>1){const s=1/(i-1);if(e&&e.hasMaxEdgeLength)for(let n=1;n<i;n++){const i=e.applyMaxEdgeLength(1,this._points.getPoint3dAtUncheckedPointIndex(n-1).distance(this._points.getPoint3dAtUncheckedPointIndex(n)));t.announceSegmentInterval(this,this._points.getPoint3dAtUncheckedPointIndex(n-1),this._points.getPoint3dAtUncheckedPointIndex(n),i,(n-1)*s,n*s)}else for(let e=1;e<i;e++)t.announceSegmentInterval(this,this._points.getPoint3dAtUncheckedPointIndex(e-1),this._points.getPoint3dAtUncheckedPointIndex(e),1,(e-1)*s,e*s)}t.endCurvePrimitive(this)}computeStrokeCountForOptions(t){const e=this._points.length;let i=e-1;if(t&&t.hasMaxEdgeLength){i=0;for(let s=1;s<e;s++)i+=t.applyMaxEdgeLength(1,this._points.distanceIndexIndex(s-1,s))}return i}computeAndAttachRecursiveStrokeCounts(t,e){const i=this._points.length,s=void 0!==t&&t.hasMaxEdgeLength,n=Nt.createWithCurvePrimitiveAndOptionalParent(this,e,[]);for(let e=1;e<i;e++){const i=this._points.distanceIndexIndex(e-1,e),r=s?t.applyMaxEdgeLength(1,i):1;n.addToCountAndLength(r,i)}ae.installStrokeCountMap(this,n,e)}dispatchToGeometryHandler(t){return t.handleLineString3d(this)}announceClipIntervals(t,e){const i=this._points.length;if(i<2)return!1;let s=0,n=1;const r=(t,i)=>{e&&e(Q.interpolate(s,t,n),Q.interpolate(s,i,n),this)},o=Me._workPointA,a=Me._workPointB;this._points.getPoint3dAtUncheckedPointIndex(0,o);let c=!1;for(let e=1;e<i;e++,o.setFrom(a),s=n)this._points.getPoint3dAtUncheckedPointIndex(e,a),n=e/(i-1),t.announceClippedSegmentIntervals(0,1,o,a,r)&&(c=!0);return c}addResolvedPoint(t,e,i){const s=this._points.length;if(0!==s){if(1===s)return this._points.getPoint3dAtUncheckedPointIndex(0,Me._indexPoint),void i.push(Me._indexPoint);t<0&&(t=0),t>s-2&&(t=s-2,e+=1),this._points.interpolate(t,e,t+1,Me._indexPoint),i.push(Me._indexPoint)}}clonePartialCurve(t,e){if(e<t){const i=this.clonePartialCurve(e,t);return i&&i.reverseInPlace(),i}const i=this._points.length;if(i<2)return this.clone();let s,n;i>2&&this.isPhysicallyClosed&&(t<0&&(t=0),e>1&&(e=1));const r=this.globalFractionToSegmentIndexAndLocalFraction(t),o=this.globalFractionToSegmentIndexAndLocalFraction(e);s=t<0?1:0<=t&&t<=1?Q.isSmallRelative(1-r.fraction)?r.index+2:r.index+1:i,n=e<0?-1:0<=e&&e<=1?Q.isSmallRelative(o.fraction)?o.index-1:o.index:i-2;const a=Me.create();this.addResolvedPoint(r.index,r.fraction,a._points);for(let t=s;t<=n;t++)this._points.isIndexValid(t)&&(this._points.getPoint3dAtUncheckedPointIndex(t,Me._workPointA),a._points.push(Me._workPointA));return this.addResolvedPoint(o.index,o.fraction,a._points),a}getIndexedSegment(t,e){if(t>=0&&t+1<this._points.length)return Ce.create(this._points.getPoint3dAtCheckedPointIndex(t),this._points.getPoint3dAtCheckedPointIndex(t+1),e)}get isPhysicallyClosed(){return this._points.length>0&&Q.isSmallMetricDistance(this._points.distanceIndexIndex(0,this._points.length-1))}addMappedStrokesToLineString3D(t,e){const i=e.numPoints(),s=void 0!==e._fractions,n=void 0!==e._derivatives,r=this._points,o=Me._workPointA,a=Me._workPointB,c=Me._workPointC,l=r.length;if(t.primitive&&t.primitive===this&&t.componentData&&t.componentData.length+1===l){r.getPoint3dAtUncheckedPointIndex(0,o);for(let i=0;i+1<l;i++,o.setFromPoint3d(a)){r.getPoint3dAtUncheckedPointIndex(i+1,a);const l=t.componentData[i],h=l.numStroke,d=o.vectorTo(a);d.scale(h);for(let t=0;t<=h;t++){const i=t/h,r=l.fractionToA(i);e.addPoint(o.interpolate(i,a,c)),s&&e._fractions.push(r),n&&e._derivatives.push(d)}}}return e.numPoints()-i}static createArrayOfLineString3d(t){const e=new at;ht.streamXYZ(t,e);const i=e.claimArrayOfGrowableXYZArray(),s=[];if(void 0!==i)for(const t of i)s.push(Me.createCapture(t));return s}collectCurvePrimitivesGo(t,e,i=!1){if(i){let e;for(let i=0;void 0!==(e=this.getIndexedSegment(i));i++)t.push(e)}else t.push(this)}constructOffsetXY(t){const e=we.create(t),i=[];for(const t of this.collectCurvePrimitives(void 0,!0,!0)){const s=t.constructOffsetXY(e);void 0!==s&&(s instanceof ae?i.push(s):Array.isArray(s)&&s.forEach((t=>i.push(t))))}return i}projectedParameterRange(t,e){return Ee.findExtremeFractionsAlongDirection(this,t,e)}static convertLocalToGlobalDetail(t,e,i,s,n){return t.childDetail=t.clone(n),t.childDetail.a=e,t.fraction=this.mapLocalToGlobalFraction(e,t.fraction,i),t.curve=s,t}}Me._workPointA=j.create(),Me._workPointB=j.create(),Me._workPointC=j.create(),Me._workRay=bt.createXAxis(),Me._indexPoint=j.create();class be{constructor(t,e,i){this.point0=t,this.distance0=0,this.targetDistance=Math.abs(i),this.fraction0=e}distanceStatus(){return Q.isSameCoordinate(this.distance0,this.targetDistance)?A.success:A.stoppedAtBoundary}announcePoint(t,e){const i=this.point0.distance(t),s=this.distance0+i;if(s<this.targetDistance&&!Q.isSameCoordinate(s,this.targetDistance))return this.point0.setFromPoint3d(t),this.distance0=s,this.fraction0=e,!1;const n=this.targetDistance-this.distance0,r=Q.safeDivideFraction(n,i,0);return this.point0.interpolate(r,t,this.point0),this.fraction0=Q.interpolate(this.fraction0,r,e),this.distance0=this.targetDistance,!0}announceExtrapolation(t,e,i,s,n){const r=this.targetDistance-this.distance0,o=t.distanceIndexIndex(e,i);if(!o)return!1;const a=Q.conditionalDivideFraction(r,o);return void 0!==a&&(t.interpolate(i,-a,e,this.point0),this.distance0=this.targetDistance,this.fraction0=Q.interpolate(n,-a,s),!0)}}class Ee extends Ae{constructor(t){super(),this.plane=t,this.range=ft.createNull(),this.resetRange()}resetRange(){this.range.setNull()}announcePoint(t){const e=this.plane.altitude(t);this.range.extendLow(e)&&(this.lowPoint=t.clone(this.lowPoint)),this.range.extendHigh(e)&&(this.highPoint=t.clone(this.highPoint))}announcePoints(t){for(let e=0;e<t.length;e++){const i=t.evaluateUncheckedIndexPlaneAltitude(e,this.plane);this.range.extendLow(i)&&(this.lowPoint=t.getPoint3dAtUncheckedPointIndex(e,this.lowPoint)),this.range.extendHigh(i)&&(this.highPoint=t.getPoint3dAtUncheckedPointIndex(e,this.highPoint))}}static createCapture(t){return new Ee(t)}handleLineSegment3d(t){this.announcePoint(t.point0Ref),this.announcePoint(t.point1Ref)}handleLineString3d(t){this.announcePoints(t.packedPoints)}initStrokeOptions(){void 0===this._strokeOptions&&(this._strokeOptions=new Ie,this._strokeOptions.angleTol=W.createDegrees(1))}handleBSplineCurve3d(t){this.initStrokeOptions();const e=Me.create();t.emitStrokes(e,this._strokeOptions),this.handleLineString3d(e)}handleBSplineCurve3dH(t){this.initStrokeOptions();const e=Me.create();t.emitStrokes(e,this._strokeOptions),this.handleLineString3d(e)}handleArc3d(t){this._sineCosinePolynomial=t.getPlaneAltitudeSineCosinePolynomial(this.plane,this._sineCosinePolynomial);let e=this._sineCosinePolynomial.referenceMinMaxRadians();t.sweep.isRadiansInSweep(e)&&this.announcePoint(this._workPoint=t.radiansToPoint(e,this._workPoint)),e+=Math.PI,t.sweep.isRadiansInSweep(e)&&this.announcePoint(this._workPoint=t.radiansToPoint(e,this._workPoint)),this.announcePoint(this._workPoint=t.startPoint(this._workPoint)),this.announcePoint(this._workPoint=t.endPoint(this._workPoint))}static findExtremesInDirection(t,e){const i=e instanceof bt?e.origin:j.createZero(),s=e instanceof bt?e.direction:e,n=_t.create(i,s);if(n){const e=new Ee(n);if(t instanceof Ot)t.dispatchToGeometryHandler(e);else if(t instanceof nt)e.announcePoints(t);else for(const i of t)e.announcePoint(i);return e}}static findExtremePointsInDirection(t,e,i){const s=this.findExtremesInDirection(t,e);if(s&&s.highPoint&&s.lowPoint)return Ce.create(s.lowPoint,s.highPoint,i)}static findExtremeAltitudesInDirection(t,e,i){const s=this.findExtremesInDirection(t,e);if(s&&!s.range.isNull)return ft.createFrom(s.range,i)}static findExtremeFractionsAlongDirection(t,e,i){const s=this.findExtremeAltitudesInDirection(t,e,i);if(void 0!==s){const t=e instanceof $?e.magnitude():e.direction.magnitude(),i=Q.conditionalDivideCoordinate(1,t);if(void 0!==i)return s.low*=i,s.high*=i,s}}}class Re{constructor(t,e){this.x0=t,this.x1=e}set(t,e){this.x0=t,this.x1=e}shift(t){this.x0+=t,this.x1+=t}static create(t=0,e=1,i){return i?(i.set(t,e),i):new Re(t,e)}setFrom(t){this.x0=t.x0,this.x1=t.x1}clone(){return new Re(this.x0,this.x1)}get isIn01(){return Q.isIn01(this.x0)&&Q.isIn01(this.x1)}fractionToPoint(t){return Q.interpolate(this.x0,t,this.x1)}signedDelta(){return this.x1-this.x0}absoluteDelta(){return Math.abs(this.x1-this.x0)}reverseInPlace(){const t=this.x0;this.x0=this.x1,this.x1=t}reverseIfNeededForDeltaSign(t=1){t*(this.x1-this.x0)<0&&this.reverseInPlace()}isAlmostEqual(t){return Q.isSameCoordinate(this.x0,t.x0)&&Q.isSameCoordinate(this.x1,t.x1)}get isExact01(){return 0===this.x0&&1===this.x1}get isExact01Reversed(){return 1===this.x0&&0===this.x1}clipBy01FunctionValuesPositive(t,e){const i=e-t,s=t+this.x0*i,n=t+this.x1*i,r=n-s;if(s>0){if(n>=0)return!0;const t=-s/r;return this.x1=this.x0+t*(this.x1-this.x0),!0}if(s<0){if(n<0)return!1;const t=-s/r;return this.x0=this.x0+t*(this.x1-this.x0),!0}return n>0}clampDirectedTo01(t=!0,e=!0,i=!1){let s=this.x0,n=this.x1;if(n>s){if(s<0&&t&&(s=0),n>1&&e&&(n=1),s>n||s===n&&!i)return!1}else if(s>1&&e&&(s=1),n<0&&t&&(n=0),s<n||s===n&&!i)return!1;return this.set(s,n),!0}}class De{constructor(t,e){this._blockSize=t,this._order=Math.floor(e.length/t),this._packedData=e,this._basis=new Lt(this._order)}clonePolygon(t){const e=this._packedData.length;if(!t||t.length!==e)return this._packedData.slice();for(let i=0;i<e;i++)t[i]=this._packedData[i];return t}get order(){return this._order}get packedData(){return this._packedData}static create(t){if(!(t.length<1)){if(t[0]instanceof j){const e=new Float64Array(3*t.length);let i=0;for(const s of t)e[i++]=s.x,e[i++]=s.y,e[i++]=s.z;return new De(3,e)}if(t[0]instanceof Dt){const e=new Float64Array(4*t.length);let i=0;for(const s of t)e[i++]=s.x,e[i++]=s.y,e[i++]=s.z,e[i++]=s.w;return new De(4,e)}if(t[0]instanceof H){const e=new Float64Array(2*t.length);let i=0;for(const s of t)e[i++]=s.x,e[i++]=s.y;return new De(2,e)}}}evaluate(t,e){return this._basis.sumBasisFunctions(t,this._packedData,this._blockSize,e)}evaluateDerivative(t,e){return this._basis.sumBasisFunctionDerivatives(t,this._packedData,this._blockSize,e)}getPolygonPoint(t,e){if((!e||e.length<this._blockSize)&&(e=new Float64Array(this._blockSize)),t>=0&&t<this._order){const i=this._blockSize*t;for(let t=0;t<this._blockSize;t++)e[t]=this._packedData[i+t];return e}}setPolygonPoint(t,e){if(t>=0&&t<this._order){const i=this._blockSize*t;for(let t=0;t<this._blockSize;t++)this._packedData[i+t]=e[t]}}loadSpanPoles(t,e){let i=e*this._blockSize;for(let e=0;e<this._packedData.length;e++)this._packedData[e]=t[i++]}loadSpanPolesWithWeight(t,e,i,s){let n=0;const r=this._order;let o=i*e;for(let i=0;i<r;i++){for(let i=0;i<e;i++)this._packedData[n++]=t[o++];this._packedData[n++]=s}}unpackToJsonArrays(){return ue.unpackNumbersToNestedArrays(this._packedData,this._blockSize)}isAlmostEqual(t){if(t instanceof De){if(this._blockSize!==t._blockSize)return!1;if(this._order!==t._order)return!1;if(this._packedData.length!==t._packedData.length)return!1;for(let e=0;e<this._packedData.length;e++)if(!Q.isSameCoordinate(this._packedData[e],t._packedData[e]))return!1;return!0}return!1}reverseInPlace(){const t=this._blockSize;let e,i,s;for(e=0,i=(this._order-1)*t;e<i;e+=t,i-=t)for(let n=0;n<t;n++)s=this._packedData[e+n],this._packedData[e+n]=this._packedData[i+n],this._packedData[i+n]=s}interpolatePoleInPlace(t,e,i){let s=t*this._blockSize,n=i*this._blockSize;const r=this._packedData;for(let t=0;t<this._blockSize;t++,s++,n++)r[s]+=e*(r[n]-r[s])}saturateInPlace(t,e){const i=t.degree,s=e+i-1,n=s+1;if(e<0||e>=t.numSpans)return!1;const r=t.knots,o=r[s],a=r[n];if(this.setInterval(o,a),a<=o+ge.knotTolerance)return!1;for(let t=i-1;t>0;t--){let e=s-t;if(r[e]<o){let i=n;for(let s=0;s<t;s++,e++,i++){const t=r[e],n=(o-t)/(r[i]-t);this.interpolatePoleInPlace(s,n,s+1)}}}for(let t=i-1;t>0;t--){let e=n+t;if(r[e]>a)for(let s=0;s<t;s++,e--){const t=r[e],n=(a-t)/(o-t);this.interpolatePoleInPlace(i-s,n,i-s-1)}}return!0}static saturate1dInPlace(t,e,i){const s=e.degree,n=i+s-1,r=n+1;if(i<0||i>=e.numSpans)return!1;const o=e.knots,a=o[n],c=o[r];if(c<=a+ge.knotTolerance)return!1;for(let e=s-1;e>0;e--){let i=n-e;if(o[i]<a){let s=r;for(let n=0;n<e;n++,i++,s++){const e=o[i],r=(a-e)/(o[s]-e);t[n]=t[n]+r*(t[n+1]-t[n])}}}for(let e=s-1;e>0;e--){let i,n=r+e;if(o[n]>c)for(let r=0;r<e;r++,n--){const e=o[n],l=(c-e)/(a-e);i=s-r,t[i]+=l*(t[i-1]-t[i])}}return!0}subdivideInPlaceKeepLeft(t){if(Q.isAlmostEqualNumber(t,1))return!0;if(Q.isAlmostEqualNumber(t,0))return!1;const e=1-t,i=this.order;for(let t=1;t<i;t++)for(let s=i-1;s>=t;s--)this.interpolatePoleInPlace(s,e,s-1);return!0}subdivideInPlaceKeepRight(t){if(Q.isAlmostEqualNumber(t,0))return!0;if(Q.isAlmostEqualNumber(t,1))return!1;const e=this.order;for(let i=1;i<e;i++)for(let s=0;s+i<e;s++)this.interpolatePoleInPlace(s,t,s+1);return!0}subdivideToIntervalInPlace(t,e){return!Q.isAlmostEqualNumber(t,e)&&(e<t?(this.subdivideToIntervalInPlace(e,t),this.reverseInPlace(),!0):(this.subdivideInPlaceKeepLeft(e),this.subdivideInPlaceKeepRight(t/e),!0))}setInterval(t,e){this.interval=Re.create(t,e,this.interval)}fractionToParentFraction(t){return this.interval?this.interval.fractionToPoint(t):t}}class Xe extends ae{constructor(t,e){super(),this.curvePrimitiveType="bezierCurve",this._polygon=new De(t,e),this._workPoint0=j.create(),this._workPoint1=j.create(),this._workData0=new Float64Array(t),this._workData1=new Float64Array(t)}reverseInPlace(){this._polygon.reverseInPlace()}saturateInPlace(t,e){const i=this._polygon.saturateInPlace(t,e);return i&&this.setInterval(t.spanFractionToFraction(e,0),t.spanFractionToFraction(e,1)),i}get degree(){return this._polygon.order-1}get order(){return this._polygon.order}get numPoles(){return this._polygon.order}setInterval(t,e){this._polygon.setInterval(t,e)}fractionToParentFraction(t){return this._polygon.fractionToParentFraction(t)}emitStrokes(t,e){const i=this.computeStrokeCountForOptions(e),s=1/i;for(let e=0;e<=i;e++){const i=e*s;this.fractionToPoint(i,this._workPoint0),t.appendStrokePoint(this._workPoint0)}}emitStrokableParts(t,e){const i=this.computeStrokeCountForOptions(e);t.announceIntervalForUniformStepStrokes(this,i,0,1)}copyPolesAsJsonArray(){return this._polygon.unpackToJsonArrays()}isInPlane(t){let e=this._workPoint0;for(let i=0;;i++){if(e=this.getPolePoint3d(i,e),!e)return!0;if(!t.isPointInPlane(e))break}return!1}polygonLength(){if(!this.getPolePoint3d(0,this._workPoint0))return 0;let t=0,e=0;for(;this.getPolePoint3d(++t,this._workPoint1);)e+=this._workPoint0.distance(this._workPoint1),this._workPoint0.setFrom(this._workPoint1);return e}startPoint(){return this.getPolePoint3d(0)}endPoint(){return this.getPolePoint3d(this.order-1)}quickLength(){return this.polygonLength()}allocateAndZeroBezierWorkData(t,e,i){t>0&&(void 0!==this._workBezier&&this._workBezier.order===t?this._workBezier.zero():this._workBezier=new Lt(t)),e>0&&(void 0!==this._workCoffsA&&this._workCoffsA.length===e?this._workCoffsA.fill(0):this._workCoffsA=new Float64Array(e)),i>0&&(void 0!==this._workCoffsB&&this._workCoffsB.length===i?this._workCoffsB.fill(0):this._workCoffsB=new Float64Array(i))}computeStrokeCountForOptions(t){this.getPolePoint3d(0,this._workPoint0),this.getPolePoint3d(1,this._workPoint1);let e=1;if(this._workPoint0&&this._workPoint1){let i,s,n,r=this._workPoint1.x-this._workPoint0.x,o=this._workPoint1.y-this._workPoint0.y,a=this._workPoint1.z-this._workPoint0.z,c=0,l=Q.hypotenuseXYZ(r,o,a);this._workPoint1.setFromPoint3d(this._workPoint0);let h,d=l,u=l,f=0;for(let t=2;this.getPolePoint3d(t,this._workPoint1);t++)i=this._workPoint1.x-this._workPoint0.x,s=this._workPoint1.y-this._workPoint0.y,n=this._workPoint1.z-this._workPoint0.z,h=W.radiansBetweenVectorsXYZ(r,o,a,i,s,n),c+=h,f=Q.maxAbsXY(h,f),l=Q.hypotenuseXYZ(i,s,n),d+=l,u=Q.maxXY(u,l),r=i,o=s,a=n,this._workPoint0.setFrom(this._workPoint1);const g=u*this.degree,p=Math.sqrt(g*d);let m=f*(this.degree-1);this.degree<3&&(m*=3);const x=Math.sqrt(m*c),_=this.degree;e=Ie.applyAngleTol(t,Ie.applyMaxEdgeLength(t,_,p),x,.1),t&&(e=t.applyChordTolToLengthAndRadians(e,d,m))}return e}cloneTransformed(t){const e=this.clone();return e.tryTransformInPlace(t),e}constructOffsetXY(t){const e=we.create(t),i=new ye(this,e.leftOffsetDistance);return this.emitStrokableParts(i,e.strokeOptions),i.claimResult()}clonePartialCurve(t,e){const i=this.clone();return i._polygon.subdivideToIntervalInPlace(t,e),i}projectedParameterRange(t,e){return Ee.findExtremeFractionsAlongDirection(this,t,e)}}class ze extends Xe{isSameGeometryClass(t){return t instanceof ze}tryTransformInPlace(t){const e=this._workData0;for(let i=0;i<this._polygon.order;i++)this._polygon.getPolygonPoint(i,e),t.multiplyXYZToFloat64Array(e[0],e[1],e[2],e),this._polygon.setPolygonPoint(i,e);return!0}getPolePoint3d(t,e){const i=this._polygon.getPolygonPoint(t,this._workData0);if(i)return j.create(i[0],i[1],i[2],e)}getPolePoint4d(t,e){const i=this._polygon.getPolygonPoint(t,this._workData0);if(i)return Dt.create(i[0],i[1],i[2],1,e)}constructor(t){super(3,t),this._workRay0=bt.createXAxis(),this._workRay1=bt.createXAxis()}copyPointsAsLineString(){const t=Me.create();for(let e=0;e<this._polygon.order;e++)t.addPoint(this.getPolePoint3d(e));return t}static create(t){if(t.length<1)return;const e=new Float64Array(3*t.length);if(t[0]instanceof j){let i=0;for(const s of t)e[i++]=s.x,e[i++]=s.y,e[i++]=s.z;return new ze(e)}if(t[0]instanceof H){let i=0;for(const s of t)e[i++]=s.x,e[i++]=s.y,e[i++]=0;return new ze(e)}}static createOrder(t){const e=new Float64Array(3*t);return new ze(e)}loadSpanPoles(t,e){this._polygon.loadSpanPoles(t,e)}clone(){return new ze(this._polygon.clonePolygon())}fractionToPoint(t,e){return this._polygon.evaluate(t,this._workData0),j.create(this._workData0[0],this._workData0[1],this._workData0[2],e)}fractionToPointAndDerivative(t,e){return this._polygon.evaluate(t,this._workData0),this._polygon.evaluateDerivative(t,this._workData1),bt.createXYZUVW(this._workData0[0],this._workData0[1],this._workData0[2],this._workData1[0],this._workData1[1],this._workData1[2],e)}fractionToPointAnd2Derivatives(t,e){const i=1/2e-8;e||(e=Et.createXYPlane());const s=this.fractionToPointAndDerivative(t,this._workRay0);e.origin.setFrom(s.origin),e.vectorU.setFrom(s.direction);const n=this.fractionToPointAndDerivative(t-1e-8,this._workRay0),r=this.fractionToPointAndDerivative(t+1e-8,this._workRay1);return $.createAdd2Scaled(n.direction,-i,r.direction,i,e.vectorV),e}isAlmostEqual(t){return t instanceof ze&&this._polygon.isAlmostEqual(t._polygon)}dispatchToGeometryHandler(t){return t.handleBezierCurve3d(this)}extendRange(t,e){const i=this.order;if(e){this.allocateAndZeroBezierWorkData(i-1,i,0);const s=this._workBezier,n=this._workCoffsA;this.getPolePoint3d(0,this._workPoint0),t.extendTransformedPoint(e,this._workPoint0),this.getPolePoint3d(i-1,this._workPoint0),t.extendTransformedPoint(e,this._workPoint0);const r=this._polygon.packedData;for(let o=0;o<3;o++){for(let t=0,s=0;t<i;t++,s+=3)n[t]=e.multiplyComponentXYZ(o,r[s],r[s+1],r[s+2]);Vt.univariateDifference(n,s.coffs);const a=s.roots(0,!0);if(a&&a.length>0)for(const i of a)this.fractionToPoint(i,this._workPoint0),t.extendTransformedPoint(e,this._workPoint0)}}else{this.allocateAndZeroBezierWorkData(i-1,0,0);const e=this._workBezier;this.getPolePoint3d(0,this._workPoint0),t.extend(this._workPoint0),this.getPolePoint3d(i-1,this._workPoint0),t.extend(this._workPoint0);for(let s=0;s<3;s++){Vt.componentDifference(e.coffs,this._polygon.packedData,3,i,s);const n=e.roots(0,!0);if(n)for(const e of n)this.fractionToPoint(e,this._workPoint0),t.extend(this._workPoint0)}}}}class Ne extends Xe{isSameGeometryClass(t){return t instanceof Ne}tryTransformInPlace(t){const e=this._workData0;for(let i=0;i<this._polygon.order;i++)this._polygon.getPolygonPoint(i,e),t.multiplyXYZWToFloat64Array(e[0],e[1],e[2],e[3],e),this._polygon.setPolygonPoint(i,e);return!0}tryMultiplyMatrix4dInPlace(t){t.multiplyBlockedFloat64ArrayInPlace(this._polygon.packedData)}getPolePoint4d(t,e){const i=this._polygon.getPolygonPoint(t,this._workData0);if(i)return Dt.create(i[0],i[1],i[2],i[3],e)}getPolePoint3d(t,e){const i=this._polygon.getPolygonPoint(t,this._workData0);if(i)return j.createFromPackedXYZW(i,0,e)}isUnitWeight(t){void 0===t&&(t=Q.smallAngleRadians);const e=1-t,i=1+t,s=this._polygon.packedData,n=s.length;let r;for(let t=3;t<n;t+=4)if(r=s[t],r<e||r>i)return!1;return!0}constructor(t){super(4,t),this._workRay0=bt.createXAxis(),this._workRay1=bt.createXAxis()}static create(t){if(t.length<1)return;const e=new Float64Array(4*t.length);if(t[0]instanceof j){let i=0;for(const s of t)e[i++]=s.x,e[i++]=s.y,e[i++]=s.z,e[i++]=1;return new Ne(e)}if(t[0]instanceof Dt){let i=0;for(const s of t)e[i++]=s.x,e[i++]=s.y,e[i++]=s.z,e[i++]=s.w;return new Ne(e)}if(t[0]instanceof H){let i=0;for(const s of t)e[i++]=s.x,e[i++]=s.y,e[i++]=0,e[i++]=1;return new Ne(e)}}static createOrder(t){const e=new Float64Array(4*t);return new Ne(e)}loadSpan3dPolesWithWeight(t,e,i){this._polygon.loadSpanPolesWithWeight(t,3,e,i)}loadSpan4dPoles(t,e){this._polygon.loadSpanPoles(t,e)}clone(){return new Ne(this._polygon.clonePolygon())}fractionToPoint(t,e){return this._polygon.evaluate(t,this._workData0),(e=j.createFromPackedXYZW(this._workData0,0,e))||j.createZero()}fractionToPoint4d(t,e){return this._polygon.evaluate(t,this._workData0),(e=Dt.createFromPacked(this._workData0,0,e))||Dt.createZero()}fractionToPointAndDerivative(t,e){return this._polygon.evaluate(t,this._workData0),this._polygon.evaluateDerivative(t,this._workData1),(e=bt.createWeightedDerivative(this._workData0,this._workData1,e))||bt.createXAxis()}fractionToPointAnd2Derivatives(t,e){const i=1/2e-8;e||(e=Et.createXYPlane());const s=this.fractionToPointAndDerivative(t,this._workRay0);e.origin.setFrom(s.origin),e.vectorU.setFrom(s.direction);const n=this.fractionToPointAndDerivative(t-1e-8,this._workRay0),r=this.fractionToPointAndDerivative(t+1e-8,this._workRay1);return $.createAdd2Scaled(n.direction,-i,r.direction,i,e.vectorV),e}isAlmostEqual(t){return t instanceof Ne&&this._polygon.isAlmostEqual(t._polygon)}dispatchToGeometryHandler(t){return t.handleBezierCurve3dH(this)}poleProductsXYZW(t,e,i,s,n){const r=this.numPoles,o=this._polygon.packedData;for(let a=0,c=0;a<r;a++,c+=4)t[a]=e*o[c]+i*o[c+1]+s*o[c+2]+n*o[c+3]}updateClosestPointByTruePerpendicular(t,e,i=!1,s=!1){let n,r=0;if(this.isUnitWeight()){const e=2*this.order-2;this.allocateAndZeroBezierWorkData(e,0,0);const i=this._workBezier;Vt.accumulateScaledShiftedComponentTimesComponentDelta(i.coffs,this._polygon.packedData,4,this.order,1,0,-t.x,0),Vt.accumulateScaledShiftedComponentTimesComponentDelta(i.coffs,this._polygon.packedData,4,this.order,1,1,-t.y,1),Vt.accumulateScaledShiftedComponentTimesComponentDelta(i.coffs,this._polygon.packedData,4,this.order,1,2,-t.z,2),n=i.roots(0,!0)}else{const e=this.order,i=2*this.order-2,s=e+i-1;this.allocateAndZeroBezierWorkData(s,e,i);const r=this._workBezier,o=this._workCoffsA,a=this._workCoffsB,c=this._polygon.packedData;for(let i=0;i<3;i++){for(let t=0;t<o.length;t++)o[t]=0;for(let t=0;t<a.length;t++)a[t]=0;Vt.scaledComponentSum(o,c,4,e,3,t.at(i),i,-1),Vt.accumulateScaledShiftedComponentTimesComponentDelta(a,c,4,e,1,3,0,i),Vt.accumulateScaledShiftedComponentTimesComponentDelta(a,c,4,e,-1,i,0,3),Vt.accumulateProduct(r.coffs,o,a)}n=r.roots(0,!0)}if(n)for(const i of n){const s=this.fractionToPoint(i),n=s.distance(t);r+=e.updateIfCloserCurveFractionPointDistance(this,i,s,n)?1:0}return i&&(r+=this.updateDetailAtFraction(e,0,t)?1:0),s&&(r+=this.updateDetailAtFraction(e,1,t)?1:0),r>0}updateDetailAtFraction(t,e,i){const s=this.fractionToPoint(e),n=s.distance(i);return t.updateIfCloserCurveFractionPointDistance(this,e,s,n)}extendRange(t,e){const i=this.order;if(e){this.allocateAndZeroBezierWorkData(2*i-2,i,i);const s=this._workCoffsA,n=this._workCoffsB,r=this._workBezier;this.getPolePoint3d(0,this._workPoint0),t.extendTransformedPoint(e,this._workPoint0),this.getPolePoint3d(i-1,this._workPoint0),t.extendTransformedPoint(e,this._workPoint0);const o=this._polygon.packedData;let a;for(let c=0;c<3;c++){r.zero();for(let t=0,r=0;t<i;t++,r+=4)a=o[r+3],s[t]=e.multiplyComponentXYZW(c,o[r],o[r+1],o[r+2],a),n[t]=a;Vt.accumulateProductWithDifferences(r.coffs,s,n,1),Vt.accumulateProductWithDifferences(r.coffs,n,s,-1);const l=r.roots(0,!0);if(l&&l.length>0)for(const i of l)this.fractionToPoint(i,this._workPoint0),t.extendTransformedPoint(e,this._workPoint0)}}else{this.allocateAndZeroBezierWorkData(2*i-2,0,0);const e=this._workBezier,s=this._polygon.packedData;this.getPolePoint3d(0,this._workPoint0),t.extend(this._workPoint0),this.getPolePoint3d(i-1,this._workPoint0),t.extend(this._workPoint0);for(let n=0;n<3;n++){e.zero(),Vt.accumulateScaledShiftedComponentTimesComponentDelta(e.coffs,s,4,i,1,n,0,3),Vt.accumulateScaledShiftedComponentTimesComponentDelta(e.coffs,s,4,i,-1,3,0,n);const r=e.roots(0,!0);if(r)for(const e of r)this.fractionToPoint(e,this._workPoint0),t.extend(this._workPoint0)}}}}class Oe{get degree(){return this.knots.degree}get order(){return this.knots.degree+1}get numSpan(){return this.numPoles-this.knots.degree}get numPoles(){return this.packedData.length/this.poleLength}getPoint3dPole(t,e){return j.createFromPacked(this.packedData,t,e)}constructor(t,e,i,s){this.knots=s,this.packedData=new Float64Array(t*e),this.poleLength=e,this.basisBuffer=new Float64Array(i),this.poleBuffer=new Float64Array(e),this.basisBuffer1=new Float64Array(i),this.basisBuffer2=new Float64Array(i),this.poleBuffer1=new Float64Array(e),this.poleBuffer2=new Float64Array(e)}static create(t,e,i,s){return new Oe(t,e,i,s)}spanFractionToKnot(t,e){return this.knots.spanFractionToKnot(t,e)}evaluateBasisFunctionsInSpan(t,e,i,s,n){t<0&&(t=0),t>=this.numSpan&&(t=this.numSpan-1);const r=t+this.degree-1,o=this.knots.baseKnotFractionToKnot(r,e);return s?this.knots.evaluateBasisFunctions1(r,o,i,s,n):this.knots.evaluateBasisFunctions(r,o,i)}evaluateBuffersInSpan(t,e){this.evaluateBasisFunctionsInSpan(t,e,this.basisBuffer),this.sumPoleBufferForSpan(t)}evaluateBuffersInSpan1(t,e){this.evaluateBasisFunctionsInSpan(t,e,this.basisBuffer,this.basisBuffer1),this.sumPoleBufferForSpan(t),this.sumPoleBuffer1ForSpan(t)}sumPoleBufferForSpan(t){this.poleBuffer.fill(0);let e=t*this.poleLength;for(const t of this.basisBuffer)for(let i=0;i<this.poleLength;i++)this.poleBuffer[i]+=t*this.packedData[e++]}sumPoleBuffer1ForSpan(t){this.poleBuffer1.fill(0);let e=t*this.poleLength;for(const t of this.basisBuffer1)for(let i=0;i<this.poleLength;i++)this.poleBuffer1[i]+=t*this.packedData[e++]}sumPoleBuffer2ForSpan(t){this.poleBuffer2.fill(0);let e=t*this.poleLength;for(const t of this.basisBuffer2)for(let i=0;i<this.poleLength;i++)this.poleBuffer2[i]+=t*this.packedData[e++]}evaluateBuffersAtKnot(t,e=0){const i=this.knots.knotToLeftKnotIndex(t);e<1?(this.knots.evaluateBasisFunctions(i,t,this.basisBuffer),this.sumPoleBufferForSpan(i-this.degree+1)):1===e?(this.knots.evaluateBasisFunctions1(i,t,this.basisBuffer,this.basisBuffer1),this.sumPoleBufferForSpan(i-this.degree+1),this.sumPoleBuffer1ForSpan(i-this.degree+1)):(this.knots.evaluateBasisFunctions1(i,t,this.basisBuffer,this.basisBuffer1,this.basisBuffer2),this.sumPoleBufferForSpan(i-this.degree+1),this.sumPoleBuffer1ForSpan(i-this.degree+1),this.sumPoleBuffer2ForSpan(i-this.degree+1))}reverseInPlace(){const t=this.poleLength,e=this.packedData;for(let i=0,s=t*(this.numPoles-1);i<s;i+=t,s-=t){let n=0;for(let r=0;r<t;r++)n=e[i+r],e[i+r]=e[s+r],e[s+r]=n}this.knots.reflectKnots()}testCloseablePolygon(t){return this.testClosablePolygon(t)}testClosablePolygon(t){void 0===t&&(t=this.knots.wrappable);let e=0;if(t===w.OpenByAddingControlPoints)e=this.degree;else{if(t!==w.OpenByRemovingKnots)return!1;e=1}const i=this.poleLength,s=(this.numPoles-e)*i,n=e*i;for(let t=0;t<n;t++)if(!Q.isSameCoordinate(this.packedData[t],this.packedData[t+s]))return!1;return!0}addKnot(t,e){if(t<this.knots.leftKnot||t>this.knots.rightKnot)return!1;let i=this.knots.knotToLeftKnotIndex(t);if(Math.abs(t-this.knots.knots[i])<ge.knotTolerance)t=this.knots.knots[i];else if(Math.abs(t-this.knots.knots[i+1])<ge.knotTolerance){if(i+=this.knots.getKnotMultiplicityAtIndex(i+1),i>this.knots.rightKnotIndex)return!0;t=this.knots.knots[i]}const s=Math.min(e,this.degree)-this.knots.getKnotMultiplicity(t);if(s<=0)return!0;let n=this.knots.knots.length;const r=new Float64Array(n+s);for(let t=0;t<n;++t)r[t]=this.knots.knots[t];let o=this.numPoles;const a=new Float64Array(this.packedData.length+s*this.poleLength);for(let t=0;t<this.packedData.length;++t)a[t]=this.packedData[t];const c=new Float64Array(this.degree*this.poleLength);for(let e=0;e<s;++e){let e=0;const s=i-this.degree+2;for(let i=s;i<s+this.degree;++i){const s=(t-r[i-1])/(r[i+this.degree-1]-r[i-1]);for(let t=i*this.poleLength;t<(i+1)*this.poleLength;++t)c[e++]=Q.interpolate(a[t-this.poleLength],s,a[t])}a.copyWithin((s+this.degree)*this.poleLength,(s+this.degree-1)*this.poleLength,o*this.poleLength);let l=s*this.poleLength;for(const t of c)a[l++]=t;r.copyWithin(i+2,i+1,n),r[i+1]=t,++i,++n,++o}return this.knots.setKnotsCapture(r),this.packedData=a,!0}}class Ye extends ae{set definitionData(t){this._definitionData=t}get definitionData(){return this._definitionData}constructor(t,e,i,s){super(),this.curvePrimitiveType="bsplineCurve",this._bcurve=Oe.create(e,t,i,s)}get degree(){return this._bcurve.degree}get order(){return this._bcurve.order}get numSpan(){return this._bcurve.numSpan}get numPoles(){return this._bcurve.numPoles}get polesRef(){return this._bcurve.packedData}get knotsRef(){return this._bcurve.knots.knots}get poleDimension(){return this._bcurve.poleLength}copyKnots(t){return this._bcurve.knots.copyKnots(t)}getWrappable(){return this._bcurve.knots.wrappable}setWrappable(t){this._bcurve.knots.wrappable=t}get isClosableCurve(){const t=this._bcurve.knots.wrappable;return t===w.None?w.None:this._bcurve.knots.testClosable(t)&&this._bcurve.testClosablePolygon(t)?t:w.None}fractionToPoint(t,e){return this.knotToPoint(this._bcurve.knots.fractionToKnot(t),e)}fractionToPointAndDerivative(t,e){const i=this._bcurve.knots.fractionToKnot(t);return(e=this.knotToPointAndDerivative(i,e)).direction.scaleInPlace(this._bcurve.knots.knotLength01),e}fractionToPointAnd2Derivatives(t,e){const i=this._bcurve.knots.fractionToKnot(t);e=this.knotToPointAnd2Derivatives(i,e);const s=this._bcurve.knots.knotLength01;return e.vectorU.scaleInPlace(s),e.vectorV.scaleInPlace(s*s),e}startPoint(){return this.evaluatePointInSpan(0,0)}endPoint(){return this.evaluatePointInSpan(this.numSpan-1,1)}reverseInPlace(){this._bcurve.reverseInPlace()}collectBezierSpans(t){const e=[],i=this.numSpan;for(let s=0;s<i;s++)if(this._bcurve.knots.isIndexOfRealSpan(s)){const i=this.getSaturatedBezierSpan3dOr3dH(s,t);i&&e.push(i)}return e}poleIndexToDataIndex(t){if(t>=0&&t<this.numPoles)return t*this._bcurve.poleLength}closestPoint(t,e,i){const s=this.fractionToPoint(0);let n;i=vt.createCurveFractionPointDistance(this,0,s,s.distance(t),i);const r=this.numSpan;for(let e=0;e<r;e++)this._bcurve.knots.isIndexOfRealSpan(e)&&(n=this.getSaturatedBezierSpan3dOr3dH(e,!0,n),n&&n.updateClosestPointByTruePerpendicular(t,i,!1,!0)&&(i.curve=this,i.fraction=n.fractionToParentFraction(i.fraction)));return i}cloneTransformed(t){const e=this.clone();return e.tryTransformInPlace(t),e}clonePartialCurve(t,e){const i=this.clone(),s=i._bcurve.knots.knots.length;let n=i._bcurve.knots.fractionToKnot(t),r=i._bcurve.knots.fractionToKnot(e);if(i._bcurve.addKnot(n,i.degree),i._bcurve.addKnot(r,i.degree),s===i._bcurve.knots.knots.length)return i;if(n>r){const t=n;n=r,r=t}const o=i._bcurve.knots.knotToLeftKnotIndex(n)-i.degree+1,a=o*i._bcurve.poleLength,c=i._bcurve.knots.knotToLeftKnotIndex(r);let l=c-i._bcurve.knots.getKnotMultiplicityAtIndex(c)+1;i._bcurve.knots.knots[c]<r&&(l=c+1);const h=(l+1)*i._bcurve.poleLength,d=l+i.degree;return i._bcurve.knots.setKnotsCapture(i._bcurve.knots.knots.slice(o,d)),i._bcurve.packedData=i._bcurve.packedData.slice(a,h),i.setWrappable(w.None),i}appendPlaneIntersectionPoints(t,e){const i=this.numPoles,s=this.order,n=new Float64Array(i),r=this.numSpan,o=Dt.create(),a=ft.createNull();for(let e=0;e<i;e++)n[e]=t.weightedAltitude(this.getPolePoint4d(e,o)),a.extendX(n[e]);let c,l=0,h=-1e3;if(a.containsX(0))for(let t=0;t<r;t++)if(this._bcurve.knots.isIndexOfRealSpan(t)&&(a.setNull(),a.extendArraySubset(n,t,s),a.containsX(0))){c=Lt.createArraySubset(n,t,s,c),De.saturate1dInPlace(c.coffs,this._bcurve.knots,t);const i=c.roots(0,!0);if(i)for(const s of i){l++;const i=this._bcurve.knots.spanFractionToFraction(t,s);if(!Q.isAlmostEqualNumber(i,h)){const t=vt.createCurveEvaluatedFraction(this,i);t.intervalRole=P.isolated,e.push(t),h=i}}}return l}constructOffsetXY(t){const e=we.create(t),i=new ye(this,e.leftOffsetDistance);return this.emitStrokableParts(i,e.strokeOptions),i.claimResult()}projectedParameterRange(t,e){return Ee.findExtremeFractionsAlongDirection(this,t,e)}}class Be extends Ye{initializeWorkBezier(){return void 0===this._workBezier&&(this._workBezier=ze.createOrder(this.order)),this._workBezier}isSameGeometryClass(t){return t instanceof Be}tryTransformInPlace(t){return ue.multiplyInPlace(t,this._bcurve.packedData),!0}getPolePoint3d(t,e){const i=this.poleIndexToDataIndex(t);if(void 0!==i){const t=this._bcurve.packedData;return j.create(t[i],t[i+1],t[i+2],e)}}getPolePoint4d(t,e){const i=this.poleIndexToDataIndex(t);if(void 0!==i){const t=this._bcurve.packedData;return Dt.create(t[i],t[i+1],t[i+2],1,e)}}spanFractionToKnot(t,e){return this._bcurve.spanFractionToKnot(t,e)}constructor(t,e,i){super(3,t,e,i)}copyPoints(){return ue.unpackNumbersToNestedArrays(this._bcurve.packedData,3)}copyPointsFloat64Array(){return this._bcurve.packedData.slice()}copyKnots(t){return this._bcurve.knots.copyKnots(t)}static createUniformKnots(t,e){const i=t instanceof Float64Array?t.length/3:t.length;if(e<2||i<e)return;const s=ge.createUniformClamped(i,e-1,0,1),n=new Be(i,e,s);if(t instanceof Float64Array)for(let e=0;e<3*i;e++)n._bcurve.packedData[e]=t[e];else if(t instanceof nt)n._bcurve.packedData=t.float64Data().slice(0,3*i);else{let e=0;for(const i of t)n._bcurve.packedData[e++]=i.x,n._bcurve.packedData[e++]=i.y,n._bcurve.packedData[e++]=i.z}return n}static createPeriodicUniformKnots(t,e){if(e<2)return;let i=t instanceof Float64Array?t.length/3:t.length;if(i<2)return;const s=j.createZero(),n=j.createZero();let r=!1;do{t instanceof Float64Array?(s.set(t[0],t[1],t[2]),n.set(t[3*i-3],t[3*i-2],t[3*i-1])):t instanceof nt?(t.getPoint3dAtUncheckedPointIndex(0,s),t.getPoint3dAtUncheckedPointIndex(i-1,n)):(s.setFromPoint3d(t[0]),n.setFromPoint3d(t[i-1])),(r=s.isAlmostEqual(n))&&--i}while(r&&i>1);if(i<e)return;const o=e-1,a=i,c=ge.createUniformWrapped(a,o,0,1);c.wrappable=w.OpenByAddingControlPoints;const l=new Be(i+o,e,c);if(t instanceof Float64Array){let e=0;for(let s=0;s<3*i;s++)l._bcurve.packedData[e++]=t[s];for(let i=0;i<3*o;i++)l._bcurve.packedData[e++]=t[i]}else if(t instanceof nt){let e=0;for(let s=0;s<3*i;s++)l._bcurve.packedData[e++]=t.float64Data()[s];for(let i=0;i<3*o;i++)l._bcurve.packedData[e++]=t.float64Data()[i]}else{let e=0;for(let s=0;s<i;s++)l._bcurve.packedData[e++]=t[s].x,l._bcurve.packedData[e++]=t[s].y,l._bcurve.packedData[e++]=t[s].z;for(let i=0;i<o;i++)l._bcurve.packedData[e++]=t[i].x,l._bcurve.packedData[e++]=t[i].y,l._bcurve.packedData[e++]=t[i].z}return l}static createFromInterpolationCurve3dOptions(t){return pe.createThroughPointsC2Cubic(t)}static createFromAkimaCurve3dOptions(t){return pe.createThroughPoints(t.fitPoints,4)}static create(t,e,i){if(i<2)return;let s=t.length;if(t instanceof Float64Array&&(s=Math.floor(s/3)),s<i)return;const n=e.length,r=s+i===n;if(!r&&s+i!==n+2)return;const o=ge.create(e,i-1,r),a=new Be(s,i,o);let c=0;if(t instanceof Float64Array)for(const e of t)a._bcurve.packedData[c++]=e;else if(t[0]instanceof j)for(const e of t)a._bcurve.packedData[c++]=e.x,a._bcurve.packedData[c++]=e.y,a._bcurve.packedData[c++]=e.z;else{if(!Array.isArray(t[0])||3!==t[0].length)return;for(const e of t)for(const t of e)a._bcurve.packedData[c++]=t}return a}clone(){const t=this._bcurve.knots.clone(),e=new Be(this.numPoles,this.order,t);return e._bcurve.packedData=this._bcurve.packedData.slice(),e}evaluatePointInSpan(t,e){return this._bcurve.evaluateBuffersInSpan(t,e),j.createFrom(this._bcurve.poleBuffer)}evaluatePointAndDerivativeInSpan(t,e){return this._bcurve.evaluateBuffersInSpan1(t,e),bt.createCapture(j.createFrom(this._bcurve.poleBuffer),$.createFrom(this._bcurve.poleBuffer1))}knotToPoint(t,e){return this._bcurve.evaluateBuffersAtKnot(t),j.createFrom(this._bcurve.poleBuffer,e)}knotToPointAndDerivative(t,e){return this._bcurve.evaluateBuffersAtKnot(t,1),e?(e.origin.setFrom(this._bcurve.poleBuffer),e.direction.setFrom(this._bcurve.poleBuffer1),e):bt.createCapture(j.createFrom(this._bcurve.poleBuffer),$.createFrom(this._bcurve.poleBuffer1))}knotToPointAnd2Derivatives(t,e){return this._bcurve.evaluateBuffersAtKnot(t,2),Et.createOriginAndVectorsXYZ(this._bcurve.poleBuffer[0],this._bcurve.poleBuffer[1],this._bcurve.poleBuffer[2],this._bcurve.poleBuffer1[0],this._bcurve.poleBuffer1[1],this._bcurve.poleBuffer1[2],this._bcurve.poleBuffer2[0],this._bcurve.poleBuffer2[1],this._bcurve.poleBuffer2[2],e)}isAlmostEqual(t){return t instanceof Be&&this._bcurve.knots.isAlmostEqual(t._bcurve.knots)&&ue.isAlmostEqual(this._bcurve.packedData,t._bcurve.packedData)}isInPlane(t){return ue.isCloseToPlane(this._bcurve.packedData,t)}quickLength(){return ue.sumEdgeLengths(this._bcurve.packedData)}emitStrokableParts(t,e){const i=void 0!==t.announceBezierCurve,s=this.initializeWorkBezier(),n=this.numSpan;let r;for(let o=0;o<n;o++){const n=this.getSaturatedBezierSpan3dOr3dH(o,!1,s);n&&(r=n.computeStrokeCountForOptions(e),i?t.announceBezierCurve(n,r,this,o,this._bcurve.knots.spanFractionToFraction(o,0),this._bcurve.knots.spanFractionToFraction(o,1)):t.announceIntervalForUniformStepStrokes(this,r,this._bcurve.knots.spanFractionToFraction(o,0),this._bcurve.knots.spanFractionToFraction(o,1)))}}computeStrokeCountForOptions(t){const e=this.initializeWorkBezier(),i=this.numSpan;let s=0;for(let n=0;n<i;n++){const i=this.getSaturatedBezierSpan3d(n,e);i&&(s+=i.computeStrokeCountForOptions(t))}return s}computeAndAttachRecursiveStrokeCounts(t,e){const i=this.initializeWorkBezier(),s=this.numSpan,n=Nt.createWithCurvePrimitiveAndOptionalParent(this,e,[]);for(let e=0;e<s;e++)if(this.getSaturatedBezierSpan3d(e,i)){const e=i.curveLength(),s=i.computeStrokeCountForOptions(t);n.addToCountAndLength(s,e)}ae.installStrokeCountMap(this,n,e)}emitStrokes(t,e){const i=this.initializeWorkBezier(),s=this.numSpan;for(let n=0;n<s;n++){const s=this.getSaturatedBezierSpan3d(n,i);s&&s.emitStrokes(t,e)}}get isClosable(){return this.isClosableCurve}getSaturatedBezierSpan3dOr3dH(t,e,i){return e?this.getSaturatedBezierSpan3dH(t,i):this.getSaturatedBezierSpan3d(t,i)}getSaturatedBezierSpan3d(t,e){if(t<0||t>=this.numSpan)return;const i=this.order;void 0!==e&&e instanceof ze&&e.order===i||(e=ze.createOrder(i));const s=e;return s.loadSpanPoles(this._bcurve.packedData,t),s.saturateInPlace(this._bcurve.knots,t)?e:void 0}getSaturatedBezierSpan3dH(t,e){if(t<0||t>=this.numSpan)return;const i=this.order;void 0!==e&&e instanceof Ne&&e.order===i||(e=Ne.createOrder(i));const s=e;return s.loadSpan3dPolesWithWeight(this._bcurve.packedData,t,1),s.saturateInPlace(this._bcurve.knots,t)?s:void 0}dispatchToGeometryHandler(t){return t.handleBSplineCurve3d(this)}extendRange(t,e){const i=this._bcurve.packedData,s=i.length-2;if(e)for(let n=0;n<s;n+=3)t.extendTransformedXYZ(e,i[n],i[n+1],i[n+2]);else for(let e=0;e<s;e+=3)t.extendXYZ(i[e],i[e+1],i[e+2])}}class Ve{}function Le(t){return t}function Ue(t,e,i){return Ze(e,(e=>i(t,e)))}function Ze(t,e){let i=0,s=t.length;for(;i<s;){const n=Math.floor((i+s)/2),r=e(t[n]);if(0===r)return{index:n,equal:!0};r<0?s=n:i=n+1}return{index:i,equal:!1}}Ve.oneMillimeter=.001,Ve.oneCentimeter=.01,Ve.oneMeter=1,Ve.oneKilometer=1e3,Ve.diameterOfEarth=12742*Ve.oneKilometer,Ve.circumferenceOfEarth=40075*Ve.oneKilometer,Ve.earthRadiusWGS84={polar:6356752.3142,equator:6378137},function(t){t[t.Allow=0]="Allow",t[t.Retain=1]="Retain",t[t.Replace=2]="Replace"}(C||(C={}));class qe{constructor(t,e=!1,i=Le){this._array=[],this._compare=t,this._clone=i,"boolean"==typeof e&&(e=e?C.Allow:C.Retain),this._duplicatePolicy=e}get length(){return this._array.length}get isEmpty(){return 0===this.length}[Symbol.iterator](){return this._array[Symbol.iterator]()}indexOf(t){const e=this.lowerBound(t);return e.equal?e.index:-1}contains(t){return-1!==this.indexOf(t)}findEqual(t){const e=this.indexOf(t);return-1!==e?this._array[e]:void 0}findEquivalent(t){const e=this.indexOfEquivalent(t);return-1!==e?this._array[e]:void 0}indexOfEquivalent(t){const e=Ze(this._array,(e=>0-t(e)));return e.equal?e.index:-1}get(t){return t<this.length?this._array[t]:void 0}forEach(t){for(let e=0;e<this.length;e++)t(this._array[e])}slice(t,e){const i=new qe(this._compare,this._duplicatePolicy,this._clone);return i._array=this._array.slice(t,e),i}lowerBound(t){return Ue(t,this._array,this._compare)}_clear(){this._array.length=0}_extractArray(){const t=this._array;return this._array=[],t}_insert(t,e){const i=this.lowerBound(t);if(i.equal)switch(this._duplicatePolicy){case C.Retain:return i.index;case C.Replace:return this._array[i.index]=this._clone(t),e&&e(t),i.index}return this._array.splice(i.index,0,this._clone(t)),void 0!==e&&e(t),i.index}_remove(t){const e=this.lowerBound(t);return e.equal?(this._array.splice(e.index,1),e.index):-1}}class We extends qe{constructor(t,e=!1,i=Le){super(t,e,i)}clear(){this._clear()}extractArray(){return this._extractArray()}insert(t,e){return this._insert(t,e)}remove(t){return this._remove(t)}slice(t,e){const i=new We(this._compare,this._duplicatePolicy,this._clone);return i._array=this._array.slice(t,e),i}}class Ge{constructor(t,e=Le){this._array=new We(t,!1,e)}get size(){return this._array.length}has(t){return-1!==this._array.indexOf(t)}[Symbol.iterator](){return this._array[Symbol.iterator]()}}class He extends Ge{constructor(t,e=Le){super(t,e)}clear(){this._array.clear()}add(t){return this._array.insert(t),this}delete(t){return-1!==this._array.remove(t)}}class Je{constructor(){}announceUnexpected(t,e){}announceCurvePrimitive(t,e=-1){}announcePath(t,e=-1){let i=0;for(const e of t.children)this.announceCurvePrimitive(e,i++)}announceLoop(t,e=-1){let i=0;for(const e of t.children)this.announceCurvePrimitive(e,i++)}announceParityRegion(t,e=-1){let i=0;for(const e of t.children)this.announceLoop(e,i++)}announceUnionRegion(t,e=-1){let i=0;for(const e of t.children)e.announceToCurveProcessor(this,i++)}announceBagOfCurves(t,e=-1){for(const e of t.children)e instanceof ae?this.announceCurvePrimitive(e):e.announceToCurveProcessor(this)}}class Qe extends Je{constructor(){super(),this._stack=[]}enter(t){this._stack.push(t)}leave(){return this._stack.pop()}announceUnexpected(t,e){}announceCurvePrimitive(t,e=-1){}announcePath(t,e=-1){this.enter(t),super.announcePath(t,e),this.leave()}announceLoop(t,e=-1){this.enter(t),super.announceLoop(t,e),this.leave()}announceParityRegion(t,e=-1){this.enter(t);let i=0;for(const e of t.children)this.announceLoop(e,i++);this.leave()}announceUnionRegion(t,e=-1){this.enter(t),super.announceUnionRegion(t,e),this.leave()}announceBagOfCurves(t,e=-1){this.enter(t);let i=0;for(const e of t.children)e instanceof ae?this.announceCurvePrimitive(e,i++):e.announceToCurveProcessor(this);this.leave()}}class Ke extends Qe{constructor(t){super(),this._transform=t,this._result=void 0}static clone(t,e){const i=new Ke(e);return t.announceToCurveProcessor(i),i._result}enter(t){t instanceof si&&super.enter(t.cloneEmptyPeer())}leave(){const t=super.leave();return t&&(0===this._stack.length?this._result=t:this._stack[this._stack.length-1].tryAddChild(t)),t}doClone(t){return this._transform?t.cloneTransformed(this._transform):t.clone()}announceCurvePrimitive(t,e){const i=this.doClone(t);if(void 0!==i&&this._stack.length>0){const t=this._stack[this._stack.length-1];if(t instanceof ni||t instanceof ri)if(Array.isArray(i))for(const e of i)t.tryAddChild(e);else t.tryAddChild(i)}}}class je extends Ke{constructor(){super(void 0)}doClone(t){if(t instanceof Me&&t.numPoints()>1){const e=t.packedPoints,i=e.length,s=[];for(let t=0;t+1<i;t++)s.push(Ce.createCapture(e.getPoint3dAtUncheckedPointIndex(t),e.getPoint3dAtUncheckedPointIndex(t+1)));return s}return t.clone()}static clone(t){const e=new je;return t.announceToCurveProcessor(e),e._result}}class $e extends Qe{constructor(){super(),this.numLineSegment=0,this.numLineString=0,this.numOther=0}static hasNonLinearPrimitives(t){const e=new $e;return t.announceToCurveProcessor(e),e.numOther>0}announceCurvePrimitive(t,e){t instanceof Ce?this.numLineSegment++:t instanceof Me?this.numLineString++:this.numOther++}}class ti extends Qe{constructor(){super(),this.maxGap=0}static maxGap(t){const e=new ti;return t.announceToCurveProcessor(e),e.maxGap}announceCurvePrimitive(t,e){if(this._stack.length>0){const i=this._stack[this._stack.length-1];if(i instanceof ni){const s=i.cyclicCurvePrimitive(e+1);void 0!==t&&void 0!==s&&(this.maxGap=Math.max(this.maxGap,t.endPoint().distance(s.startPoint())))}}}}class ei extends Je{constructor(){super(),this._sum=0}static sumLengths(t){const e=new ei;return t.announceToCurveProcessor(e),e._sum}announceCurvePrimitive(t,e){this._sum+=t.curveLength()}}class ii extends Je{constructor(t){super(),this.numFail=0,this.numOK=0,this.transform=t}static tryTransformInPlace(t,e){const i=new ii(e);return t.announceToCurveProcessor(i),0===i.numFail}announceCurvePrimitive(t,e){t.tryTransformInPlace(this.transform)?this.numOK++:this.numFail++}}class si extends Ot{constructor(){super(...arguments),this.geometryCategory="curveCollection",this.isInner=!1}sumLengths(){return ei.sumLengths(this)}closestPoint(t,e=!1,i){let s;const n=new vt;if(void 0!==this.children)for(const e of this.children)e.closestPoint(t,!1,n)&&(s=i=vt.chooseSmallerA(s,n).clone(i));return s}maxGap(){return ti.maxGap(this)}checkForNonLinearPrimitives(){return $e.hasNonLinearPrimitives(this)}tryTransformInPlace(t){return ii.tryTransformInPlace(this,t)}clone(){return Ke.clone(this)}cloneTransformed(t){return Ke.clone(this,t)}cloneWithExpandedLineStrings(){return je.clone(this)}collectCurvePrimitivesGo(t,e,i=!1){if(this.children)for(const s of this.children)(s instanceof ae||s instanceof si)&&s.collectCurvePrimitivesGo(t,e,i)}collectCurvePrimitives(t,e=!1,i=!1){const s=void 0===t?[]:t;return this.collectCurvePrimitivesGo(s,e,i),s}get isAnyRegionType(){return 2===this.dgnBoundaryType()||4===this.dgnBoundaryType()||5===this.dgnBoundaryType()}isAnyRegion(){return this.isAnyRegionType}get isOpenPath(){return 1===this.dgnBoundaryType()}isPath(){return this.isOpenPath}get isClosedPath(){return 2===this.dgnBoundaryType()}isLoop(){return this.isClosedPath}extendRange(t,e){const i=this.children;if(i)for(const s of i)s.extendRange(t,e)}static createCurveLocationDetailOnAnyCurvePrimitive(t,e=.5){if(t){if(t instanceof ae)return vt.createCurveEvaluatedFraction(t,e);if(t instanceof si&&void 0!==t.children)for(const i of t.children){const t=this.createCurveLocationDetailOnAnyCurvePrimitive(i,e);if(t)return t}}}projectedParameterRange(t,e){return Ee.findExtremeFractionsAlongDirection(this,t,e)}}class ni extends si{constructor(){super(),this._curves=[]}get children(){return this._curves}startPoint(t){const e=this.getChild(0);return e?e.fractionToPoint(0,t):void 0}endPoint(t){const e=this.getChild(this._curves.length-1);return e?e.fractionToPoint(1,t):void 0}cyclicCurvePrimitive(t,e=!0){const i=this.children.length;if(0!==i){if(t>=0&&t<i)return this.children[t];if(e){const e=Q.modulo(t,i);return this.children[e]}}}getPackedStrokes(t){const e=this.cloneStroked(t);if(e instanceof ni){const t=e.children;if(1===t.length){const e=t[0];if(e instanceof Me)return e.packedPoints}}}tryAddChild(t){return!!(t&&t instanceof ae)&&(this._curves.push(t),!0)}getChild(t){if(t<this._curves.length)return this._curves[t]}extendRange(t,e){for(const i of this._curves)i.extendRange(t,e)}reverseChildrenInPlace(){for(const t of this._curves)t.reverseInPlace();this._curves.reverse()}childIndex(t,e){for(let e=0;e<this._curves.length;e++)if(this._curves[e]===t)return e;if(e)for(let e=0;e<this._curves.length;e++){const i=this._curves[e];if(i instanceof me&&i.proxyCurve===t)return e}}primitiveIndexAndFractionToCurveLocationDetailPointAndDerivative(t,e,i=!1,s){const n=this.cyclicCurvePrimitive(t,i);if(n)return vt.createCurveEvaluatedFractionPointAndDerivative(n,e,s)}}class ri extends si{isSameGeometryClass(t){return t instanceof ri}constructor(){super(),this.curveCollectionType="bagOfCurves",this._children=[]}get children(){return this._children}static create(...t){const e=new ri;for(const i of t)e.tryAddChild(i);return e}dgnBoundaryType(){return 0}announceToCurveProcessor(t,e=-1){return t.announceBagOfCurves(this,e)}cloneStroked(t){const e=new ri;let i;for(i of this.children)if(i instanceof ae){const s=Me.create();i.emitStrokes(s,t),s&&e.children.push(s)}else if(i instanceof si){const s=i.cloneStroked(t);s&&e.children.push(s)}return e}closestPoint(t,e=!1,i){let s;const n=new vt;if(void 0!==this.children)for(const r of this.children)r.closestPoint(t,e,n)&&(s=i=vt.chooseSmallerA(s,n).clone(i));return s}cloneEmptyPeer(){return new ri}tryAddChild(t){return t&&this._children.push(t),!0}getChild(t){if(t<this._children.length)return this._children[t]}dispatchToGeometryHandler(t){return t.handleBagOfCurves(this)}}class oi extends ni{isSameGeometryClass(t){return t instanceof oi}announceToCurveProcessor(t,e=-1){return t.announcePath(this,e)}constructor(){super(),this.curveCollectionType="path"}static create(...t){const e=new oi;for(const i of t)i instanceof li?e.children.push(...i.path.children):i instanceof ae?e.children.push(i):Array.isArray(i)&&i.length>0&&i[0]instanceof j&&e.children.push(Me.create(i));return e}static createArray(t){return this.create(...t)}cloneStroked(t){const e=Me.create();for(const i of this.children)i.emitStrokes(e,t);return oi.create(e)}closestPoint(t,e=!1,i){let s;const n=new vt;if(void 0!==this.children)for(let r=0;r<this.children.length;r++){const o=this.children[r],a=0===r?ie.resolveVariantCurveExtendParameterToCurveExtendMode(e,0):S.None,c=r===this.children.length-1?ie.resolveVariantCurveExtendParameterToCurveExtendMode(e,1):S.None;o.closestPoint(t,[a,c],n)&&(s=i=vt.chooseSmallerA(s,n).clone(i))}return s}dgnBoundaryType(){return 1}cloneEmptyPeer(){return new oi}dispatchToGeometryHandler(t){return t.handlePath(this)}}class ai{constructor(t,e,i,s,n,r){this.childFraction0=t,this.childFraction1=e,this.chainDistance0=i,this.chainDistance1=s,this.childCurve=n,this.range=r,this.a=0}containsChainDistance(t){return t>=this.chainDistance0&&t<=this.chainDistance1}quickMinDistanceToChildCurve(t){if(this.range)return this.range.distanceToPoint(t);const e=this.childCurve.closestPoint(t,!1);return e?e.a:0}static collectSortedQuickMinDistances(t,e){const i=[];for(const s of t)s.a=s.quickMinDistanceToChildCurve(e),i.push(s);return i.sort(((t,e)=>t.a-e.a)),i}containsChildCurveAndChildFraction(t,e){return this.childCurve===t&&e>=this.childFraction0&&e<=this.childFraction1}chainDistanceToInterpolatedChildFraction(t){return Q.inverseInterpolate(this.childFraction0,this.chainDistance0,this.childFraction1,this.chainDistance1,t,this.childFraction0)}chainDistanceToAccurateChildFraction(t,e){return this.childCurve.moveSignedDistanceFromFraction(this.childFraction0,t-this.chainDistance0,e??!1).fraction}fractionScaleFactor(t){return t*(this.childFraction1-this.childFraction0)/(this.chainDistance1-this.chainDistance0)}reverseFractionsAndDistances(t){const e=this.childFraction0,i=this.childFraction1,s=this.chainDistance0,n=this.chainDistance1;this.childFraction0=1-i,this.childFraction1=1-e,this.chainDistance0=t-n,this.chainDistance1=t-s}childFractionTChainDistance(t){return this.childFractionToChainDistance(t)}childFractionToChainDistance(t){let e=this.childCurve.curveLengthBetweenFractions(this.childFraction0,t);return t<this.childFraction0&&(e=-e),this.chainDistance0+e}}class ci{constructor(){this._accumulatedDistance=0,this._fragments=[]}startParentCurvePrimitive(t){}startCurvePrimitive(t){}endParentCurvePrimitive(t){}endCurvePrimitive(t){}announcePointTangent(t,e,i){}announceSegmentInterval(t,e,i,s,n,r){const o=e.clone(),a=i.clone();let c=this._accumulatedDistance;if(s<=1)this._accumulatedDistance+=e.distance(i),this._fragments.push(new ai(n,r,c,this._accumulatedDistance,t,ut.create(o,a)));else{let l;for(let h=1,d=n;h<=s;h++,d=l)l=Q.interpolate(n,h/s,r),e.interpolate(l,i,a),c=this._accumulatedDistance,this._accumulatedDistance+=Math.abs(l-d)*e.distance(i),this._fragments.push(new ai(d,l,c,this._accumulatedDistance,t,ut.create(o,a))),o.setFrom(a)}}announceIntervalForUniformStepStrokes(t,e,i,s){let n,r,o;for(let a=1,c=i;a<=e;a++,c=n){n=Q.interpolate(i,a/e,s),r=t.curveLengthBetweenFractions(c,n),o=this._accumulatedDistance,this._accumulatedDistance+=r;const l=t.rangeBetweenFractions(c,n);this._fragments.push(new ai(c,n,o,this._accumulatedDistance,t,l))}}needPrimaryGeometryForStrokes(){return!0}static createPathFragmentIndex(t,e){const i=new ci;for(const s of t.children)s.emitStrokableParts(i,e);return i._fragments}}class li extends ae{isSameGeometryClass(t){return t instanceof li}constructor(t,e){super(),this.curvePrimitiveType="curveChainWithDistanceIndex",this._path=t instanceof oi?t:oi.create(...t.children),this._fragments=e,this._totalLength=e.length>0?e[e.length-1].chainDistance1:0}cloneTransformed(t,e){const i=this._path.clone();if(i.tryTransformInPlace(t))return li.createCapture(i,e)}get path(){return this._path}get fragments(){return this._fragments}clone(t){const e=this._path.clone();return li.createCapture(e,t)}clonePartialCurve(t,e,i){const s=t instanceof vt,n=e instanceof vt;let r=s?t.fraction:t,o=n?e.fraction:e;if(r===o)return;const a=r>o;a&&([r,o]=[o,r]);const c=r*this._totalLength,l=o*this._totalLength,h=this.chainDistanceToFragment(c,!0);if(void 0===h)return;const d=this.chainDistanceToFragment(l,!0);if(void 0===d)return;const u=this._path.childIndex(h.childCurve,!0);if(void 0===u)return;const f=this._path.childIndex(d.childCurve,!0);if(void 0===f)return;const g=s&&t.childDetail?t.childDetail.fraction:h.chainDistanceToAccurateChildFraction(c,!0),p=n&&e.childDetail?e.childDetail.fraction:d.chainDistanceToAccurateChildFraction(l,!0),m=oi.create(),x=(t,e,i,s)=>{if(e===i)return!1;let n;return 0===e&&1===i?(n=t.clone(),s&&n.reverseInPlace()):n=s?t.clonePartialCurve(i,e):t.clonePartialCurve(e,i),!!n&&(m.children.push(n),!0)};if(h.childCurve===d.childCurve)return x(h.childCurve,g,p,a)?li.createCapture(m,i):void 0;x(this._path.children[u],g,1,a);for(let t=u+1;t<f;t++)x(this._path.children[t],0,1,a);return x(this._path.children[f],0,p,a),a&&m.children.reverse(),li.createCapture(m,i)}isInPlane(t){for(const e of this._path.children)if(!e.isInPlane(t))return!1;return!0}startPoint(t){const e=this._path.cyclicCurvePrimitive(0);return e?e.startPoint(t):j.createZero(t)}endPoint(t){const e=this._path.cyclicCurvePrimitive(-1);return e?e.endPoint(t):j.createZero(t)}emitStrokes(t,e){for(const i of this._path.children)i.emitStrokes(t,e)}emitStrokableParts(t,e){for(const i of this._path.children)i.emitStrokableParts(t,e)}computeStrokeCountForOptions(t){let e=0;for(const i of this._path.children)e+=i.computeStrokeCountForOptions(t);return e}collectCurvePrimitivesGo(t,e=!1,i=!1){if(e)for(const s of this._path.children)s.collectCurvePrimitivesGo(t,e,i);else t.push(this)}computeAndAttachRecursiveStrokeCounts(t,e){const i=Nt.createWithCurvePrimitiveAndOptionalParent(this,e);for(const e of this._path.children)e.computeAndAttachRecursiveStrokeCounts(t,i);ae.installStrokeCountMap(this,i,e)}dispatchToGeometryHandler(t){return t.handleCurveChainWithDistanceIndex(this)}extendRange(t,e){this._path.extendRange(t,e)}curveLengthBetweenFractions(t,e){return Math.abs(e-t)*this._totalLength}static flattenNestedChains(t){if(-1===t.children.findIndex((t=>t instanceof li)))return t;const e=t.clone(),i=e.children.flatMap((t=>t instanceof li?t.path.children:[t]));return e.children.splice(0,1/0,...i),e}static createCapture(t,e){t=this.flattenNestedChains(t);const i=ci.createPathFragmentIndex(t,e);return new li(t,i)}chainDistanceToFragment(t,e=!1){const i=this.chainDistanceToFragmentIndex(t,e);if(void 0!==i)return this._fragments[i]}chainDistanceToFragmentIndex(t,e=!1){const i=this._fragments.length,s=this._fragments;if(i>0){if(t<0)return e?0:void 0;if(t>this._totalLength)return e?i-1:void 0;for(let e=0;e<i;e++)if(s[e].containsChainDistance(t))return e}}chainDistanceToChainFraction(t){return t/this._totalLength}curveAndChildFractionToFragment(t,e){const i=this._fragments.length,s=this._fragments;if(i>0){if(e<0)return s[0];if(e>1)return s[i-1];for(const i of s)if(i.containsChildCurveAndChildFraction(t,e))return i}}curveLength(){return this._totalLength}quickLength(){return this._totalLength}fractionToPoint(t,i){const s=t*this._totalLength,n=this.chainDistanceToFragment(s,!0);if(n){const t=n.chainDistanceToAccurateChildFraction(s,!0);return n.childCurve.fractionToPoint(t,i)}return e(!1),this._fragments[0].childCurve.fractionToPoint(0,i)}fractionToPointAndDerivative(t,e){const i=t*this._totalLength,s=this.chainDistanceToFragment(i,!0),n=s.chainDistanceToAccurateChildFraction(i,!0);e=s.childCurve.fractionToPointAndDerivative(n,e);const r=this._totalLength/e.direction.magnitude();return e.direction.scaleInPlace(r),e}fractionToPointAndUnitTangent(t,e){const i=t*this._totalLength,s=this.chainDistanceToFragment(i,!0),n=s.chainDistanceToAccurateChildFraction(i,!0);return(e=s.childCurve.fractionToPointAndDerivative(n,e)).direction.normalizeInPlace(),e}fractionToPointAnd2Derivatives(t,e){const i=t*this._totalLength,s=this.chainDistanceToFragment(i,!0),n=s.chainDistanceToAccurateChildFraction(i,!0);if(!(e=s.childCurve.fractionToPointAnd2Derivatives(n,e)))return;const r=e.vectorU.magnitude(),o=r*r,a=e.vectorU.dotProduct(e.vectorV);e.vectorV.addScaledInPlace(e.vectorU,-a/o);const c=this._totalLength/r;return e.vectorU.scaleInPlace(c),e.vectorV.scaleInPlace(c*c),e}tryTransformInPlace(t){let e=0;for(const i of this._path.children)i.tryTransformInPlace(t)||e++;return 0===e}reverseInPlace(){this._path.reverseChildrenInPlace();for(const t of this._fragments)t.reverseFractionsAndDistances(this._totalLength);this._fragments.reverse()}isAlmostEqual(t){return t instanceof li&&Q.isSameCoordinate(this._totalLength,t._totalLength)&&this._path.isAlmostEqual(t._path)}moveSignedDistanceFromFraction(t,e,i,s){const n=t*this._totalLength+e,r=this.chainDistanceToFragment(n,!0),o=r.childCurve.moveSignedDistanceFromFraction(r.childFraction0,n-r.chainDistance0,i,s?.childDetail),a=t+e/this._totalLength,c=vt.createConditionalMoveSignedDistance(i,this,t,a,e,s);return c.childDetail=o,c}static getClosestPointTestCounts(t=!0){const e={numCalls:this._numCalls,numTested:this._numTested,numAssigned:this._numAssigned,numCandidate:this._numCandidate};return t&&(this._numTested=this._numAssigned=this._numCandidate=0),e}closestPoint(t,e,i){let s,n=Number.MAX_VALUE;if(1===this.path.children.length)s=this.path.children[0].closestPoint(t,e);else{const i=ai.collectSortedQuickMinDistances(this._fragments,t),r=[ie.resolveVariantCurveExtendParameterToCurveExtendMode(e,0),S.None],o=[S.None,ie.resolveVariantCurveExtendParameterToCurveExtendMode(e,1)],a=this._fragments[0],c=this._fragments[this._fragments.length-1];let l;li._numCalls++,li._numCandidate+=i.length;for(const e of i){if(e.a>n)break;li._numTested++,l=e.childCurve.closestPoint(t,e===a?r:e===c&&o,l),l&&l.a<n&&(n=l.a,s=l.clone(s),li._numAssigned++)}}if(s)return this.computeChainDetail(s,i)}constructOffsetXY(t){const e=we.create(t),i=[];for(const t of this.collectCurvePrimitives(void 0,!0,!0)){const s=t.constructOffsetXY(e);void 0!==s&&(s instanceof ae?i.push(s):Array.isArray(s)&&s.forEach((t=>i.push(t))))}return i}projectedParameterRange(t,e){return Ee.findExtremeFractionsAlongDirection(this,t,e)}computeChainDetail(t,e){if(!t.curve)return;const i=this.curveAndChildFractionToFragment(t.curve,t.fraction);if(i){const s=i.childFractionToChainDistance(t.fraction),n=this.chainDistanceToChainFraction(s),r=vt.createCurveFractionPoint(this,n,t.point,e);return r.childDetail=t,r.a=t.a,r}}static convertChildDetailToChainDetail(t,e,i,s,n){for(let n=e;n<t.length;++n){const e=t[n];if(i){const t=i.computeChainDetail(e.detailA);t&&(e.detailA=t)}if(s){const t=s.computeChainDetail(e.detailB);t&&(e.detailB=t)}}return n&&(t=Pt.removeAdjacentDuplicates(t,e)),t}}li._numCalls=0,li._numTested=0,li._numAssigned=0,li._numCandidate=0;class hi extends ni{isSameGeometryClass(t){return t instanceof hi}constructor(){super(),this.curveCollectionType="loop",this.isInner=!1}static create(...t){const e=new hi;for(const i of t)i instanceof li?e.children.push(...i.path.children):e.children.push(i);return e}static createArray(t){return this.create(...t)}static createPolygon(t){const e=Me.create(t);return e.addClosurePoint(),hi.create(e)}cloneStroked(t){const e=Me.create();for(const i of this.children)i.emitStrokes(e,t);return e.removeDuplicatePoints(),e.isPhysicallyClosed&&(e.popPoint(),e.addClosurePoint()),hi.create(e)}dgnBoundaryType(){return 2}announceToCurveProcessor(t,e=-1){return t.announceLoop(this,e)}cloneEmptyPeer(){return new hi}dispatchToGeometryHandler(t){return t.handleLoop(this)}}class di{constructor(t,e,i,s){this.loopA=t,this.curveA=e,this.loopB=i,this.curveB=s}setA(t,e){this.loopA=t,this.curveA=e}setB(t,e){this.loopB=t,this.curveB=e}}class ui extends Ae{setGeometryB(t){this._geometryB=t}constructor(t){super(),this.setGeometryB(t),this._maxDistanceSquared=Q.smallMetricDistanceSquared,this._results=[]}set maxDistanceToAccept(t){this._maxDistanceToAccept=t,void 0!==this._maxDistanceToAccept&&this._maxDistanceToAccept>0&&(this._maxDistanceSquared=this._maxDistanceToAccept*this._maxDistanceToAccept)}get maxDistanceToAccept(){return this._maxDistanceToAccept}get isMaxDistanceSet(){return void 0!==this._maxDistanceToAccept&&this._maxDistanceToAccept>0}resetGeometry(t){this.setGeometryB(t)}acceptFraction(t,e=1e-12){return!(t<-e||t>1+e)}grabPairedResults(t=!1){const e=this._results;return t&&(this._results=[]),e}testAndRecordPointPairApproach(t,e,i,s,n,r,o){if(i.distanceSquaredXY(r)<this._maxDistanceSquared){const a=vt.createCurveFractionPoint(t,e,i),c=vt.createCurveFractionPoint(s,n,r),l=Pt.createCapture(a,c);o&&l.swapDetails(),this._results.push(l)}}recordPointWithLocalFractions(t,e,i,s,n,r,o,a,c,l){let h,d,u,f;const g=void 0!==l&&l.detailA.hasFraction1&&l.detailB.hasFraction1;g?(h=Q.interpolate(i,l.detailA.fraction,s),d=Q.interpolate(o,l.detailB.fraction,a),u=Q.interpolate(i,l.detailA.fraction1,s),f=Q.interpolate(o,l.detailB.fraction1,a)):(h=u=Q.interpolate(i,t,s),d=f=Q.interpolate(o,n,a));const p=this._results.length;if(p>0&&!g){const t=this._results[p-1].detailA,i=this._results[p-1].detailB;if(c){if(i.isSameCurveAndFraction({curve:e,fraction:h})&&t.isSameCurveAndFraction({curve:r,fraction:d}))return}else if(t.isSameCurveAndFraction({curve:e,fraction:h})&&i.isSameCurveAndFraction({curve:r,fraction:d}))return}const m=vt.createCurveFractionPoint(e,h,e.fractionToPoint(h)),x=vt.createCurveFractionPoint(r,d,r.fractionToPoint(d));if(g)m.captureFraction1Point1(u,e.fractionToPoint(u)),x.captureFraction1Point1(f,r.fractionToPoint(f));else{if(m.point.distanceSquaredXY(x.point)>this._maxDistanceSquared)return;m.setIntervalRole(P.isolated),x.setIntervalRole(P.isolated)}c?this._results.push(new Pt(x,m)):this._results.push(new Pt(m,x))}capturePairWithLocalFractions(t,e,i,s,n,r,o,a){const c=Q.interpolate(i,t.detailA.fraction,s),l=Q.interpolate(r,t.detailB.fraction,o),h=this._results.length;if(h>0){const t=this._results[h-1].detailA,i=this._results[h-1].detailB;if(a){if(i.isSameCurveAndFraction({curve:e,fraction:c})&&t.isSameCurveAndFraction({curve:n,fraction:l}))return}else if(t.isSameCurveAndFraction({curve:e,fraction:c})&&i.isSameCurveAndFraction({curve:n,fraction:l}))return}vt.createCurveEvaluatedFraction(e,c,t.detailA),vt.createCurveEvaluatedFraction(n,l,t.detailB),t.detailA.setIntervalRole(P.isolated),t.detailB.setIntervalRole(P.isolated),a&&t.swapDetails(),this._results.push(t)}recordPairs(t,e,i,s){if(void 0!==i)for(const n of i)this.recordPointWithLocalFractions(n.detailA.fraction,t,0,1,n.detailB.fraction,e,0,1,s,n)}captureDetailPair(t,e,i){t&&e&&(i?this._results.push(Pt.createCapture(e,t)):this._results.push(Pt.createCapture(t,e)))}static updatePointToSegmentDistance(t,e,i,s,n,r,o){let a=!1;n<0?n=0:n>1&&(n=1),this._workPointB=i.interpolate(n,s,this._workPointB);const c=this._workPointB.distanceSquaredXY(e);return c<=Math.min(r,o.detailA.a)&&(o.detailA.setFP(t,e,void 0,c),o.detailB.setFP(n,this._workPointB,void 0,c),a=!0),a}static segmentSegmentBoundedApproach(t,e,i,s,n){const r=e.x-t.x,o=e.y-t.y,a=s.x-i.x,c=s.y-i.y,l=i.x-t.x,h=i.y-t.y,d=s.x-t.x,u=s.y-t.y,f=i.x-e.x,g=i.y-e.y,p=Q.crossProductXYXY(r,o,l,h),m=Q.crossProductXYXY(r,o,d,u),x=-Q.crossProductXYXY(a,c,l,h),_=-Q.crossProductXYXY(a,c,f,g);if(p*m<0&&x*_<0){const n=-x/(_-x),r=-p/(m-p);return Pt.createCapture(vt.createCurveFractionPoint(void 0,n,t.interpolate(n,e)),vt.createCurveFractionPoint(void 0,r,i.interpolate(r,s)))}const y=new Pt;y.detailA.a=2*n;let v=!1;const P=Q.hypotenuseSquaredXY(r,o);if(p*p<=n*P){const s=Q.dotProductXYXY(r,o,l,h)/P;this.updatePointToSegmentDistance(0,i,t,e,s,n,y)&&(v=!0)}if(m*m<=n*P){const i=Q.dotProductXYXY(r,o,d,u)/P;this.updatePointToSegmentDistance(1,s,t,e,i,n,y)&&(v=!0)}const A=Q.hypotenuseSquaredXY(a,c);if(x*x<=n*A){const e=-Q.dotProductXYXY(a,c,l,h)/A;this.updatePointToSegmentDistance(0,t,i,s,e,n,y)&&(v=!1)}if(_*_<=n*A){const t=-Q.dotProductXYXY(a,c,f,g)/A;this.updatePointToSegmentDistance(1,e,i,s,t,n,y)&&(v=!1)}if(!(y.detailA.a>n))return v&&y.swapDetails(),y}testAndRecordFractionalPairApproach(t,e,i,s,n,r,o,a,c){const l=t.fractionToPoint(e),h=t.fractionToPoint(i),d=n.fractionToPoint(r),u=n.fractionToPoint(o);this.testAndRecordPointPairApproach(t,e,l,n,r,d,c),this.testAndRecordPointPairApproach(t,i,h,n,r,d,c),this.testAndRecordPointPairApproach(t,e,l,n,o,u,c),this.testAndRecordPointPairApproach(t,i,h,n,o,u,c),a&&(this.testAndRecordProjection(t,e,l,n,r,o,c),this.testAndRecordProjection(t,i,h,n,r,o,c)),s&&(this.testAndRecordProjection(n,r,d,t,e,i,!c),this.testAndRecordProjection(n,o,u,t,e,i,!c))}getPointCurveClosestApproachXYNewton(t,i){t instanceof Ti||t instanceof Ce||e(!1,"getPointCurveClosestApproachXYNewton only supports Arc3d and LineSegment");const s=[.2,.4,.6,.8],n=new jt(t,i),r=new Wt(n,100);let o,a,c=Q.largeCoordinateResult;for(const e of s)if(r.setX(e),r.runIterations()){const e=r.getX();if(this.acceptFraction(e)){const s=t.fractionToPoint(e),n=s.distanceSquaredXY(i);n<c&&(c=n,o=e,a=s)}}if(o&&a)return vt.createCurveFractionPoint(t,o,a)}testAndRecordProjection(t,e,i,s,n,r,o){let a;if(s instanceof Me){const t=s.globalFractionToSegmentIndexAndLocalFraction(n<=r?n:r),e=t.fraction<.999999?t.index:t.index+1,o=s.getIndexedSegment(e);o&&(a=this.getPointCurveClosestApproachXYNewton(o,i))&&Me.convertLocalToGlobalDetail(a,e,s.numEdges(),s)}else a=this.getPointCurveClosestApproachXYNewton(s,i);a&&Q.restrictToInterval(a.fraction,n,r)===a.fraction&&this.testAndRecordPointPairApproach(t,e,i,s,a.fraction,a.point,o)}computeSegmentSegment3D(t,e,i,s,n,r,o,a,c,l,h){const d=ui.segmentSegmentBoundedApproach(e,s,o,c,this._maxDistanceSquared);d&&(d.detailA.setCurve(t),d.detailB.setCurve(r),this.capturePairWithLocalFractions(d,t,i,n,r,a,l,h))}dispatchSegmentSegment(t,e,i,s,n,r,o,a,c,l,h){this.computeSegmentSegment3D(t,e,i,s,n,r,o,a,c,l,h)}allPerpendicularsSegmentArcBounded(t,e,i,s,n,r,o=!1){const a=r.vector0.crossProductStartEndXY(e,s),c=r.vector90.crossProductStartEndXY(e,s),l=Math.atan2(c,a);for(const a of[l,l+Math.PI]){const c=r.radiansToPoint(a),l=r.sweep.radiansToSignedPeriodicFraction(a);if(this.acceptFraction(l)){const a=Mt.lineSegment3dXYClosestPointUnbounded(e,s,c);void 0!==a&&this.acceptFraction(a)&&this.recordPointWithLocalFractions(a,t,i,n,l,r,0,1,o)}}}dispatchSegmentArc(t,e,i,s,n,r,o){let a=!1;const c=r.toTransformedVectors(),l=e,h=s,d=Q.tripleProductXYW(l,1,h,1,c.center,1),u=Q.tripleProductXYW(l,1,h,1,c.vector0,0),f=Q.tripleProductXYW(l,1,h,1,c.vector90,0),g=new It(2),p=new It(2),m=new It(2),x=wt.appendImplicitLineUnitCircleIntersections(d,u,f,g,p,m);for(let e=0;e<x;e++){const s=c.center.plus2Scaled(c.vector0,g.atUncheckedIndex(e),c.vector90,p.atUncheckedIndex(e)),d=c.sweep.radiansToSignedPeriodicFraction(m.atUncheckedIndex(e)),u=Mt.lineSegment3dXYClosestPointUnbounded(l,h,s);void 0!==u&&this.acceptFraction(u)&&this.acceptFraction(d)&&(this.recordPointWithLocalFractions(u,t,i,n,d,r,0,1,o),a=!0)}a||(this.testAndRecordFractionalPairApproach(t,i,n,!0,r,0,1,!0,o),this.allPerpendicularsSegmentArcBounded(t,e,i,s,n,r,o))}allPerpendicularsArcArcBounded(t,e,i=!1){const s=new $t(t,e),n=new Qt(s,100);for(let s=.05;s<1;s+=.1)for(let r=.05;r<1;r+=.1)if(n.setUV(s,r),n.runIterations()){const s=n.getU(),r=n.getV();this.acceptFraction(s)&&this.acceptFraction(r)&&this.recordPointWithLocalFractions(s,t,0,1,r,e,0,1,i)}}dispatchArcArc(t,e,i){const s=t.range(),n=e.range();s.expandInPlace(this._maxDistanceToAccept),n.intersectsRangeXY(s)&&(this.testAndRecordFractionalPairApproach(t,0,1,!0,e,0,1,!0,i),this.allPerpendicularsArcArcBounded(t,e,i))}dispatchArcBsplineCurve3d(t,e,i){const s=Me.create();e.emitStrokes(s),this.computeArcLineString(t,s,i)}dispatchBSplineCurve3dBSplineCurve3d(t,e,i){const s=Me.create();t.emitStrokes(s);const n=Me.create();e.emitStrokes(n),this.computeLineStringLineString(s,n,i)}dispatchLineStringBSplineCurve(t,e,i){const s=Me.create();e.emitStrokes(s),this.computeLineStringLineString(t,s,i)}dispatchSegmentBsplineCurve(t,e,i){const s=Me.create();e.emitStrokes(s),this.computeSegmentLineString(t,s,i)}computeSegmentLineString(t,e,i){const s=e.numPoints(),n=Q.safeDivideFraction(1,s-1,0),r=t.point0Ref,o=t.point1Ref,a=ui._workPointBB0,c=ui._workPointBB1;for(let l=0;l<s-1;++l){const h=l*n,d=l+1===s-1?1:(l+1)*n;e.packedPoints.getPoint3dAtUncheckedPointIndex(l,a),e.packedPoints.getPoint3dAtUncheckedPointIndex(l+1,c),this.dispatchSegmentSegment(t,r,0,o,1,e,a,h,c,d,i)}}computeArcLineString(t,e,i){const s=t.range(),n=e.range();if(s.expandInPlace(this._maxDistanceToAccept),!n.intersectsRangeXY(s))return;const r=ui._workPointBB0,o=ui._workPointBB1,a=e.numPoints();if(a>1){const s=1/(a-1);let n,c;n=0,e.pointAt(0,r);for(let l=1;l<a;l++,r.setFrom(o),n=c)e.pointAt(l,o),c=l*s,this.dispatchSegmentArc(e,r,n,o,c,t,!i)}}dispatchCurveCollection(t,e){const i=this._geometryB;if(i&&i.children&&i instanceof si){for(const s of i.children)this.resetGeometry(s),e(t);this._geometryB=i}}dispatchCurveChainWithDistanceIndex(t,i){if(!(this._geometryB&&this._geometryB instanceof li))return;t instanceof li&&e(!1,"call handleCurveChainWithDistanceIndex(geomA) instead");const s=this._results.length,n=this._geometryB;for(const e of n.path.children)this.resetGeometry(e),i(t);this.resetGeometry(n),this._results=li.convertChildDetailToChainDetail(this._results,s,void 0,n,!0)}handleLineSegment3d(t){if(this._geometryB instanceof Ce){const e=this._geometryB;this.dispatchSegmentSegment(t,t.point0Ref,0,t.point1Ref,1,e,e.point0Ref,0,e.point1Ref,1,!1)}else this._geometryB instanceof Me?this.computeSegmentLineString(t,this._geometryB,!1):this._geometryB instanceof Ti?this.dispatchSegmentArc(t,t.point0Ref,0,t.point1Ref,1,this._geometryB,!1):this._geometryB instanceof Be?this.dispatchSegmentBsplineCurve(t,this._geometryB,!1):this._geometryB instanceof si?this.dispatchCurveCollection(t,this.handleLineSegment3d.bind(this)):this._geometryB instanceof li&&this.dispatchCurveChainWithDistanceIndex(t,this.handleLineSegment3d.bind(this))}classifyBitsPointRangeXY(t,e,i){let s=0;return t<i.low.x?s=1:t>i.high.x&&(s=2),e<i.low.y?s|=4:e>i.high.y&&(s|=8),s}computeLineStringLineString(t,e,i){const s=t.range(),n=e.range();if(s.expandInPlace(this._maxDistanceToAccept),!n.intersectsRangeXY(s))return;let r,o;const a=ut.createNull(),c=ui._workPointAA0,l=ui._workPointAA1,h=ui._workPointBB0,d=ui._workPointBB1,u=t.numPoints(),f=e.numPoints();if(u>1&&f>1){const s=1/(u-1),g=1/(f-1);let p,m,x,_=0;t.pointAt(0,c);for(let y=1;y<u;y++,c.setFrom(l),_=p)if(p=y*s,m=0,t.pointAt(y,l),a.setNull(),a.extendPoint(c),a.extendPoint(l),a.expandInPlace(this._maxDistanceToAccept),a.intersectsRangeXY(n)){e.pointAt(0,h),r=this.classifyBitsPointRangeXY(h.x,h.y,a);for(let s=1;s<f;s++,h.setFrom(d),m=x,r=o)e.pointAt(s,d),o=this.classifyBitsPointRangeXY(d.x,d.y,a),x=s*g,r&o||this.dispatchSegmentSegment(t,c,_,l,p,e,h,m,d,x,i)}}}handleLineString3d(t){if(this._geometryB instanceof Me){const e=this._geometryB;this.computeLineStringLineString(t,e,!1)}else this._geometryB instanceof Ce?this.computeSegmentLineString(this._geometryB,t,!0):this._geometryB instanceof Ti?this.computeArcLineString(this._geometryB,t,!0):this._geometryB instanceof Be?this.dispatchLineStringBSplineCurve(t,this._geometryB,!1):this._geometryB instanceof si?this.dispatchCurveCollection(t,this.handleLineString3d.bind(this)):this._geometryB instanceof li&&this.dispatchCurveChainWithDistanceIndex(t,this.handleLineString3d.bind(this))}handleArc3d(t){this._geometryB instanceof Ce?this.dispatchSegmentArc(this._geometryB,this._geometryB.point0Ref,0,this._geometryB.point1Ref,1,t,!0):this._geometryB instanceof Me?this.computeArcLineString(t,this._geometryB,!1):this._geometryB instanceof Ti?this.dispatchArcArc(t,this._geometryB,!1):this._geometryB instanceof Be?this.dispatchArcBsplineCurve3d(t,this._geometryB,!1):this._geometryB instanceof si?this.dispatchCurveCollection(t,this.handleArc3d.bind(this)):this._geometryB instanceof li&&this.dispatchCurveChainWithDistanceIndex(t,this.handleArc3d.bind(this))}handleBSplineCurve3d(t){this._geometryB instanceof Ce?this.dispatchSegmentBsplineCurve(this._geometryB,t,!0):this._geometryB instanceof Me?this.dispatchLineStringBSplineCurve(this._geometryB,t,!0):this._geometryB instanceof Ti?this.dispatchArcBsplineCurve3d(this._geometryB,t,!0):this._geometryB instanceof Ye?this.dispatchBSplineCurve3dBSplineCurve3d(t,this._geometryB,!1):this._geometryB instanceof si?this.dispatchCurveCollection(t,this.handleBSplineCurve3d.bind(this)):this._geometryB instanceof li&&this.dispatchCurveChainWithDistanceIndex(t,this.handleBSplineCurve3d.bind(this))}handleCurveChainWithDistanceIndex(t){super.handleCurveChainWithDistanceIndex(t),this._results=li.convertChildDetailToChainDetail(this._results,0,t,void 0,!0)}handleBSplineCurve3dH(t){}}function fi(t,e){return Q.isAlmostEqualNumber(t,e,Q.smallFraction)?0:t<e?-1:1}function gi(t,e){return Q.isAlmostEqualNumber(t,e,Q.smallFraction)?0:t<e?1:-1}ui._workPointAA0=j.create(),ui._workPointAA1=j.create(),ui._workPointBB0=j.create(),ui._workPointBB1=j.create(),ui._workPointB=j.create();class pi{constructor(t,e,i,s){this._quadrant=t,this._fractions=e,this._interpolateStartTangent=i,this._interpolateEndTangent=s,this._averageAdded=!1}static create(t,e=[],i=!0,s=!0){return new pi(t,e,i,s)}get quadrant(){return this._quadrant}get fractions(){return this._fractions}set fractions(t){this._fractions=t}get interpolateStartTangent(){return this._interpolateStartTangent}set interpolateStartTangent(t){this._interpolateStartTangent=t}get interpolateEndTangent(){return this._interpolateEndTangent}set interpolateEndTangent(t){this._interpolateEndTangent=t}get averageAdded(){return 3===this._fractions.length&&this._averageAdded}set averageAdded(t){this._averageAdded=t}static getQuadrantRadians(t,e){return At.isRadiansInStartEnd(t,0,W.piOver2Radians)&&At.isRadiansInStartEnd(e,0,W.piOver2Radians)?{quadrant:1,angle0:0,angle1:W.piOver2Radians}:At.isRadiansInStartEnd(t,W.piOver2Radians,W.piRadians)&&At.isRadiansInStartEnd(e,W.piOver2Radians,W.piRadians)?{quadrant:2,angle0:W.piOver2Radians,angle1:W.piRadians}:At.isRadiansInStartEnd(t,W.piRadians,W.pi3Over2Radians)&&At.isRadiansInStartEnd(e,W.piRadians,W.pi3Over2Radians)?{quadrant:3,angle0:W.piRadians,angle1:W.pi3Over2Radians}:At.isRadiansInStartEnd(t,W.pi3Over2Radians,W.pi2Radians)&&At.isRadiansInStartEnd(e,W.pi3Over2Radians,W.pi2Radians)?{quadrant:4,angle0:W.pi3Over2Radians,angle1:W.pi2Radians}:void 0}static getQ1FractionalRange(t){const e=.5*Math.PI;let i=t.radiansToSignedPeriodicFraction(0),s=t.radiansToSignedPeriodicFraction(e);return t.isCCW||([i,s]=[s,i]),s<i&&(s+=1),ft.createXX(i,s)}reverse(){this._fractions.reverse(),[this._interpolateStartTangent,this._interpolateEndTangent]=[this._interpolateEndTangent,this._interpolateStartTangent]}}class mi{announceQuadrantBegin(t,e){return!0}announceArc(t,e,i,s){}announceQuadrantEnd(t,e){}}class xi extends mi{constructor(t){super(),this._ellipticalArc=t,this._maxPerpendicular=void 0}static create(t){return new xi(t)}get ellipticalArc(){return this._ellipticalArc}static computePrimitiveErrorXY(t,e,i,s){const n=new ui;n.maxDistanceToAccept=t.quickLength()/2;const r=void 0!==i&&void 0!==s,o=r?e.clonePartialCurve(i,s):e;let a;n.allPerpendicularsArcArcBounded(t,o);for(const t of n.grabPairedResults()){if(Q.isAlmostEqualEitherNumber(t.detailA.fraction,0,1,Q.smallFraction))continue;if(Q.isAlmostEqualEitherNumber(t.detailB.fraction,0,1,Q.smallFraction))continue;const n=t.detailA.point.distanceXY(t.detailB.point);(!a||a.detailA.a<n)&&(r&&(t.detailB.fraction=Q.interpolate(i,t.detailB.fraction,s),t.detailB.setCurve(e)),t.detailA.a=t.detailB.a=n,a=t)}return a}get maxPerpendicular(){return this._maxPerpendicular}set maxPerpendicular(t){this._maxPerpendicular=t}updateMaxPerpendicular(t,e,i){const s=xi.computePrimitiveErrorXY(t,this.ellipticalArc,e,i);s&&(!this.maxPerpendicular||this.maxPerpendicular.detailA.a<s.detailA.a)&&(this.maxPerpendicular=s)}announceArc(t,e,i,s){this.updateMaxPerpendicular(t,i,s)}}class _i extends mi{constructor(t,e,i,s){super(),this._fullEllipseXY=t,this._bracket0=e,this._f=i,this._bracket1=s,this._error0=this._error1=Q.largeCoordinateResult}static create(t,e,i,s){return new _i(t,e,i,s)}get fullEllipseXY(){return this._fullEllipseXY}get f(){return this._f}get isConverged(){return!!Q.isSmallMetricDistance(this._error0-this._error1)||!!Q.isSmallRelative(this._bracket0-this._bracket1)}announceQuadrantBegin(t,i){return e(1===t.quadrant),e(!i),e(4===t.fractions.length||3===t.fractions.length&&t.interpolateStartTangent),this._error0=this._error1=Q.largeCoordinateResult,!0}announceArc(t,e,i,s){if(Q.isAlmostEqualEitherNumber(this.f,i,s,0)){const e=xi.computePrimitiveErrorXY(t,this.fullEllipseXY,i,s);e&&(this.f===s?this._error0=e.detailA.a:this._error1=e.detailA.a)}}announceQuadrantEnd(t,e){if(Q.isLargeCoordinateResult(this._error0)||Q.isLargeCoordinateResult(this._error1))return;if(this.isConverged)return;const i=t.fractions.length;this._error0<this._error1?this._bracket0=this._f:this._bracket1=this._f,this._f=t.fractions[i-2]=Q.interpolate(this._bracket0,.5,this._bracket1)}}class yi extends mi{constructor(t,e){super(),this._fullEllipseXY=t,this._fractionRangeQ1=pi.getQ1FractionalRange(t.sweep),this._maxError=e>0?e:Ci.defaultMaxError,this._originalRefinementCount=0}static create(t,e){return new yi(t,e)}get fullEllipseXY(){return this._fullEllipseXY}get isRefined(){return void 0!==this._refinement&&0!==this._refinement.length&&this._originalRefinementCount<this._refinement.length}announceQuadrantBegin(t,i){e(1===t.quadrant),this._refinement=new We(i?gi:fi,!1);for(const e of t.fractions)this._fractionRangeQ1.containsX(e)&&this._refinement.insert(e);return 2<=(this._originalRefinementCount=this._refinement.length)}getPreviousFraction(t){if(void 0===this._refinement)return;const e=this._refinement.indexOf(t);return e>=1?this._refinement.get(e-1):void 0}announceArc(t,e,i,s){if(void 0===this._refinement)return;if(this._originalRefinementCount>2){const e=xi.computePrimitiveErrorXY(t,this.fullEllipseXY,i,s);if(!e||e.detailA.a<=this._maxError)return}const n=Q.interpolate(i,.5,s),r=Q.isAlmostEqualEitherNumber(i,this._fractionRangeQ1.low,this._fractionRangeQ1.high,0),o=Q.isAlmostEqualEitherNumber(s,this._fractionRangeQ1.low,this._fractionRangeQ1.high,0);r||void 0!==e||(e=this.getPreviousFraction(i));const a=void 0===e?[i,n,s]:[e,i,n,s],c=[pi.create(1,a,r,o)],l=_i.create(this.fullEllipseXY,i,n,s);let h=0;do{wi.processQuadrantFractions(this.fullEllipseXY,c,l)}while(h++<yi._maxIters&&!l.isConverged);this._refinement.insert(l.f)}announceQuadrantEnd(t,e){this._refinement&&(t.fractions=[...this._refinement])}getRefinedInteriorQ1Angles(t){if(t?t.length=0:t=[],this._refinement)for(const e of this._refinement)this._fractionRangeQ1.containsXOpen(e)&&t.push(this.fullEllipseXY.sweep.fractionToRadians(e));return t}}yi._maxIters=50;class vi{constructor(t,e){this._context=t,this._options=e}static create(t,e){return new vi(t,e)}computeRadiansStrictlyInsideQuadrant1(t){if(t||(t=[]),this._context.isValidEllipticalArc){const e=W.piOver2Radians/(this._options.numSamplesInQuadrant-1);for(let i=1;i<this._options.numSamplesInQuadrant-1;++i)t.push(i*e)}return t}}class Pi{constructor(t,e){this._context=t,this._options=e,this._xMag2=t.ellipticalArc.matrixRef.columnXMagnitudeSquared(),this._yMag2=t.ellipticalArc.matrixRef.columnYMagnitudeSquared(),this._curvatureRange=ft.createXX(Math.sqrt(this._xMag2)/this._yMag2,Math.sqrt(this._yMag2)/this._xMag2)}static create(t,e){return new Pi(t,e)}curvatureToRadians(t){if(!this._curvatureRange.containsX(t))return;const e=Math.cbrt(this._xMag2*this._yMag2/(t*t)),i=Math.sqrt(Math.abs((e-this._xMag2)/(this._yMag2-this._xMag2)));return Math.acos(i)}computeRadiansStrictlyInsideQuadrant1(t){if(t||(t=[]),this._context.isValidEllipticalArc){const e=1/(this._options.numSamplesInQuadrant-1);for(let i=1;i<this._options.numSamplesInQuadrant-1;++i){const s=this._options.remapFunction(i*e),n=(1-s)*this._curvatureRange.low+s*this._curvatureRange.high,r=this.curvatureToRadians(n);void 0!==r&&t.push(r)}}return t}}class Ai extends Pi{constructor(t,e){super(t,e.clone()),this._options.remapFunction=t=>t}static create(t,e){return new Ai(t,e)}}class Ii{constructor(t,e){this._context=t,this._options=e,this._fullEllipseXY=t.cloneLocalArc(!0)??Ti.createUnitCircle()}static create(t,e){return new Ii(t,e)}get fullEllipseXY(){return this._fullEllipseXY}computeRadiansStrictlyInsideQuadrant1(t){if(!this._context.isValidEllipticalArc)return[];const e=pi.getQ1FractionalRange(this.fullEllipseXY.sweep),i=[pi.create(1,[e.low,e.high],!0,!0)],s=yi.create(this.fullEllipseXY,this._options.maxError);do{wi.processQuadrantFractions(this.fullEllipseXY,i,s)}while(s.isRefined);return s.getRefinedInteriorQ1Angles(t)}}class Si extends mi{constructor(t,e){super(),this._chain=t.sweep.isFullCircle&&!e?hi.create():oi.create()}static create(t,e=!1){return new Si(t,e)}get chain(){return this._chain.children.length>0?this._chain:void 0}announceQuadrantBegin(t,e){return this._quadrantChain=void 0,!0}announceArc(t,e,i,s){this._quadrantChain||(this._quadrantChain=oi.create()),this._quadrantChain.tryAddChild(t)}announceQuadrantEnd(t,e){if(this._quadrantChain){e&&this._quadrantChain.reverseChildrenInPlace();for(const t of this._quadrantChain.children)this._chain.tryAddChild(t)}}}class wi{constructor(t){this._isValidEllipticalArc=!1;const e=t.toScaledMatrix3d();if(this._ellipticalArc=Ti.createScaledXYColumns(e.center,e.axes,e.r0,e.r90,e.sweep),this._localToWorld=pt.createRefs(e.center,e.axes),this._localToWorld.matrix.isSingular())return;if(this._ellipticalArc.sweep.isEmpty)return;const i=t.matrixRef.columnXMagnitudeSquared(),s=t.matrixRef.columnYMagnitudeSquared();Q.isSmallMetricDistanceSquared(i)||Q.isSmallMetricDistanceSquared(s)||Q.isSameCoordinateSquared(i,s)||(this._isValidEllipticalArc=!0)}static create(t){return new wi(t)}get ellipticalArc(){return this._ellipticalArc}get localToWorld(){return this._localToWorld}get isValidEllipticalArc(){return this._isValidEllipticalArc}cloneLocalArc(t){if(!this.isValidEllipticalArc)return;const e=this.localToWorld.inverse();if(!e)return;const i=this.ellipticalArc.cloneTransformed(e);if(t){let t=2*Math.PI;i.sweep.isCCW||(t=-t),i.sweep.setStartEndRadians(i.sweep.startRadians,i.sweep.startRadians+t)}return i}static processQuadrantFractions(t,e,i){const s=this.workPt0,n=this.workPt1,r=this.workPt2,o=this.workRay,a=(t,e,i)=>{const s=Ti.createCircularStartTangentEnd(t.origin,t.direction,e);if(s instanceof Ti)return i&&s.reverseInPlace(),s},c=(e,s)=>{t.fractionToPointAndDerivative(e,o),t.fractionToPoint(s,n),e>s&&o.direction.scaleInPlace(-1);const r=a(o,n,!1);r&&i.announceArc(r,void 0,e,s)},l=(e,o,a)=>{let c=e;i.getPreviousFraction&&(c=i.getPreviousFraction(o)??e),t.fractionToPoint(c,s),t.fractionToPoint(o,n),t.fractionToPoint(a,r);const l=((t,e,i)=>{const s=Ti.createCircularStartMiddleEnd(t,e,i);if(!(s instanceof Ti))return;const n=s.vector0.signedAngleTo($.createStartEnd(s.center,e),s.matrixRef.columnZ());return s.sweep.setStartEndRadians(n.radians,s.sweep.endRadians),s})(s,n,r);l&&i.announceArc(l,c,o,a)},h=(e,n)=>{t.fractionToPoint(e,s),t.fractionToPointAndDerivative(n,o),n>e&&o.direction.scaleInPlace(-1);const r=a(o,s,!0);r&&i.announceArc(r,void 0,e,n)},d=e=>{if(!e.interpolateStartTangent&&!e.interpolateEndTangent)return!1;const i=e.fractions.length;if(i<2)return!1;const s=t.vector0.magnitudeSquared()>t.vector90.magnitudeSquared()?2===e.quadrant||4===e.quadrant:1===e.quadrant||3===e.quadrant,n=!(e.fractions[0]>e.fractions[i-1])&&s===t.sweep.isCCW;return n&&e.reverse(),n};for(const t of e){const e=t.fractions.length;if(e<2)continue;const s=d(t);if(i.announceQuadrantBegin(t,s)){t.interpolateStartTangent&&c(t.fractions[0],t.fractions[1]);for(let i=0;i+2<e-1;++i)l(t.fractions[i],t.fractions[i+1],t.fractions[i+2]);e>2&&(t.interpolateEndTangent?h(t.fractions[e-2],t.fractions[e-1]):l(t.fractions[e-3],t.fractions[e-2],t.fractions[e-1])),i.announceQuadrantEnd(t,s),s&&t.reverse()}}}computeApproximationError(t){const e=this.cloneLocalArc();if(!e)return;const i=xi.create(e);wi.processQuadrantFractions(e,t,i);const s=i.maxPerpendicular;return s&&s.tryTransformInPlace(this.localToWorld)?s:void 0}computeSampleFractions(t,e=!1){if(!this.isValidEllipticalArc)return[];const i=(t,e)=>Q.isAlmostEqualNumber(t,e,Q.smallAngleRadians)?0:t<e?-1:1,s=(t,e)=>Q.isAlmostEqualNumber(t,e,Q.smallAngleRadians)?0:t<e?1:-1,n=(t,e)=>fi(t.fractions[t.fractions.length-1],e.fractions[0])<=0?-1:fi(e.fractions[e.fractions.length-1],t.fractions[0])<=0?1:0,r=(t,e)=>{const i=e.isRadiansInSweep(t,!0);if(i){const i=e.radiansToSignedPeriodicFraction(t);Q.isIn01(i)&&(t=e.fractionToRadians(i))}return{angle:t,inSweep:i}},o=(t,e,i,s,n)=>{if(void 0===s&&(s=0),void 0===n&&(n=1),s>n)return o(t,e,i,n,s);const r=i.radiansToSignedPeriodicFraction(e);return r<s-Q.smallFraction||n+Q.smallFraction<r?void 0:(Q.restrictToInterval(r,0,1),t.add(r),r)},a=(t,e,i,s)=>{if(e>i)return a(t,i,e,s);if(W.isAlmostEqualRadiansNoPeriodShift(e,i))return;const n=pi.getQuadrantRadians(e,i);if(void 0===n)return;const r=new He(fi),c=o(r,e,s),l=o(r,i,s);if(void 0===c||void 0===l)return;for(const e of t){let t=e;2===n.quadrant?t=W.piRadians-t:3===n.quadrant?t=W.piRadians+t:4===n.quadrant&&(t=W.pi2Radians-t),o(r,t,s,c,l)}const h=pi.create(n.quadrant,[...r]);return 2===h.fractions.length&&(h.fractions.splice(1,0,Q.interpolate(h.fractions[0],.5,h.fractions[1])),h.averageAdded=!0),h},c=[];switch(t.sampleMethod){case T.UniformParameter:vi.create(this,t).computeRadiansStrictlyInsideQuadrant1(c);break;case T.UniformCurvature:Ai.create(this,t).computeRadiansStrictlyInsideQuadrant1(c);break;case T.NonUniformCurvature:Pi.create(this,t).computeRadiansStrictlyInsideQuadrant1(c);break;case T.AdaptiveSubdivision:Ii.create(this,t).computeRadiansStrictlyInsideQuadrant1(c)}return e?((t,e)=>{const o=new He(e.isCCW?i:s);o.add(e.endRadians);for(const t of[0,W.piOver2Radians,W.piRadians,W.pi3Over2Radians,W.pi2Radians]){const i=r(t,e);i.inSweep&&o.add(i.angle)}const c=new He(n);let l=e.startRadians;for(const i of o){const s=a(t,l,i,e);s&&c.add(s),l=i}return[...c]})(c,this.ellipticalArc.sweep):((t,e)=>{const i=new He(fi);i.add(0),i.add(1);for(const t of[0,W.piOver2Radians,W.piRadians,W.pi3Over2Radians])o(i,t,e);for(const s of t)for(const t of[s,W.piRadians-s,W.piRadians+s,W.pi2Radians-s])o(i,t,e);return[...i]})(c,this.ellipticalArc.sweep)}constructCircularArcChainApproximation(t){if(!this.isValidEllipticalArc)return;t||(t=Ci.create());const e=this.computeSampleFractions(t,!0),i=Si.create(this.ellipticalArc,t.forcePath);return wi.processQuadrantFractions(this.ellipticalArc,e,i),i.chain}}wi.workPt0=j.createZero(),wi.workPt1=j.createZero(),wi.workPt2=j.createZero(),wi.workRay=bt.createZero(),function(t){t[t.UniformParameter=0]="UniformParameter",t[t.UniformCurvature=1]="UniformCurvature",t[t.NonUniformCurvature=2]="NonUniformCurvature",t[t.AdaptiveSubdivision=3]="AdaptiveSubdivision"}(T||(T={}));class Ci{constructor(t,e,i,s,n){this._sampleMethod=t,this._numSamplesInQuadrant=e,this._maxError=i,this._remapFunction=s,this._forcePath=n}static create(t=T.AdaptiveSubdivision,e=4,i=this.defaultMaxError,s=t=>t*t,n=!1){return e<2&&(e=2),i<=0&&(i=this.defaultMaxError),new Ci(t,e,i,s,n)}clone(){return new Ci(this.sampleMethod,this.numSamplesInQuadrant,this.maxError,this.remapFunction,this.forcePath)}get sampleMethod(){return this._sampleMethod}set sampleMethod(t){this._sampleMethod=t}get numSamplesInQuadrant(){return this._numSamplesInQuadrant}set numSamplesInQuadrant(t){this._numSamplesInQuadrant=t}get maxError(){return this._maxError}set maxError(t){this._maxError=t}get remapFunction(){return this._remapFunction}set remapFunction(t){this._remapFunction=t}get forcePath(){return this._forcePath}set forcePath(t){this._forcePath=t}}Ci.defaultMaxError=Ve.oneCentimeter;class Ti extends ae{isSameGeometryClass(t){return t instanceof Ti}get center(){return this._center.clone()}get vector0(){return this._matrix.columnX()}get vector90(){return this._matrix.columnY()}get perpendicularVector(){return this._matrix.columnZ()}matrixClone(){return this._matrix.clone()}get matrixRef(){return this._matrix}get sweep(){return this._sweep}set sweep(t){this._sweep.setFrom(t)}get isExtensibleFractionSpace(){return!0}constructor(t,e,i){super(),this.curvePrimitiveType="arc",this._center=t,this._matrix=e,this._sweep=i}cloneTransformed(t){const e=this.clone();return e.tryTransformInPlace(t),e}setRefs(t,e,i){this._center=t,this._matrix=e,this._sweep=i}set(t,e,i){this.setRefs(t.clone(),e.clone(),i?i.clone():At.create360())}setFrom(t){this._center.setFrom(t._center),this._matrix.setFrom(t._matrix),this._sweep.setFrom(t._sweep)}clone(){return new Ti(this._center.clone(),this._matrix.clone(),this._sweep.clone())}static createRefs(t,e,i,s){return s?(s.setRefs(t,e,i),s):new Ti(t,e,i)}static createScaledXYColumns(t,e,i,s,n,r){const o=e.columnX(),a=e.columnY();return Ti.create(t,o.scale(i,o),a.scale(s,a),n,r)}static createCenterNormalRadius(t,e,i,s){const n=xt.createRigidHeadsUp(e);return Ti.createScaledXYColumns(t,n,i,i,void 0,s)}static create(t,e,i,s,n){const r=e.unitCrossProductWithDefault(i,0,0,0),o=xt.createColumns(e,i,r);return Ti.createRefs(void 0!==t?t.clone():j.create(0,0,0),o,s?s.clone():At.create360(),n)}static createStartMiddleEnd(t,e,i,s,n){const r=j.createAdd2Scaled(t,.5,i,.5),o=$.createStartEnd(r,t),a=$.createStartEnd(r,e),c=o.dotProduct(a),l=o.magnitudeSquared();if(Math.abs(c)>=l)return;const h=o.crossProduct(a).unitCrossProductWithDefault(o,0,0,0),d=a.dotProduct(h),u=Q.safeDivideFraction(l*d,Math.sqrt(l*l-c*c),0);return Q.isSmallMetricDistanceSquared(u)?void 0:(h.scaleInPlace(u),Ti.create(r,o,h,s,n))}static createCircularStartTangentEnd(t,e,i,s){const n=$.createStartEnd(t,i),r=xt.createRigidFromColumns(e,n,g.XYZ);if(void 0!==r){const i=n.dotProduct(n),o=r.dotColumnY(n),a=Q.conditionalDivideCoordinate(i,2*o);if(void 0!==a){const i=r.columnY();i.scaleInPlace(-a);const o=r.columnX();o.scaleInPlace(a);const c=i.plus(n);let l=i.angleTo(c).radians;e.dotProduct(c)<0&&(l=2*Math.PI-l);const h=t.plusScaled(i,-1),d=At.createStartEndRadians(0,l);return Ti.create(h,i,o,d,s)}}return Ce.create(t,i)}static createCircularStartTangentRadius(t,e,i,s,n){void 0===s&&(s=$.unitZ());const r=s.unitCrossProduct(e);if(void 0===r)return;const o=t.plusScaled(r,i);r.scaleInPlace(-i);const a=e.scaleToLength(Math.abs(i));return Ti.create(o,r,a,At.create(n))}static createCircularStartEndRadius(t,e,i,s){const n=.25*t.distanceSquared(e),r=i*i;if(r<n)return;const o=Math.sqrt(r-n),a=$.createZero(this._workVectorU),c=$.createZero(this._workVectorV);if(s instanceof j?t.crossProductToPoints(s,e,a):a.setFrom(s),!a.normalizeInPlace()||!a.crossProductStartEnd(t,e,c).scaleToLength(o,c))return;const l=j.createZero();t.interpolate(.5,e,l).addInPlace(c);const h=$.createStartEnd(l,t,this._workVectorW),d=$.createStartEnd(l,e,this._workVectorV),u=At.create(h.signedAngleTo(d,a)),f=a.crossProduct(h,this._workVectorV);return Ti.createRefs(l,xt.createColumns(h,f,a),u)}cloneAtZ(t){return void 0===t&&(t=this._center.z),Ti.createXYZXYZXYZ(this._center.x,this._center.y,t,this._matrix.coffs[0],this._matrix.coffs[3],0,this._matrix.coffs[1],this._matrix.coffs[4],0,this._sweep)}static createXYZXYZXYZ(t,e,i,s,n,r,o,a,c,l,h){return Ti.create(j.create(t,e,i),$.create(s,n,r),$.create(o,a,c),l,h)}quickEccentricity(){const t=this._matrix.columnXMagnitude(),e=this._matrix.columnYMagnitude(),i=this._matrix.columnXYCrossProductMagnitude(),s=Q.maxXY(t,e);return i/(s*s)}static createCircularStartMiddleEnd(t,e,i,s){const n=$.createStartEnd(t,e),r=$.createStartEnd(t,i),o=n.magnitudeSquared(),a=r.magnitudeSquared(),c=n.sizedCrossProduct(r,Math.sqrt(Math.sqrt(o*a)));if(c){const e=Mt.linearSystem3d(c.x,c.y,c.z,n.x,n.y,n.z,r.x,r.y,r.z,0,.5*o,.5*a);if(e){const n=j.create(t.x,t.y,t.z).plus(e),r=$.createStartEnd(n,t),o=$.createRotateVectorAroundVector(r,c,W.createDegrees(90));if(o){const t=$.createStartEnd(n,i),e=r.signedAngleTo(t,c);return e.radians<0&&e.addMultipleOf2PiInPlace(1),Ti.create(n,r,o,At.createStartEndRadians(0,e.radians),s)}}}return Me.create(t,e,i)}getFractionToDistanceScale(){const t=this.circularRadius();if(void 0!==t)return Math.abs(t*this._sweep.sweepRadians)}fractionToPoint(t,e){const i=this._sweep.fractionToRadians(t);return this._matrix.originPlusMatrixTimesXY(this._center,Math.cos(i),Math.sin(i),e)}fractionAndRadialFractionToPoint(t,e,i){const s=this._sweep.fractionToRadians(t);return this._matrix.originPlusMatrixTimesXY(this._center,e*Math.cos(s),e*Math.sin(s),i)}fractionToPointAndDerivative(t,e){return(e=this.radiansToPointAndDerivative(this._sweep.fractionToRadians(t),e)).direction.scaleInPlace(this._sweep.sweepRadians),e}fractionToPointAnd2Derivatives(t,e){const i=this._sweep.fractionToRadians(t);e||(e=Et.createXYPlane());const s=Math.cos(i),n=Math.sin(i);this._matrix.originPlusMatrixTimesXY(this._center,s,n,e.origin);const r=this._sweep.sweepRadians;this._matrix.multiplyXY(-r*n,r*s,e.vectorU);const o=r*r;return this._matrix.multiplyXY(-o*s,-o*n,e.vectorV),e}radiansToPointAndDerivative(t,e){e=e||bt.createZero();const i=Math.cos(t),s=Math.sin(t);return this._matrix.originPlusMatrixTimesXY(this._center,i,s,e.origin),this._matrix.multiplyXY(-s,i,e.direction),e}radiansToPoint(t,e){e=e||j.create();const i=Math.cos(t),s=Math.sin(t);return this._matrix.originPlusMatrixTimesXY(this._center,i,s,e),e}radiansToRotatedBasis(t,e){e=e||Et.createXYPlane();const i=Math.cos(t),s=Math.sin(t);return e.origin.setFromPoint3d(this.center),this._matrix.multiplyXY(i,s,e.vectorU),this._matrix.multiplyXY(-s,i,e.vectorV),e}angleToPointAndDerivative(t,e){e=e||bt.createZero();const i=t.cos(),s=t.sin();return this._matrix.originPlusMatrixTimesXY(this._center,i,s,e.origin),this._matrix.multiplyXY(-s,i,e.direction),e}startPoint(t){return this.fractionToPoint(0,t)}endPoint(t){return this.fractionToPoint(1,t)}curveLength(){return this.curveLengthBetweenFractions(0,1)}curveLengthBetweenFractions(t,e){const i=this.getFractionToDistanceScale();if(void 0!==i)return i*Math.abs(e-t);let s=t,n=e;t>e&&(s=e,n=t);const r=(n-s)*this._sweep.sweepDegrees;let o=this.quickEccentricity();o<1e-5&&(o=1e-5);let a=Math.ceil(r/(o*Ti.quadratureIntervalAngleDegrees));return a>400&&(a=400),a<1&&(a=1),super.curveLengthWithFixedIntervalCountQuadrature(s,n,a,Ti.quadratureGuassCount)}quickLength(){const t=Math.abs(this._sweep.sweepRadians);let e=Math.ceil(4*t/Math.PI);e<1&&(e=1),e<4?e+=3:e<6&&(e+=2);const i=Ti._workPointA,s=Ti._workPointB;let n=0;this.fractionToPoint(0,i);for(let t=1;t<=e;t++)this.fractionToPoint(t/e,s),n+=i.distance(s),i.setFromPoint3d(s);const r=t/e;return n*(r/(2*Math.sin(.5*r)))}moveSignedDistanceFromFraction(t,e,i,s){if(!this.isCircular)return super.moveSignedDistanceFromFractionGeneric(t,e,i,s);const n=this.curveLength(),r=Q.conditionalDivideFraction(e,n);return void 0===r?vt.createCurveFractionPointDistanceCurveSearchStatus(this,t,this.fractionToPoint(t),0,A.error):vt.createConditionalMoveSignedDistance(i,this,t,t+r,e,s)}allPerpendicularAngles(t,e=!0,i=!1){const s=[],n=t.vectorTo(this.center),r=this._matrix.columnXMagnitudeSquared(),o=this._matrix.columnXDotColumnY(),a=this._matrix.columnYMagnitudeSquared();return Tt.solveUnitCircleImplicitQuadricIntersection(o,a-r,-o,this._matrix.dotColumnY(n),-this._matrix.dotColumnX(n),0,s),i&&(s.push(this.sweep.startRadians),s.push(this.sweep.endRadians)),s}closestPoint(t,e,i){i=vt.create(this,i);const s=this.allPerpendicularAngles(t,!0,!0);let n=ie.resolveVariantCurveExtendParameterToCurveExtendMode(e,0),r=ie.resolveVariantCurveExtendParameterToCurveExtendMode(e,1);this._sweep.isFullCircle&&(n=S.None,r=S.None),n!==S.None&&r!==S.None&&(s.push(this._sweep.startRadians),s.push(this._sweep.endRadians));const o=bt.createZero();if(0===s.length)i.setFR(0,this.radiansToPointAndDerivative(this._sweep.startRadians,o)),i.a=t.distance(i.point);else{let n=Number.MAX_VALUE,r=0;for(const a of s){const s=ie.resolveRadiansToSweepFraction(e,a,this.sweep);void 0!==s&&(this.fractionToPointAndDerivative(s,o),r=t.distance(o.origin),r<n&&(n=r,i.setFR(s,o),i.a=r))}}return i}reverseInPlace(){this._sweep.reverseInPlace()}tryTransformInPlace(t){return this._center=t.multiplyPoint3d(this._center,this._center),this._matrix=t.matrix.multiplyMatrixMatrix(this._matrix,this._matrix),this.setVector0Vector90(this._matrix.columnX(),this._matrix.columnY()),!0}isInPlane(t){const e=t.getNormalRef();return Q.isSmallMetricDistance(t.altitude(this._center))&&Q.isSmallMetricDistance(this._matrix.dotColumnX(e))&&Q.isSmallMetricDistance(this._matrix.dotColumnY(e))}get isCircular(){const t=this._matrix.columnXMagnitudeSquared(),e=this._matrix.columnYMagnitudeSquared(),i=this._matrix.columnXDotColumnY();return W.isPerpendicularDotSet(t,e,i)&&Q.isSameCoordinateSquared(t,e)}circularRadiusXY(){const t=this._matrix.at(0,0),e=this._matrix.at(1,0),i=this._matrix.at(0,1),s=this._matrix.at(1,1),n=Q.dotProductXYXY(t,e,t,e),r=Q.dotProductXYXY(i,s,i,s),o=Q.dotProductXYXY(t,e,i,s);if(W.isPerpendicularDotSet(n,r,o)&&Q.isSameCoordinateSquared(n,r))return Q.hypotenuseXY(t,e)}circularRadius(){return this.isCircular?this._matrix.columnXMagnitude():void 0}maxVectorLength(){return Math.max(this._matrix.columnXMagnitude(),this._matrix.columnYMagnitude())}appendPlaneIntersectionPoints(t,e){const i=t.altitude(this._center),s=this._matrix.coffs,n=t.velocityXYZ(s[0],s[3],s[6]),r=t.velocityXYZ(s[1],s[4],s[7]),o=Q.solveTrigForm(i,n,r);let a=0;if(void 0!==o){let t;for(t of(a=o.length,o)){const i=Math.atan2(t.y,t.x),s=this._sweep.radiansToPositivePeriodicFraction(i),n=vt.createCurveFractionPoint(this,s,this.fractionToPoint(s));n.intervalRole=P.isolated,(W.isAlmostEqualRadiansAllowPeriodShift(i,this._sweep.startRadians)||W.isAlmostEqualRadiansAllowPeriodShift(i,this._sweep.endRadians))&&(n.intervalRole=P.isolatedAtVertex),e.push(n)}}return a}extendRange(t,e){this.extendRangeInSweep(t,this._sweep,e)}extendRangeInSweep(t,e,i){const s=new kt(0,0,0),n=this._center.clone(Ti._workPointA),r=this._matrix.columnX(Ti._workVectorU),o=this._matrix.columnY(Ti._workVectorV);i&&(i.multiplyPoint3d(n,n),i.multiplyVector(r,r),i.multiplyVector(o,o));const a=Ti._workPointB,c=Ti._workPointC,l=ft.createNull();for(let t=0;t<3;t++)s.set(n.at(t),r.at(t),o.at(t)),s.rangeInSweep(e,l),a.setAt(t,l.low),c.setAt(t,l.high);t.extend(a),t.extend(c)}rangeBetweenFractions(t,e,i){const s=At.createStartEndRadians(this.sweep.fractionToRadians(t),this.sweep.fractionToRadians(e)),n=ut.create();return this.extendRangeInSweep(n,s,i),n}getPlaneAltitudeSineCosinePolynomial(t,e){return e||(e=new kt(0,0,0)),e.set(t.altitude(this._center),t.velocityXYZ(this._matrix.coffs[0],this._matrix.coffs[3],this._matrix.coffs[6]),t.velocityXYZ(this._matrix.coffs[1],this._matrix.coffs[4],this._matrix.coffs[7])),e}static createUnitCircle(){return Ti.createRefs(j.create(0,0,0),xt.createIdentity(),At.create360())}static createXY(t,e,i=At.create360()){return new Ti(t.clone(),xt.createScale(e,e,1),i.clone())}static createXYEllipse(t,e,i,s=At.create360()){return new Ti(t.clone(),xt.createScale(e,i,1),s.clone())}setVector0Vector90(t,e){this._matrix.setColumns(t,e,t.unitCrossProductWithDefault(e,0,0,0))}toScaledMatrix3d(){const t=W.dotProductsToHalfAngleTrigValues(this._matrix.columnXMagnitudeSquared(),this._matrix.columnYMagnitudeSquared(),this._matrix.columnXDotColumnY(),!0),e=this._matrix.multiplyXY(t.c,t.s),i=this._matrix.multiplyXY(-t.s,t.c),s=xt.createRigidFromColumns(e,i,g.XYZ);return{center:this._center.clone(),axes:s||xt.createIdentity(),r0:e.magnitude(),r90:i.magnitude(),sweep:this.sweep.cloneMinusRadians(t.radians)}}toVectors(){return{center:this.center.clone(),vector0:this._matrix.columnX(),vector90:this._matrix.columnY(),sweep:this.sweep.clone()}}toTransformedVectors(t){return t?{center:t.multiplyPoint3d(this._center),vector0:t.multiplyVector(this._matrix.columnX()),vector90:t.multiplyVector(this._matrix.columnY()),sweep:this.sweep.clone()}:{center:this._center.clone(),vector0:this._matrix.columnX(),vector90:this._matrix.columnY(),sweep:this.sweep.clone()}}toTransformedPoint4d(t){return{center:t.multiplyPoint3d(this._center,1),vector0:t.multiplyPoint3d(this._matrix.columnX(),0),vector90:t.multiplyPoint3d(this._matrix.columnY(),0),sweep:this.sweep.clone()}}setFromJSON(t){if(t&&t.center&&t.vector0&&t.vector90&&t.sweep){this._center.setFromJSON(t.center);const e=$.create(),i=$.create();e.setFromJSON(t.vector0),i.setFromJSON(t.vector90),this.setVector0Vector90(e,i),this._sweep.setFromJSON(t.sweep)}else this._center.set(0,0,0),this._matrix.setFrom(xt.identity),this._sweep.setStartEndRadians()}toJSON(){return{center:this._center.toJSON(),sweep:this._sweep.toJSON(),vector0:this._matrix.columnX().toJSON(),vector90:this._matrix.columnY().toJSON()}}isAlmostEqual(t,e=Q.smallMetricDistance,i=Q.smallAngleRadians){if(t instanceof Ti){const s=t;return this._center.isAlmostEqual(s._center,e)&&this._matrix.isAlmostEqual(s._matrix,e)&&this._sweep.isAlmostEqualAllowPeriodShift(s._sweep,i)}return!1}emitStrokes(t,e){const i=this.computeStrokeCountForOptions(e);t.appendFractionalStrokePoints(this,i,0,1,!0)}emitStrokableParts(t,e){const i=this.computeStrokeCountForOptions(e);t.startCurvePrimitive(this),t.announceIntervalForUniformStepStrokes(this,i,0,1),t.endCurvePrimitive(this)}computeStrokeCountForOptions(t){let e;if(t){const i=this.maxVectorLength();e=t.applyTolerancesToArc(i,this._sweep.sweepRadians)}else e=Ie.applyAngleTol(void 0,1,this._sweep.sweepRadians);return e}dispatchToGeometryHandler(t){return t.handleArc3d(this)}clonePartialCurve(t,e){if(e<t){const i=this.clonePartialCurve(e,t);return i.reverseInPlace(),i}const i=this.clone();return i.sweep.setStartEndRadians(this.sweep.fractionToRadians(t),this.sweep.fractionToRadians(e)),i}cloneInRotatedBasis(t){const e=t.cos(),i=t.sin(),s=this._matrix.multiplyXY(e,i),n=this._matrix.multiplyXY(-i,e),r=At.createStartEndRadians(this._sweep.startRadians-t.radians,this._sweep.endRadians-t.radians);return Ti.create(this._center.clone(),s,n,r)}announceClipIntervals(t,e){return t.announceClippedArcIntervals(this,e)}otherArcAsLocalVectors(t){const e=this._matrix.multiplyInverseXYZAsPoint3d(t.center.x-this.center.x,t.center.y-this.center.y,t.center.z-this.center.z),i=this._matrix.multiplyInverse(t.vector0),s=this._matrix.multiplyInverse(t.vector90);if(e&&i&&s)return{center:e,vector0:i,vector90:s,sweep:this.sweep.clone()}}static createFilletArc(t,e,i,s){const n=$.createStartEnd(e,t),r=$.createStartEnd(e,i),o=n.magnitude(),a=r.magnitude();if(n.normalizeInPlace()&&r.normalizeInPlace()){const t=n.plus(r);if(t.normalizeInPlace()){const i=r.minus(n),c=i.magnitude(),l=.5*c;if(!Q.isSmallAngleRadians(l)){const n=l/Math.sqrt(1-l*l),r=Math.acos(l),h=s/l,d=s/n,u=d/o,f=d/a,g=e.plusScaled(t,h);return t.scaleInPlace(-s),i.scaleInPlace(s/c),{arc:Ti.create(g,t,i,At.createStartEndRadians(-r,r)),fraction10:u,fraction12:f,point:e.clone()}}}}return{fraction10:0,fraction12:0,point:e.clone()}}scaleAboutCenterInPlace(t){this._matrix.scaleColumnsInPlace(t,t,1)}areaToChordXY(t,e){let i=Q.crossProductXYXY(this._matrix.coffs[0],this._matrix.coffs[3],this._matrix.coffs[1],this._matrix.coffs[4]);const s=this._sweep.fractionToRadians(t),n=.5*(this._sweep.fractionToRadians(e)-s);return n<0&&(i=-i),(n-Math.cos(n)*Math.sin(n))*i}constructOffsetXY(t){const e=we.create(t);if(this.isCircular||e.preserveEllipticalArcs){const t=this.cloneAtZ(),i=t.sweep.sweepRadians*t.matrixRef.coffs[8]>=0?1:-1,s=t.matrixRef.columnXMagnitude(),n=s-i*e.leftOffsetDistance,r=this.isCircular?s:t.matrixRef.columnYMagnitude(),o=this.isCircular?n:r-i*e.leftOffsetDistance;if(!Q.isSmallMetricDistance(n)&&s*n>0&&(this.isCircular||!Q.isSmallMetricDistance(o)&&r*o>0)){const e=n/s,i=this.isCircular?e:o/r,a=t.matrixClone();return a.scaleColumnsInPlace(e,i,1),Ti.createRefs(t.center.clone(),a,t.sweep.clone())}return}const i=new ye(this,e.leftOffsetDistance);return this.emitStrokableParts(i,e.strokeOptions),i.claimResult()}projectedParameterRange(t,e){return Ee.findExtremeFractionsAlongDirection(this,t,e)}constructCircularArcChainApproximation(t){t||(t=Ci.create());const e=wi.create(this).constructCircularArcChainApproximation(t);return!e&&this.isCircular?this.sweep.isFullCircle&&t.forcePath?oi.create(this):this:e}}Ti._workPointA=j.create(),Ti._workPointB=j.create(),Ti._workPointC=j.create(),Ti._workVectorU=$.create(),Ti._workVectorV=$.create(),Ti._workVectorW=$.create(),Ti.quadratureGuassCount=5,Ti.quadratureIntervalAngleDegrees=10;class Fi{areStronglyIndependentVectors(t,e,i=Q.smallAngleRadians){return void 0!==t&&void 0!==e&&t.smallerUnorientedRadiansTo(e)>i}clear(){this._origin=void 0,this._vector0=void 0,this._vector1=void 0,this._vector2=void 0}constructor(){this.clear()}getValidatedFrame(t=!1,e){if(this._origin&&this._vector0&&this._vector1){const i=(t,e)=>Fi._workMatrix=xt.createRigidFromColumns(t,e,g.XYZ,Fi._workMatrix);if(t){if(this._vector2){const t=i(this._vector0,this._vector1);if(t)return this._vector0.tripleProduct(this._vector1,this._vector2)<0&&t.scaleColumns(1,1,-1),pt.createOriginAndMatrix(this._origin,t,e);const s=this._vector2;this._vector1=this._vector2=void 0,this.announceVector(s)}}else{const t=i(this._vector0,this._vector1);if(t)return pt.createOriginAndMatrix(this._origin,t,e);this._vector1=this._vector2=void 0}}}applyDefaultUpVector(t){t&&this._vector0&&!this._vector1&&!t.isParallelTo(this._vector0)&&(this._vector1=t.crossProduct(this._vector0))}get hasOrigin(){return void 0!==this._origin}savedVectorCount(){return this._vector0?this._vector1?this._vector2?3:2:1:0}announcePoint(t){return this._origin?this._origin.isAlmostEqual(t)?this.savedVectorCount():this.announceVector(this._origin.vectorTo(t)):(this._origin=t.clone(),this.savedVectorCount())}announceVector(t){if(t.isAlmostZero)return this.savedVectorCount();if(!this._vector0)return this._vector0=t.clone(this._vector0),1;if(!this._vector1)return this.areStronglyIndependentVectors(t,this._vector0,1e-5)?(this._vector1=t.clone(this._vector1),2):1;if(!this._vector2){const e=this._vector0.unitCrossProduct(this._vector1);return e&&!Q.isSameCoordinate(0,e.dotProduct(t))?(this._vector2=t.clone(this._vector2),3):2}return 3}announce(t){if(!(this.savedVectorCount()>1)&&void 0!==t)if(t instanceof j)this.announcePoint(t);else if(t instanceof $)this.announceVector(t);else if(Array.isArray(t))for(const e of t){if(this.savedVectorCount()>1)break;this.announce(e)}else if(t instanceof ae)if(t instanceof Ce)this.announcePoint(t.startPoint()),this.announcePoint(t.endPoint());else if(t instanceof Ti){const e=t.fractionToPointAndDerivative(0);this.announcePoint(e.origin),this.announceVector(e.direction),this.announceVector(t.matrixRef.columnZCrossVector(e.direction))}else if(t instanceof Me){for(const e of t.points)if(this.announcePoint(e),this.savedVectorCount()>1)break}else if(t instanceof Be){const e=j.create();for(let i=0;this.savedVectorCount()<2&&t.getPolePoint3d(i,e)instanceof j;i++)this.announcePoint(e)}else if(t instanceof _e){const e=j.create();for(let i=0;this.savedVectorCount()<2&&i<t.options.fitPoints.length;i++)e.setFrom(t.options.fitPoints[i]),this.announcePoint(e)}else{const e=t.fractionToFrenetFrame(0);void 0!==e&&(this.announcePoint(e.getOrigin()),this.announceVector(e.matrix.getColumn(0)),this.announceVector(e.matrix.getColumn(1)))}else if(t instanceof si){if(t.children)for(const e of t.children)if(this.announce(e),this.savedVectorCount()>1)break}else if(t instanceof nt){const e=j.create();for(let i=0;this.savedVectorCount()<2&&t.getPoint3dAtCheckedPointIndex(i,e)instanceof j;i++)this.announcePoint(e)}else t.hasOwnProperty("x")&&t.hasOwnProperty("y")&&t.hasOwnProperty("z")&&this.announcePoint(j.create(t.x,t.y,t.z))}static createRightHandedFrame(t,...e){let i=e.length>0&&e[e.length-1]instanceof pt?e.pop():void 0;const s=e=>(t&&e.matrix.dotColumnZ(t)<0&&e.matrix.scaleColumnsInPlace(1,-1,-1),e),n=new Fi;for(const r of e)if(n.announce(r),n.applyDefaultUpVector(t),i=n.getValidatedFrame(!1,i))return s(i);const r=(t,e)=>t.fractionToFrenetFrame(0,e);for(const t of e)if(t instanceof ae){if(i=r(t,i))return s(i)}else if(t instanceof si){const e=t.collectCurvePrimitives();for(const t of e)if(i=r(t,i))return s(i)}}static createRightHandedLocalToWorld(...t){return this.createRightHandedFrame(void 0,t)}static createFrameToDistantPoints(t,e){if(t.length>2){const i=t[0],s=Fi._workVector0??$.create();ue.indexOfMostDistantPoint(t,t[0],s);const n=Fi._workVector1??$.create();ue.indexOfPointWithMaxCrossProductMagnitude(t,i,s,n);const r=Fi._workMatrix=xt.createRigidFromColumns(s,n,g.XYZ,Fi._workMatrix);if(r)return pt.createOriginAndMatrix(i,r,e)}}static createFrameWithCCWPolygon(t,e){if(t.length>2){const i=Ur.centroidAreaNormal(t);if(i)return i.toRigidZFrame(e)}}static createLocalToWorldTransformInRange(t,e=x.NonUniformRangeContainment,i=0,s=0,n=0,r=1,o){if(t.isNull)return pt.createIdentity(o);let a=1,c=1,l=1;e===x.LongestRangeDirection?a=c=l=Q.correctSmallMetricDistance(t.maxLength(),r):e===x.NonUniformRangeContainment&&(a=Q.correctSmallMetricDistance(t.xLength(),r)*Q.maxAbsDiff(i,0,1),c=Q.correctSmallMetricDistance(t.yLength(),r)*Q.maxAbsDiff(s,0,1),l=Q.correctSmallMetricDistance(t.zLength(),r)*Q.maxAbsDiff(n,0,1));const h=Fi._workPoint=t.fractionToPoint(i,s,n,Fi._workPoint),d=Fi._workMatrix=xt.createScale(a,c,l,Fi._workMatrix);return pt.createOriginAndMatrix(h,d,o)}}class ki{constructor(t,e,i){this._toleranceSquared=i*i,this._source=t,this._dest=e}acceptPointByIndex(t){const e=this._source.getPoint3dAtCheckedPointIndex(this._source.cyclicIndex(t));e&&this._dest.push(e)}indexOfMaxCrossProduct(t,e){let i,s,n=0;for(let r=t;r<=e;r++){const t=this._source.cyclicIndex(r),e=this._source.cyclicIndex(r+1),o=this._source.cyclicIndex(r+2);this._source.crossProductIndexIndexIndex(t,e,o,ki._vectorQ),i=ki._vectorQ.magnitudeSquared(),i>n&&(n=i,s=r)}return s}indexOfMaxDeviation(t,e){const i=this._source.cyclicIndex(t),s=this._source.cyclicIndex(e);let n,r,o,a,c,l=this._toleranceSquared;this._source.vectorIndexIndex(i,s,ki._vector01);const h=ki._vector01.magnitudeSquared();for(let d=t+1;d<e;d++)c=this._source.cyclicIndex(d),this._source.vectorIndexIndex(i,c,ki._vectorQ),r=ki._vector01.dotProduct(ki._vectorQ),r<=0?o=ki._vectorQ.magnitudeSquared():r>h?(this._source.vectorIndexIndex(s,c,ki._vectorQ),o=ki._vectorQ.magnitudeSquared()):(a=r/h,o=ki._vectorQ.magnitudeSquared()-h*a*a),o>l&&(l=o,n=d);return n}recursiveCompressByChordErrorGo(t,e){if(e===t+1)return void this.acceptPointByIndex(e);const i=this.indexOfMaxDeviation(t,e);void 0===i?this.acceptPointByIndex(e):(this.recursiveCompressByChordErrorGo(t,i),this.recursiveCompressByChordErrorGo(i,e))}static compressPoint3dArrayByChordError(t,e){const i=new ce(t),s=new ce([]);return this.compressCollectionByChordError(i,s,e),s.data}static compressCollectionByChordError(t,e,i){e.clear();const s=t.length;if(1===s)return void e.push(t.getPoint3dAtCheckedPointIndex(0));const n=new ki(t,e,i);let r=0,o=s-1;if(s>2&&t.distanceIndexIndex(0,s-1)<=i){const t=n.indexOfMaxCrossProduct(0,s-1);void 0!==t&&(r=t+1,o=r+s)}n.acceptPointByIndex(r),n.recursiveCompressByChordErrorGo(r,o)}static compressInPlaceByShortEdgeLength(t,e){const i=t.length;if(i<2)return;let s=0,n=i-1;for(;n>0&&t.distanceIndexIndex(n-1,i-1)<e;)n--;if(0===n)return void(t.length=1);n<i-1&&t.moveIndexToIndex(i-1,n);let r=s+1;for(;r<=n;)t.distanceIndexIndex(s,r)>=e&&(t.moveIndexToIndex(r,s+1),s++),r++;t.length=s+1}static compressInPlaceBySmallTriangleArea(t,e){const i=t.length;if(i<3)return;let s=0;const n=$.create();for(let r=1;r+1<i;r++)t.crossProductIndexIndexIndex(s,r,r+1,n),.5*n.magnitude()>e&&t.moveIndexToIndex(r,++s);t.moveIndexToIndex(i-1,++s),t.length=s+1}static compressInPlaceByPerpendicularDistance(t,e,i=1.0001){const s=t.length;if(s<3)return;let n=0;const r=ki._vector01,o=ki._vectorQ;let a;const c=e*e;let l,h=1;for(;h+1<s;h++){t.vectorIndexIndex(n,h+1,r),t.vectorIndexIndex(n,h,o),l=r.magnitudeSquared();const e=Q.conditionalDivideFraction(o.dotProduct(r),l);void 0!==e&&e>=0&&e<=i&&(a=ki._vectorQ.magnitudeSquared()-l*e*e,a<=c)?(t.moveIndexToIndex(h+1,++n),h+=1):t.moveIndexToIndex(h,++n)}h<s&&t.moveIndexToIndex(h,++n),t.length=n+1}static compressColinearWrapInPlace(t,e,i){const s=t.length-1;if(s>=3&&t[0].distance(t[s])<e){const e=s-1,n=0,r=1,o=$.createStartEnd(t[e],t[r]),a=$.createStartEnd(t[e],t[n]),c=o.dotProduct(o),l=o.dotProduct(a),h=Q.conditionalDivideFraction(l,c);if(void 0!==h&&h>0&&h<1){const s=a.magnitudeSquared()-h*h*c;Math.sqrt(Math.abs(s))<i&&(t[0]=t[e],t.pop())}}}}ki._vector01=$.create(),ki._vectorQ=$.create();class Mi{static edgeLengthRange(t){const e=ft.createNull();for(let i=1;i<t.length;i++)e.extendX(t[i-1].distance(t[i]));return e}static compressByChordError(t,e){return ki.compressPoint3dArrayByChordError(t,e)}static compressShortEdges(t,e){const i=nt.create(t);return ki.compressInPlaceByShortEdgeLength(i,e),i.getPoint3dArray()}static compressSmallTriangles(t,e){const i=nt.create(t);return ki.compressInPlaceBySmallTriangleArea(i,e),i.getPoint3dArray()}static compressByPerpendicularDistance(t,e,i=2){const s=nt.create(t);let n=s.length;for(let t=0;t<i;t++){ki.compressInPlaceByPerpendicularDistance(s,e);const t=s.length;if(t===n)break;n=t}return s.getPoint3dArray()}static squaredDistanceToInterpolatedPoint(t,e,i,s){const n=1-i,r=t.x-(n*e.x+i*s.x),o=t.y-(n*e.y+i*s.y),a=t.z-(n*e.z+i*s.z);return r*r+o*o+a*a}static isDanglerConfiguration(t,e,i,s,n){if(e<0||e>=t.length)return!1;const r=t[e],o=r.distanceSquared(s);if(o<=n)return!0;if(i<0||i>=t.length)return!1;const a=t[i],c=r.dotVectorsToTargets(a,s);if(c<=0)return!1;const l=r.distanceSquared(a);let h;if(o>=l){const t=c/o;h=this.squaredDistanceToInterpolatedPoint(a,r,t,s)}else{const t=c/l;h=this.squaredDistanceToInterpolatedPoint(s,r,t,a)}return h<n}static compressDanglers(t,e=!1,i=Q.smallMetricDistance){let s=t.length;const n=i*i;if(e)for(;s>1&&t[s-1].distanceSquared(t[0])<=n;)s--;const r=[];r.push(t[0].clone());for(let e=1;e<s;e++){const i=t[e];for(;this.isDanglerConfiguration(r,r.length-1,r.length-2,i,n);)r.pop();r.push(i.clone())}if(e){let t=0,e=r.length-1;for(;e>t+2;)if(this.isDanglerConfiguration(r,t,t+1,r[e],n))t++;else{if(!this.isDanglerConfiguration(r,e,e-1,r[t],n))break;e--}e+1<r.length&&(r.length=e+1),t>0&&r.splice(0,t)}return r}static addClosurePoint(t){if(0===t.length)return;const e=t[0];if(Array.isArray(e)){for(const e of t)Array.isArray(e)&&this.addClosurePoint(e);return}const i=t[t.length-1];e instanceof j&&i instanceof j&&!e.isAlmostEqual(i)&&t.push(e.clone())}static removeClosurePoint(t){if(0===t.length)return;const e=t[0];if(Array.isArray(e)){for(const e of t)Array.isArray(e)&&this.removeClosurePoint(e);return}const i=t[t.length-1];e instanceof j&&i instanceof j&&e.isAlmostEqual(i)&&t.pop()}static createBisectorPlanesForDistinctPoints(t,e=!1){const i=Mi.compressShortEdges(t,2*Q.smallMetricDistance);if(i.length<2)return;const s=[],n=i[0],r=i[1],o=$.createNormalizedStartEnd(n,r),a=_t.create(n,o),c=_t.createXYPlane();s.push(a.clone());for(let t=1;t+1<i.length;t++)if($.createNormalizedStartEnd(i[t],i[t+1],o),void 0!==_t.create(i[t],o,c)){const e=a.getNormalRef().interpolate(.5,c.getNormalRef()),n=_t.create(i[t],e);void 0!==n&&s.push(n),a.setFrom(c)}s.push(_t.create(i[i.length-1],a.getNormalRef()));const l=s.length-1;if(l>0&&e){const t=s[0],e=s[l];if(Q.isSamePoint3d(t.getOriginRef(),e.getOriginRef())){const i=t.getNormalRef().plus(e.getNormalRef()),n=_t.create(t.getOriginRef(),i);void 0!==n&&(s[0]=n,s[l]=_t.create(e.getOriginRef(),i))}}return s.length>1?s:void 0}static closestApproach(t,e,i,s,n=Number.MAX_VALUE,r){Array.isArray(t)&&(t=new ce(t)),Array.isArray(i)&&(i=new ce(i));let o=n,a=!1;const c=t.length-1,l=i.length-1,h=[S.None,S.None],d=[S.None,S.None],u=(t,e,i,s)=>{t[0]=t[1]=S.None,0===i?t[0]=ie.resolveVariantCurveExtendParameterToCurveExtendMode(e,0):i===s-1&&(t[1]=ie.resolveVariantCurveExtendParameterToCurveExtendMode(e,1))},f=(t,e,i)=>void 0===i?Ce.createCapture(t.getPoint3dAtUncheckedPointIndex(e),t.getPoint3dAtUncheckedPointIndex(e+1)):(t.getPoint3dAtUncheckedPointIndex(e,i.point0Ref),t.getPoint3dAtUncheckedPointIndex(e+1,i.point1Ref),i);for(let n=0;n<c;n++){this._workSegmentA=f(t,n,this._workSegmentA),u(h,e,n,c);for(let t=0;t<l;t++)if(this._workSegmentB=f(i,t,this._workSegmentB),u(d,s,t,l),void 0!==(this._workLocalDetailPair=Ce.closestApproach(this._workSegmentA,h,this._workSegmentB,d,this._workLocalDetailPair))){const e=this._workLocalDetailPair.detailA.a;if(e<o){const i=r?.detailA.childDetail,s=r?.detailB.childDetail;r=this._workLocalDetailPair.clone(r),Me.convertLocalToGlobalDetail(r.detailA,n,c,void 0,i),Me.convertLocalToGlobalDetail(r.detailB,t,l,void 0,s),r.detailA.childDetail&&r.detailB.childDetail&&(r.detailA.childDetail.curve=r.detailB.childDetail.curve=void 0),o=e,a=!0}}}return a?r:void 0}}class bi extends si{isSameGeometryClass(t){return t instanceof bi}get children(){return this._children}constructor(){super(),this.curveCollectionType="parityRegion",this._children=[]}addLoops(t){if(void 0===t);else if(t instanceof hi)this.children.push(t);else if(Array.isArray(t))for(const e of t)e instanceof hi?this.children.push(e):Array.isArray(e)&&this.addLoops(e)}static createLoops(t){if(t instanceof hi)return t;const e=new bi;return e.addLoops(t),e}static create(...t){const e=new bi;for(const i of t)e.children.push(i);return e}dgnBoundaryType(){return 4}announceToCurveProcessor(t,e=-1){return t.announceParityRegion(this,e)}clone(){const t=new bi;let e;for(e of this.children){const i=e.clone();i instanceof hi&&t.children.push(i)}return t}cloneStroked(t){const e=new bi;let i;for(i of this.children){const s=i.cloneStroked(t);s&&e.children.push(s)}return e}cloneEmptyPeer(){return new bi}tryAddChild(t){return!!(t&&t instanceof hi)&&(this._children.push(t),!0)}getChild(t){if(t<this._children.length)return this._children[t]}dispatchToGeometryHandler(t){return t.handleParityRegion(this)}}class Ei{get quantitySum(){return this.sums.atIJ(3,3)}signFactor(t){return t*this.quantitySum>0?1:-1}setOriginIfNeeded(t){this.needOrigin&&(this.origin.setFromPoint3d(t),this.needOrigin=!1)}setOriginFromGrowableXYZArrayIfNeeded(t){this.needOrigin&&t.length>0&&(t.getPoint3dAtCheckedPointIndex(0,this.origin),this.needOrigin=!1)}setOriginXYZIfNeeded(t,e,i){this.needOrigin&&(this.origin.set(t,e,i),this.needOrigin=!1)}constructor(){this._point0=j.create(),this._point1=j.create(),this.origin=j.createZero(),this.sums=Xt.createZero(),this.localToWorldMap=pt.createIdentity(),this.radiusOfGyration=$.create(),this.needOrigin=!1,this.absoluteQuantity=.1,this.absoluteQuantity=void 0}static create(t,e=!1){const i=new Ei;return i.needOrigin=e,t&&(i.origin.setFromPoint3d(t),i.needOrigin=!1),i}static momentTensorFromInertiaProducts(t){const e=t.sumDiagonal(),i=xt.createScale(e,e,e);return i.addScaledInPlace(t,-1),i}static sortColumnsForIncreasingMoments(t,e){const i=[t.indexedColumnWithWeight(0,e.x),t.indexedColumnWithWeight(1,e.y),t.indexedColumnWithWeight(2,e.z)].sort(((t,e)=>t.w<e.w?-1:t.w>e.w?1:0));t.setColumnsPoint4dXYZ(i[0],i[1],i[2]),t.determinant()<0&&t.scaleColumnsInPlace(-1,-1,-1),t.at(0,0)<0&&t.scaleColumnsInPlace(-1,-1,1),t.at(2,2)<0&&t.scaleColumnsInPlace(1,-1,-1),e.set(i[0].w,i[1].w,i[2].w)}static pointsToPrincipalAxes(t){const e=new Ei;return 0===t.length?e:(e.clearSums(t[0]),e.accumulatePointMomentsFromOrigin(t),this.inertiaProductsToPrincipalAxes(e.origin,e.sums))}static inertiaProductsToPrincipalAxes(t,e){const i=new Ei;if(i.sums.setFrom(e),i.origin.setFrom(t),!i.shiftOriginAndSumsToCentroidOfSums())return;const s=i.sums.matrixPart(),n=i.sums.weight();n<0&&s.scaleColumnsInPlace(-1,-1,-1);const r=Ei.momentTensorFromInertiaProducts(s),o=$.create(),a=xt.createZero();return r.fastSymmetricEigenvalues(a,o),o.x<0?void 0:(Ei.sortColumnsForIncreasingMoments(a,o),n<0&&a.scaleColumnsInPlace(1,-1,-1),i.localToWorldMap=pt.createOriginAndMatrix(i.origin,a),i.radiusOfGyration.set(Math.sqrt(Math.abs(o.x)),Math.sqrt(Math.abs(o.y)),Math.sqrt(Math.abs(o.z))),i.radiusOfGyration.scaleInPlace(1/Math.sqrt(Math.abs(n))),i.absoluteQuantity=Math.abs(n),i)}static areEquivalentPrincipalAxes(t,e){if(t&&e&&Q.isSameCoordinate(t.quantitySum,e.quantitySum)&&t.localToWorldMap.getOrigin().isAlmostEqual(e.localToWorldMap.getOrigin())&&t.radiusOfGyration.isAlmostEqual(e.radiusOfGyration)){if(Q.isSameCoordinate(t.radiusOfGyration.x,t.radiusOfGyration.y)){if(Q.isSameCoordinate(t.radiusOfGyration.x,t.radiusOfGyration.z))return!0;const i=t.localToWorldMap.matrix.columnZ(),s=e.localToWorldMap.matrix.columnZ();return!!i.isParallelTo(s,!0)}const i=$.create(),s=$.create();for(let n=0;n<3;n++)if(t.localToWorldMap.matrix.getColumn(n,i),e.localToWorldMap.matrix.getColumn(n,s),!i.isParallelTo(s,!0))return!1;return!0}return!1}clearSums(t){this.sums.setZero(),t?this.origin.setFrom(t):this.origin.setZero()}accumulatePointMomentsFromOrigin(t){for(const e of t)this.sums.addMomentsInPlace(e.x-this.origin.x,e.y-this.origin.y,e.z-this.origin.z,1)}shiftOriginAndSumsToCentroidOfSums(){const t=this.sums.columnW().realPoint();return!!t&&(this.shiftOriginAndSumsByXYZ(t.x,t.y,t.z),!0)}shiftOriginAndSumsByXYZ(t,e,i){this.origin.addXYZInPlace(t,e,i),this.sums.multiplyTranslationSandwichInPlace(-t,-e,-i)}shiftOriginAndSumsToNewOrigin(t){this.shiftOriginAndSumsByXYZ(t.x-this.origin.x,t.y-this.origin.y,t.z-this.origin.z)}accumulateTriangleMomentsXY(t,e,i){this.setOriginXYZIfNeeded(e.x,e.y,0);const s=this.origin.x,n=this.origin.y,r=Ei._vectorA=void 0!==t?Dt.create(t.x-s,t.y-n,0,1,Ei._vectorA):Dt.create(this.origin.x,this.origin.y,0,1,Ei._vectorA),o=Ei._vectorB=Dt.create(e.x-s,e.y-n,0,1,Ei._vectorB),a=Ei._vectorC=Dt.create(i.x-s,i.y-n,0,1,Ei._vectorC),c=Q.crossProductXYXY(o.x-r.x,o.y-r.y,a.x-r.x,a.y-r.y);if(0!==c){const t=c/12,e=c/24;this.sums.addScaledOuterProductInPlace(r,r,t),this.sums.addScaledOuterProductInPlace(r,o,e),this.sums.addScaledOuterProductInPlace(r,a,e),this.sums.addScaledOuterProductInPlace(o,r,e),this.sums.addScaledOuterProductInPlace(o,o,t),this.sums.addScaledOuterProductInPlace(o,a,e),this.sums.addScaledOuterProductInPlace(a,r,e),this.sums.addScaledOuterProductInPlace(a,o,e),this.sums.addScaledOuterProductInPlace(a,a,t)}}accumulateScaledOuterProduct(t,e){this.setOriginXYZIfNeeded(t.x,t.y,0);const i=Ei._vectorA=Dt.create(t.x-this.origin.x,t.y-this.origin.y,t.z-this.origin.z,1,Ei._vectorA);this.sums.addScaledOuterProductInPlace(i,i,e)}accumulateLineMomentsXYZ(t,e){this.setOriginXYZIfNeeded(t.x,t.y,t.z);const i=this.origin.x,s=this.origin.y,n=this.origin.z,r=Ei._vectorA=Dt.create(t.x-i,t.y-s,t.z-n,1,Ei._vectorA),o=Ei._vectorB=Dt.create(e.x-i,e.y-s,e.z-n,1,Ei._vectorB),a=t.distance(e),c=a/3,l=a/6;this.sums.addScaledOuterProductInPlace(r,r,c),this.sums.addScaledOuterProductInPlace(r,o,l),this.sums.addScaledOuterProductInPlace(o,r,l),this.sums.addScaledOuterProductInPlace(o,o,c)}accumulateTriangleToLineStringMomentsXY(t,e){const i=e.length;if(i>1){e.getPoint3dAtUncheckedPointIndex(0,this._point0);for(let s=1;s<i;s++)e.getPoint3dAtUncheckedPointIndex(s,this._point1),this.accumulateTriangleMomentsXY(t,this._point0,this._point1),this._point0.setFromPoint3d(this._point1)}}accumulateXYProductsInCentroidalFrame(t,e,i,s,n,r,o){const a=Xt.createRowValues(t,e,0,0,e,i,0,0,0,0,0,0,0,0,0,s),c=Q.crossProductXYXY(r.x,o.x,r.y,o.y),l=Xt.createRowValues(r.x,o.x,0,n.x-this.origin.x,r.y,o.y,0,n.y-this.origin.y,0,0,0,0,0,0,0,1),h=l.multiplyMatrixMatrix(a).multiplyMatrixMatrixTranspose(l);this.sums.addScaledInPlace(h,c)}accumulateProducts(t,e){this.setOriginIfNeeded(t.origin),this.sums.addTranslationSandwichInPlace(t.sums,this.origin.x-t.origin.x,this.origin.y-t.origin.y,this.origin.z-t.origin.z,e)}accumulateProductsFromOrigin(t,e,i){this.setOriginIfNeeded(t),this.sums.addTranslationSandwichInPlace(e,this.origin.x-t.x,this.origin.y-t.y,this.origin.z-t.z,i)}toJSON(){return{origin:this.origin,sums:this.sums.toJSON(),radiusOfGyration:this.radiusOfGyration.toJSON(),localToWorld:this.localToWorldMap.toJSON()}}}class Ri extends Pe{constructor(t,e,i){super(),this._geometry1=i,this._fraction=e}handleLineSegment3d(t){if(this._geometry1 instanceof Ce){const e=this._geometry1;return Ce.create(t.startPoint().interpolate(this._fraction,e.startPoint()),t.endPoint().interpolate(this._fraction,e.endPoint()))}}handleLineString3d(t){if(this._geometry1 instanceof Me){const e=this._geometry1;if(t.numPoints()===e.numPoints()){const i=t.numPoints(),s=Me.create(),n=j.create(),r=j.create(),o=j.create(),a=this._fraction;for(let c=0;c<i;c++)t.pointAt(c,r),e.pointAt(c,o),r.interpolate(a,o,n),s.addPoint(n);if(t.fractions&&e.fractions)for(let n=0;n<i;n++)s.addFraction(Q.interpolate(t.fractions.atUncheckedIndex(n),a,e.fractions.atUncheckedIndex(n)));if(t.strokeData&&e.strokeData&&(s.strokeData=t.strokeData.clone()),t.packedDerivatives&&e.packedDerivatives){const n=$.create(),r=$.create();for(let o=0;o<i;o++)t.packedDerivatives.getVector3dAtCheckedVectorIndex(o,n),e.packedDerivatives.getVector3dAtCheckedVectorIndex(o,r),s.addDerivative(n.interpolate(a,r))}return s}}}handleArc3d(t){if(this._geometry1 instanceof Ti){const e=this._geometry1;return Ti.create(t.center.interpolate(this._fraction,e.center),t.vector0.interpolate(this._fraction,e.vector0),t.vector90.interpolate(this._fraction,e.vector90),t.sweep.interpolate(this._fraction,e.sweep))}}static interpolateBetween(t,e,i){const s=new Ri(t,e,i);return t.dispatchToGeometryHandler(s)}}class Di extends Ot{constructor(t){super(),this.geometryCategory="solid",this._capped=t}get capped(){return this._capped}set capped(t){this._capped=t}}class Xi extends Di{constructor(t,e,i,s){super(s),this.solidPrimitiveType="cone",this._localToWorld=t,this._radiusA=e,this._radiusB=i,this._maxRadius=Math.max(this._radiusA,this._radiusB)}clone(){return new Xi(this._localToWorld.clone(),this._radiusA,this._radiusB,this.capped)}getConstructiveFrame(){return this._localToWorld.cloneRigid()}tryTransformInPlace(t){return!t.matrix.isSingular()&&(t.multiplyTransformTransform(this._localToWorld,this._localToWorld),!0)}cloneTransformed(t){const e=this.clone();return t.multiplyTransformTransform(e._localToWorld,e._localToWorld),e}static createAxisPoints(t,e,i,s,n){const r=t.vectorTo(e),o=r.magnitude();if(Q.isSmallMetricDistance(o))return;if((i=Q.correctSmallMetricDistance(i))*(s=Q.correctSmallMetricDistance(s))<0)return;if(i+s===0)return;const a=xt.createRigidHeadsUp(r);a.scaleColumns(1,1,o,a);const c=pt.createOriginAndMatrix(t,a);return new Xi(c,i,s,n)}static createBaseAndTarget(t,e,i,s,n,r,o){n=Math.abs(Q.correctSmallMetricDistance(n)),r=Math.abs(Q.correctSmallMetricDistance(r));const a=t.vectorTo(e),c=pt.createOriginAndMatrixColumns(t,i,s,a);return new Xi(c,n,r,o)}getCenterA(){return this._localToWorld.multiplyXYZ(0,0,0)}getCenterB(){return this._localToWorld.multiplyXYZ(0,0,1)}getVectorX(){return this._localToWorld.matrix.columnX()}getVectorY(){return this._localToWorld.matrix.columnY()}getRadiusA(){return this._radiusA}getRadiusB(){return this._radiusB}getMaxRadius(){return this._maxRadius}vFractionToRadius(t){return Q.interpolate(this._radiusA,t,this._radiusB)}isSameGeometryClass(t){return t instanceof Xi}isAlmostEqual(t){return t instanceof Xi&&this.capped===t.capped&&!!this._localToWorld.isAlmostEqualAllowZRotation(t._localToWorld)&&Q.isSameCoordinate(this._radiusA,t._radiusA)&&Q.isSameCoordinate(this._radiusB,t._radiusB)}dispatchToGeometryHandler(t){return t.handleCone(this)}strokeConstantVSection(t,e,i){let s=16;void 0!==e?s=e:void 0!==i&&(s=i.defaultCircleStrokes),s=Q.clampToStartEnd(s,4,64);const n=this.vFractionToRadius(t),r=Me.createForStrokes(e,i),o=2*Math.PI,a=o/s;let c=0;const l=r.fractions,h=r.packedDerivatives,d=r.packedUVParams,u=r.packedSurfaceNormals,f=j.create(),g=$.create(),p=$.create(),m=$.create(),x=this._localToWorld;let _,y,v,P;for(let e=0;e<=s;e++)c=2*e<=s?e*a:(e-s)*a,v=Math.cos(c),P=Math.sin(c),_=n*v,y=n*P,x.multiplyXYZ(_,y,t,f),r.addPoint(f),l&&l.push(e/s),h&&(x.matrix.multiplyXYZ(-y*o,_*o,0,g),h.push(g)),u&&(x.matrix.multiplyXYZ(-P,v,0,g),x.matrix.multiplyXYZ(0,0,1,p),g.unitCrossProduct(p,m),u.push(m)),d&&d.pushXY(e/s,t);return r}constantVSection(t){const e=this.vFractionToRadius(t),i=this._localToWorld,s=i.multiplyXYZ(0,0,t),n=i.matrix.multiplyXYZ(e,0,0),r=i.matrix.multiplyXYZ(0,e,0);return hi.create(Ti.create(s,n,r))}extendRange(t,e){const i=this.constantVSection(0),s=this.constantVSection(1);i.extendRange(t,e),s.extendRange(t,e)}uvFractionToPoint(t,e,i){const s=t*Math.PI*2,n=Q.interpolate(this._radiusA,e,this._radiusB),r=Math.cos(s),o=Math.sin(s);return this._localToWorld.multiplyXYZ(n*r,n*o,e,i)}uvFractionToPointAndTangents(t,e,i){const s=t*Math.PI*2,n=Q.interpolate(this._radiusA,e,this._radiusB),r=this._radiusB-this._radiusA,o=Math.cos(s),a=Math.sin(s),c=2*Math.PI;return Et.createOriginAndVectors(this._localToWorld.multiplyXYZ(n*o,n*a,e),this._localToWorld.multiplyVectorXYZ(-n*a*c,n*o*c,0),this._localToWorld.multiplyVectorXYZ(r*o,r*a,1),i)}get isClosedVolume(){return this.capped}maxIsoParametricDistance(){const t=this._localToWorld.matrix.columnX(),e=this._localToWorld.matrix.columnY(),i=this._localToWorld.matrix.columnZ(),s=t.unitCrossProduct(e),n=s.dotProduct(i),r=i.plusScaled(s,n).magnitudeXY();return J.create(2*Math.PI*Math.max(this._radiusA,this._radiusB),Q.hypotenuseXY(Math.abs(this._radiusB-this._radiusA)+r,n))}}class zi{constructor(t,e=8,i){this._data=new Float64Array(e*t),this._inUse=0,this._blockSize=t>0?t:1,this._growthFactor=void 0!==i&&i>=1?i:1.5}copyData(t,e,i){let s=void 0!==i?i*this.numPerBlock:0;if(s<0&&(s=0),s>=this._data.length)return{count:0,offset:0};let n=void 0!==e?e*this.numPerBlock:t.length;return n>0&&(n>t.length&&(n=t.length),s+n>this._data.length&&(n=this._data.length-s),n%this.numPerBlock!=0&&(n-=n%this.numPerBlock)),n<=0?{count:0,offset:0}:(n===t.length?this._data.set(t,s):t instanceof Float64Array?this._data.set(t.subarray(0,n),s):this._data.set(t.slice(0,n),s),{count:n/this.numPerBlock,offset:s/this.numPerBlock})}clone(){const t=new zi(this.numPerBlock,this.numBlocks,this._growthFactor);return t.copyData(this._data,this.numBlocks),t._inUse=this.numBlocks,t}get length(){return this._inUse}get numBlocks(){return this._inUse}get numPerBlock(){return this._blockSize}getWithinBlock(t,e){return this._data[t*this._blockSize+e]}clear(){this._inUse=0}blockCapacity(){return this._data.length/this._blockSize}ensureBlockCapacity(t,e=!0){if(t>this.blockCapacity()){e&&(t*=this._growthFactor);const i=this._data;this._data=new Float64Array(t*this._blockSize),this.copyData(i,this._inUse)}}addBlock(t){const e=this.newBlockIndex();let i=t.length;i>this._blockSize&&(i=this._blockSize);for(let s=0;s<i;s++)this._data[e+s]=t[s]}newBlockIndex(){const t=this._blockSize*this._inUse;t+1>this._data.length&&this.ensureBlockCapacity(1+this._inUse),this._inUse++;for(let e=t;e<t+this._blockSize;e++)this._data[e]=0;return t}popBlock(){this._inUse>0&&this._inUse--}blockIndexToDoubleIndex(t){return this._blockSize*t}checkedComponent(t,e){if(!(t>=this._inUse||t<0||e<0||e>=this._blockSize))return this._data[this._blockSize*t+e]}component(t,e){return this._data[this._blockSize*t+e]}static compareLexicalBlock(t,e,i,s){let n=0,r=0;for(let o=0;o<e;o++){if(n=t[i+o],r=t[s+o],n>r)return 1;if(n<r)return-1}return i-s}sortIndicesLexical(t=(t,e,i,s)=>zi.compareLexicalBlock(t,e,i,s)){const e=this._inUse,i=new Uint32Array(e),s=this._data,n=this._blockSize;for(let t=0;t<e;t++)i[t]=t;return i.sort(((e,i)=>t(s,n,e*n,i*n))),i}distanceBetweenBlocks(t,e){let i=0,s=this.blockIndexToDoubleIndex(t),n=this.blockIndexToDoubleIndex(e),r=0;const o=this._data;for(let t=0;t<this._blockSize;t++)r=o[s++]-o[n++],i+=r*r;return Math.sqrt(i)}distanceBetweenSubBlocks(t,e,i,s){let n=0;const r=this.blockIndexToDoubleIndex(t),o=this.blockIndexToDoubleIndex(e);let a=0;const c=this._data;for(let t=i;t<s;t++)a=c[r+t]-c[o+t],n+=a*a;return Math.sqrt(n)}}class Ni extends zi{static sortVectorComponent(t){let e=1;for(let i=1;i<t;i++)e*=Ni._vectorFactor;return e}constructor(t,e,i){super(1+t+e,i),this._numExtraDataPerPoint=e,this._numCoordinatePerPoint=t}addBlock(t){const e=this.newBlockIndex()+1,i=Math.min(this.numPerBlock-1,t.length);for(let s=0;s<i;s++)this._data[e+s]=t[s]}addDirect(t,e,i,s,n){const r=this.newBlockIndex();this._data[r+1]=t,void 0!==e&&(this._data[r+2]=e),void 0!==i&&(this._data[r+3]=i),void 0!==s&&(this._data[r+4]=s),void 0!==n&&(this._data[r+5]=n)}addPoint2d(t,e,i,s){const n=this.newBlockIndex();this._data[n+1]=t.x,this._data[n+2]=t.y,void 0!==e&&(this._data[n+3]=e),void 0!==i&&(this._data[n+4]=i),void 0!==s&&(this._data[n+5]=s)}addPoint3d(t,e,i,s){const n=this.newBlockIndex();this._data[n+1]=t.x,this._data[n+2]=t.y,this._data[n+3]=t.z,void 0!==e&&(this._data[n+4]=e),void 0!==i&&(this._data[n+5]=i),void 0!==s&&(this._data[n+6]=s)}getPoint2d(t,e){const i=this.blockIndexToDoubleIndex(t);return H.create(this._data[i+1],this._data[i+2],e)}getPoint3d(t,e){const i=this.blockIndexToDoubleIndex(t);return j.create(this._data[i+1],this._data[i+2],this._data[i+3],e)}getExtraData(t,e){const i=this.blockIndexToDoubleIndex(t);return this._data[i+1+this._numCoordinatePerPoint+e]}getData(t,e){const i=this.blockIndexToDoubleIndex(t);return this._data[i+e]}setExtraData(t,e,i){const s=this.blockIndexToDoubleIndex(t);this._data[s+1+this._numCoordinatePerPoint+e]=i}static isClusterTerminator(t){return t===Ni.clusterTerminator}clusterIndicesLexical(t=Q.smallMetricDistance){this.setupPrimaryClusterSort();const e=this.sortIndicesLexical(),i=new Uint32Array(2*e.length);let s=0;const n=this.numBlocks;let r=0,o=0,a=0,c=0,l=0;const h=1+this._numCoordinatePerPoint;for(c=0;c<n;c++)if(r=e[c],!Ni.isClusterTerminator(r)){for(i[s++]=r,a=this.component(r,0)+t,e[c]=Ni.clusterTerminator,l=c+1;l<n;l++)if(o=e[l],o!==Ni.clusterTerminator){if(this.component(o,0)>=a)break;this.distanceBetweenSubBlocks(r,o,1,h)<t&&(i[s++]=o,e[l]=Ni.clusterTerminator)}i[s++]=Ni.clusterTerminator}return i.slice(0,s)}setupPrimaryClusterSort(){const t=this.numBlocks,e=this._numCoordinatePerPoint,i=new Float64Array(e);i[0]=1;for(let t=1;t<e;t++)i[t]=i[t-1]*Ni._vectorFactor;let s=0,n=0;const r=this._data;for(let o=0;o<t;o++){s=this.blockIndexToDoubleIndex(o),n=0;for(let t=0;t<e;t++)n+=i[t]*r[s+1+t];r[s]=n}}toJSON(){const t=[];for(let e=0;e<this.numBlocks;e++){let i=this.blockIndexToDoubleIndex(e);const s=[e,this._data[i++]],n=[];for(let t=0;t<this._numCoordinatePerPoint;t++)n.push(this._data[i++]);s.push(n);for(let t=0;t<this._numExtraDataPerPoint;t++)s.push(this._data[i++]);t.push(s)}return t}createIndexBlockToClusterIndex(t){const e=this.numBlocks,i=new Uint32Array(e);i.fill(Ni.clusterTerminator);let s=0;for(const n of t)n>=e?s++:i[n]=s;return i}createIndexBlockToClusterStart(t){const e=t.length,i=this.numBlocks,s=new Uint32Array(i),n=Ni.clusterTerminator;s.fill(n);let r=0;for(let n=0;n<e;n++){const e=t[n];e>i?r=n+1:s[e]=r}return s}countClusters(t){let e=0;const i=Ni.clusterTerminator;for(const s of t)s===i&&e++;return e}createIndexClusterToClusterStart(t){let e=this.countClusters(t);const i=new Uint32Array(e),s=Ni.clusterTerminator;i.fill(s);const n=t.length;let r=0;for(let o=0;o<n;o++)t[o]===s?r=o+1:o===r&&(i[e++]=r);return i}sortSubsetsBySingleKey(t,e){const i=1+e;let s,n,r,o=0;const a=t.length;for(let e=0;e<a;e++)if(t[e]===Ni.clusterTerminator){for(let a=o;a+1<e;a++){n=this.getWithinBlock(t[a],i);for(let o=a+1;o<e;o++)r=this.getWithinBlock(t[o],i),r<n&&(s=t[a],t[a]=t[o],t[o]=s,n=r)}o=e+1}}static clusterPoint3dArray(t,e=Q.smallMetricDistance){const i=new Ni(3,0,t.length);t.forEach((t=>{i.addDirect(t.x,t.y,t.z)}));const s=i.clusterIndicesLexical(e),n=new Yi(t.length);let r=0,o=0;return s.forEach((e=>{Ni.isClusterTerminator(e)?(r++,o=0):(0===o&&n.packedPoints.push(t[e].clone()),n.oldToNew[e]=r,o++)})),n}static clusterNumberArray(t,e=Q.smallMetricDistance){const i=new Ni(1,0,t.length);t.forEach((t=>{i.addDirect(t)}));const s=i.clusterIndicesLexical(e),n=new Vi(t.length);let r=0,o=0;return s.forEach((e=>{Ni.isClusterTerminator(e)?(r++,o=0):(0===o&&n.packedNumbers.push(t[e]),n.oldToNew[e]=r,o++)})),n}static clusterGrowablePoint2dArray(t,e=Q.smallMetricDistance){const i=new Ni(2,0,t.length),s=H.create(),n=t.length;for(let e=0;e<n;e++)t.getPoint2dAtUncheckedPointIndex(e,s),i.addDirect(s.x,s.y);const r=i.clusterIndicesLexical(e),o=i.countClusters(r),a=new Bi(t.length,o);let c=0,l=0;return r.forEach((e=>{Ni.isClusterTerminator(e)?(c++,l=0):(0===l&&a.growablePackedPoints.pushFromGrowableXYArray(t,e),a.oldToNew[e]=c,l++)})),a}static clusterGrowablePoint3dArray(t,e=Q.smallMetricDistance){const i=new Ni(3,0,t.length),s=j.create(),n=t.length;for(let e=0;e<n;e++)t.getPoint3dAtUncheckedPointIndex(e,s),i.addDirect(s.x,s.y,s.z);const r=i.clusterIndicesLexical(e),o=new Yi(t.length),a=i.countClusters(r);o.growablePackedPoints=new nt(a);let c=0,l=0;return r.forEach((e=>{Ni.isClusterTerminator(e)?(c++,l=0):(0===l&&o.growablePackedPoints.pushFromGrowableXYZArray(t,e),o.oldToNew[e]=c,l++)})),o}}function Oi(t,e){let i=0;return t.forEach(((t,s,n)=>{t<e.length?n[s]=e[t]:i++})),0===i}Ni._vectorFactor=.8732,Ni.clusterTerminator=4294967295;class Yi{constructor(t){this.packedPoints=[],this.oldToNew=new Uint32Array(t);for(let e=0;e<t;e++)this.oldToNew[e]=Yi.invalidIndex}updateIndices(t){return Oi(t,this.oldToNew)}}Yi.invalidIndex=4294967295;class Bi{constructor(t,e){this.growablePackedPoints=new Fe(e),this.oldToNew=new Uint32Array(t);for(let e=0;e<t;e++)this.oldToNew[e]=Bi.invalidIndex}updateIndices(t){return Oi(t,this.oldToNew)}}Bi.invalidIndex=4294967295;class Vi{constructor(t){this.packedNumbers=[],this.oldToNew=new Uint32Array(t);for(let e=0;e<t;e++)this.oldToNew[e]=Yi.invalidIndex}updateIndices(t){return Oi(t,this.oldToNew)}}Vi.invalidIndex=4294967295,function(t){t[t.Scalar=0]="Scalar",t[t.Distance=1]="Distance",t[t.Vector=2]="Vector",t[t.Normal=3]="Normal"}(F||(F={}));class Li{constructor(t,e){if(this.input=t,e instanceof Float64Array){this.values=[];for(const t of e)this.values.push(t)}else this.values=e}copyValues(t,e,i,s){for(let n=0;n<s;n++)this.values[e*s+n]=t.values[i*s+n]}clone(){return new Li(this.input,this.values.slice())}isAlmostEqual(t,e){const i=e||1e-8;return Math.abs(this.input-t.input)<i&&he.isAlmostEqual(this.values,t.values,i)}}class Ui{constructor(t,e,i,s){this.data=t,this.dataType=e,this.name=i,this.inputName=s}clone(){const t=[];for(const e of this.data)t.push(e.clone());return new Ui(t,this.dataType,this.name,this.inputName)}isAlmostEqual(t,e){if(this.dataType!==t.dataType||this.name!==t.name||this.inputName!==t.inputName||this.data.length!==t.data.length)return!1;for(let i=0;i<this.data.length;i++)if(!this.data[i].isAlmostEqual(t.data[i],e))return!1;return!0}static isScalar(t){return t===F.Distance||t===F.Scalar}get isScalar(){return Ui.isScalar(this.dataType)}static entriesPerValue(t){return this.isScalar(t)?1:3}get entriesPerValue(){return Ui.entriesPerValue(this.dataType)}get valueCount(){return 0===this.data.length?0:this.data[0].values.length/this.entriesPerValue}get scalarRange(){if(!this.isScalar)return;const t=ft.createNull();for(const e of this.data)t.extendArray(e.values);return t}computeDisplacementRange(t=1,e){if(e=ut.createNull(e),F.Vector===this.dataType)for(const i of this.data){const s=i.values;for(let i=0;i<s.length;i+=3)e.extendXYZ(s[i]*t,s[i+1]*t,s[i+2]*t)}return e}}class Zi{constructor(t,e){this.channels=t,this.indices=e}clone(){const t=this.channels.map((t=>t.clone()));return new Zi(t,this.indices.slice())}isAlmostEqual(t,e){if(!he.isExactEqual(this.indices,t.indices)||this.channels.length!==t.channels.length)return!1;for(let i=0;i<this.channels.length;i++)if(!this.channels[i].isAlmostEqual(t.channels[i],e))return!1;return!0}static isAlmostEqual(t,e,i){return t===e||!(!t||!e)&&t.isAlmostEqual(e,i)}createForVisitor(){const t=[];for(const e of this.channels){const i=[];for(const t of e.data)i.push(new Li(t.input,[]));t.push(new Ui(i,e.dataType,e.name,e.inputName))}return new Zi(t,[])}tryTransformInPlace(t){let e;const i=t.matrix,s=i.determinant(),n=Math.pow(Math.abs(s),1/3)*(s>=0?1:-1);for(const t of this.channels)for(const s of t.data)switch(t.dataType){case F.Scalar:continue;case F.Distance:for(let t=0;t<s.values.length;t++)s.values[t]*=n;break;case F.Normal:if(e=e??i.inverse(),!e)return!1;qi(s.values,(t=>e.multiplyTransposeVectorInPlace(t)));break;case F.Vector:qi(s.values,(t=>i.multiplyVectorInPlace(t)))}return!0}}function qi(t,e){const i=new j;for(let s=0;s<t.length;s+=3)i.set(t[s],t[s+1],t[s+2]),e(i),t[s]=i.x,t[s+1]=i.y,t[s+2]=i.z}!function(t){let e,i,s;!function(t){t[t.SubdivisionSurface=-1e3]="SubdivisionSurface"}(e=t.TaggedNumericTagType||(t.TaggedNumericTagType={})),function(t){t[t.ChooseBasedOnFacets=0]="ChooseBasedOnFacets",t[t.CatmullClark=1]="CatmullClark",t[t.Loop=2]="Loop",t[t.DooSabin=3]="DooSabin"}(i=t.SubdivisionMethod||(t.SubdivisionMethod={})),function(t){t[t.FixedDepth=-100]="FixedDepth",t[t.AbsoluteTolerance=-101]="AbsoluteTolerance",t[t.FractionOfRangeBoxTolerance=-102]="FractionOfRangeBoxTolerance"}(s=t.SubdivisionControlCode||(t.SubdivisionControlCode={}))}(k||(k={}));class Wi{constructor(t=0,e=0,i,s){this.tagA=t,this.tagB=e,i&&(this.intData=i),s&&(this.doubleData=s)}pushIntPair(t,e){this.intData||(this.intData=[]),this.intData.push(t),this.intData.push(e)}pushIndexedDouble(t,e){this.intData||(this.intData=[]),this.doubleData||(this.doubleData=[]),this.intData.push(t),this.intData.push(this.doubleData.length),this.doubleData.push(e)}tagToInt(t,e,i,s){if(this.intData)for(let s=0;s+1<this.intData.length;s+=2)if(this.intData[s]===t)return Math.min(Math.max(this.intData[s+1],e),i);return s}tagToIndexedDouble(t,e,i,s){if(this.intData)for(let n=0;n+1<this.intData.length;n+=2)if(this.intData[n]===t)return Q.clamp(this.getDoubleData(this.intData[n+1],s),e,i);return s}getDoubleData(t,e){return this.doubleData&&0<=t&&t<this.doubleData.length?this.doubleData[t]:e}isAlmostEqual(t){return void 0!==t&&this.tagA===t.tagA&&this.tagB===t.tagB&&Q.exactEqualNumberArrays(this.intData,t.intData)&&Q.almostEqualArrays(this.doubleData,t.doubleData,((t,e)=>Q.isAlmostEqualNumber(t,e)))}static areAlmostEqual(t,e){return void 0===t&&void 0===e||void 0!==t&&void 0!==e&&t.isAlmostEqual(e)}clone(t){return t||(t=new Wi(this.tagA,this.tagB)),this.intData&&(t.intData=this.intData.slice()),this.doubleData&&(t.doubleData=this.doubleData.slice()),t}}class Gi{constructor(t=!1,e=!1,i=!1,s=!1){this.point=new nt,this.pointIndex=[],t&&(this.normal=new nt,this.normalIndex=[]),e&&(this.param=new Fe,this.paramIndex=[]),i&&(this.color=[],this.colorIndex=[]),this.face=[],this.edgeVisible=[],this._twoSided=s,this._expectedClosure=0}clone(){const t=new Gi;return t.point=this.point.clone(),t.pointIndex=this.pointIndex.slice(),this.normal&&(t.normal=this.normal.clone()),this.normalIndex&&(t.normalIndex=this.normalIndex.slice()),this.param&&(t.param=this.param.clone()),this.paramIndex&&(t.paramIndex=this.paramIndex.slice()),this.color&&(t.color=this.color.slice()),this.colorIndex&&(t.colorIndex=this.colorIndex.slice()),t.face=this.face.slice(),this.auxData&&(t.auxData=this.auxData.clone()),this.taggedNumericData&&(t.taggedNumericData=this.taggedNumericData.clone()),t.edgeVisible=this.edgeVisible.slice(),t.twoSided=this.twoSided,t.expectedClosure=this.expectedClosure,t}isAlmostEqual(t){return!!(nt.isAlmostEqual(this.point,t.point)&&he.isExactEqual(this.pointIndex,t.pointIndex)&&nt.isAlmostEqual(this.normal,t.normal)&&he.isExactEqual(this.normalIndex,t.normalIndex)&&Fe.isAlmostEqual(this.param,t.param)&&he.isExactEqual(this.paramIndex,t.paramIndex)&&he.isExactEqual(this.color,t.color)&&he.isExactEqual(this.colorIndex,t.colorIndex)&&Zi.isAlmostEqual(this.auxData,t.auxData)&&Wi.areAlmostEqual(this.taggedNumericData,t.taggedNumericData)&&he.isExactEqual(this.edgeVisible,t.edgeVisible)&&this.twoSided===t.twoSided&&this.expectedClosure===t.expectedClosure)}get requireNormals(){return void 0!==this.normal}get requireParams(){return void 0!==this.param}get requireColors(){return void 0!==this.color}get pointCount(){return this.point.length}get normalCount(){return this.normal?this.normal.length:0}get paramCount(){return this.param?this.param.length:0}get colorCount(){return this.color?this.color.length:0}get indexCount(){return this.pointIndex.length}get faceCount(){return this.face.length}getPoint(t,e){return this.point.getPoint3dAtCheckedPointIndex(t,e)}getNormal(t,e){return this.normal?this.normal.getVector3dAtCheckedVectorIndex(t,e):void 0}getParam(t,e){return this.param?this.param.getPoint2dAtCheckedPointIndex(t,e):void 0}getColor(t){return this.color?this.color[t]:0}getEdgeVisible(t){return this.edgeVisible[t]}get twoSided(){return this._twoSided}set twoSided(t){this._twoSided=t}get expectedClosure(){return this._expectedClosure}set expectedClosure(t){this._expectedClosure=t}setTaggedNumericData(t){this.taggedNumericData=t}copyPointTo(t,e){this.point.getPoint3dAtUncheckedPointIndex(t,e)}copyNormalTo(t,e){this.normal&&this.normal.getVector3dAtUncheckedVectorIndex(t,e)}copyParamTo(t,e){this.param&&this.param.getPoint2dAtUncheckedPointIndex(t,e)}isAlmostEqualParamIndexUV(t,e,i){return void 0!==this.param&&t>=0&&t<this.param.length&&Q.isSameCoordinate(e,this.param.getXAtUncheckedPointIndex(t))&&Q.isSameCoordinate(i,this.param.getYAtUncheckedPointIndex(t))}gatherIndexedData(t,e,i,s){const n=i-e;s>n&&(s=n);const r=n+s;this.resizeAllArrays(r);for(let i=0;i<n;i++)this.point.transferFromGrowableXYZArray(i,t.point,t.pointIndex[e+i]);for(let t=0;t<s;t++)this.point.transferFromGrowableXYZArray(n+t,this.point,t);for(let i=0;i<n;i++)this.pointIndex[i]=t.pointIndex[e+i];for(let t=0;t<s;t++)this.pointIndex[n+t]=this.pointIndex[t];if(this.normal&&this.normalIndex&&t.normal&&t.normalIndex){for(let i=0;i<n;i++)this.normal.transferFromGrowableXYZArray(i,t.normal,t.normalIndex[e+i]);for(let t=0;t<s;t++)this.normal.transferFromGrowableXYZArray(n+t,this.normal,t);for(let i=0;i<n;i++)this.normalIndex[i]=t.normalIndex[e+i];for(let t=0;t<s;t++)this.normalIndex[n+t]=this.normalIndex[t]}if(this.param&&this.paramIndex&&t.param&&t.paramIndex){for(let i=0;i<n;i++)this.param.transferFromGrowableXYArray(i,t.param,t.paramIndex[e+i]);for(let t=0;t<s;t++)this.param.transferFromGrowableXYArray(n+t,this.param,t);for(let i=0;i<n;i++)this.paramIndex[i]=t.paramIndex[e+i];for(let t=0;t<s;t++)this.paramIndex[n+t]=this.paramIndex[t]}if(this.color&&this.colorIndex&&t.color&&t.colorIndex){for(let i=0;i<n;i++)this.color[i]=t.color[t.colorIndex[e+i]];for(let t=0;t<s;t++)this.color[n+t]=this.color[t];for(let i=0;i<n;i++)this.colorIndex[i]=t.colorIndex[e+i];for(let t=0;t<s;t++)this.colorIndex[n+t]=this.colorIndex[t]}for(let i=0;i<n;i++)this.edgeVisible[i]=t.edgeVisible[e+i];for(let t=0;t<s;t++)this.edgeVisible[n+t]=this.edgeVisible[t];if(this.auxData&&t.auxData&&this.auxData.channels.length===t.auxData.channels.length){for(let i=0;i<this.auxData.channels.length;i++){const r=this.auxData.channels[i],o=t.auxData.channels[i],a=r.entriesPerValue;if(r.data.length===o.data.length)for(let i=0;i<r.data.length;i++){const c=r.data[i],l=o.data[i];for(let i=0;i<n;i++)c.copyValues(l,i,t.auxData.indices[e+i],a);for(let e=0;e<s;e++)c.copyValues(c,t.auxData.indices[n+e],e,a)}}for(let i=0;i<n;i++)this.auxData.indices[i]=t.auxData.indices[e+i];for(let t=0;t<s;t++)this.auxData.indices[n+t]=this.auxData.indices[t]}}static trimArray(t,e){t&&e<t.length&&(t.length=e)}trimAllIndexArrays(t){if(Gi.trimArray(this.pointIndex,t),Gi.trimArray(this.paramIndex,t),Gi.trimArray(this.normalIndex,t),Gi.trimArray(this.colorIndex,t),Gi.trimArray(this.edgeVisible,t),this.auxData){Gi.trimArray(this.auxData.indices,t);for(const e of this.auxData.channels)for(const i of e.data)Gi.trimArray(i.values,e.entriesPerValue*t)}}resizeAllArrays(t){if(t>this.point.length){for(;this.point.length<t;)this.point.push(j.create());for(;this.pointIndex.length<t;)this.pointIndex.push(-1);if(this.normal)for(;this.normal.length<t;)this.normal.push($.create());if(this.normalIndex)for(;this.normalIndex.length<t;)this.normalIndex.push(-1);if(this.param)for(;this.param.length<t;)this.param.push(H.create());if(this.paramIndex)for(;this.paramIndex.length<t;)this.paramIndex.push(-1);if(this.color)for(;this.color.length<t;)this.color.push(0);if(this.colorIndex)for(;this.colorIndex.length<t;)this.colorIndex.push(-1);for(;this.edgeVisible.length<t;)this.edgeVisible.push(!1);if(this.auxData){for(const e of this.auxData.channels)for(const i of e.data)for(;i.values.length<t*e.entriesPerValue;)i.values.push(0);this.auxData.indices&&this.auxData.indices.push(-1)}}else if(t<this.point.length&&(this.point.resize(t),this.pointIndex.length=t,this.normal&&this.normal.resize(t),this.normalIndex&&(this.normalIndex.length=t),this.param&&this.param.resize(t),this.paramIndex&&(this.paramIndex.length=t),this.color&&(this.color.length=t),this.colorIndex&&(this.colorIndex.length=t),this.edgeVisible.length=t,this.auxData)){for(const e of this.auxData.channels)for(const i of e.data)i.values.length=t*e.entriesPerValue;this.auxData.indices&&(this.auxData.indices.length=t)}}resizeAllDataArrays(t){if(t>this.point.length){for(;this.point.length<t;)this.point.push(j.create());for(;this.pointIndex.length<t;)this.pointIndex.push(-1);for(;this.edgeVisible.length<t;)this.edgeVisible.push(!1);if(this.normal)for(;this.normal.length<t;)this.normal.push($.create());if(this.param)for(;this.param.length<t;)this.param.push(H.create());if(this.color)for(;this.color.length<t;)this.color.push(0);if(this.auxData)for(const e of this.auxData.channels)for(const i of e.data)for(;i.values.length<t*e.entriesPerValue;)i.values.push(0)}else if(t<this.point.length&&(this.point.resize(t),this.edgeVisible.length=t,this.pointIndex.length=t,this.normal&&this.normal.resize(t),this.param&&this.param.resize(t),this.color&&(this.color.length=t),this.auxData))for(const e of this.auxData.channels)for(const i of e.data)i.values.length=t*e.entriesPerValue}range(t,e){return(t=t||ut.createNull()).extendArray(this.point,e),t}tryTransformInPlace(t){return this.point.multiplyTransformInPlace(t),this.normal&&!t.matrix.isIdentity&&this.normal.multiplyAndRenormalizeMatrix3dInverseTransposeInPlace(t.matrix),void 0===this.auxData||this.auxData.tryTransformInPlace(t)}compress(t=Q.smallMetricDistance){const e=Ni.clusterGrowablePoint3dArray(this.point,t);if(this.point=e.growablePackedPoints,e.updateIndices(this.pointIndex),this.normalIndex&&this.normal){const t=Ni.clusterGrowablePoint3dArray(this.normal);this.normal=t.growablePackedPoints,t.updateIndices(this.normalIndex)}if(this.paramIndex&&this.param){const t=Ni.clusterGrowablePoint2dArray(this.param);this.param=t.growablePackedPoints,t.updateIndices(this.paramIndex)}if(this.colorIndex&&this.color){const t=Ni.clusterNumberArray(this.color);this.color=t.packedNumbers,t.updateIndices(this.colorIndex)}if(this.auxData&&1===this.auxData.channels.length&&1===this.auxData.channels[0].data.length){const t=this.auxData.channels[0].entriesPerValue;if(1===t){const t=Ni.clusterNumberArray(this.auxData.channels[0].data[0].values);this.auxData.channels[0].data[0].values=t.packedNumbers,t.updateIndices(this.auxData.indices)}else if(3===t){const t=nt.create(this.auxData.channels[0].data[0].values),e=Ni.clusterGrowablePoint3dArray(t);this.auxData.channels[0].data[0].values=he.create(e.growablePackedPoints.float64Data()),e.updateIndices(this.auxData.indices)}}}static isValidFacetStartIndexArray(t){if(0===t.length)return!1;for(let e=0;e+1<t.length;e++)if(t[e]>=t[e+1])return!1;return!0}static reverseIndices(t,e,i){if(!e||0===e.length)return!0;if(e.length>0&&t[t.length-1]===e.length){for(let s=0;s+1<t.length;s++){let n=t[s],r=t[s+1];if(i)for(;r>n+2;){r--,n++;const t=e[n];e[n]=e[r],e[r]=t}else for(;r>n+1;){r--;const t=e[n];e[n]=e[r],e[r]=t,n++}}return!0}return!1}static reverseIndicesSingleFacet(t,e,i,s){if(!i||0===i.length)return!0;if(i.length>0&&e[e.length-1]===i.length&&t>=0&&t+1<e.length){let n=e[t],r=e[t+1];if(s)for(;r>n+2;){r--,n++;const t=i[n];i[n]=i[r],i[r]=t}else for(;r>n+1;){r--;const t=i[n];i[n]=i[r],i[r]=t,n++}return!0}return!1}reverseIndices(t){t&&Gi.isValidFacetStartIndexArray(t)&&(Gi.reverseIndices(t,this.pointIndex,!0),this.normalIndex!==this.pointIndex&&Gi.reverseIndices(t,this.normalIndex,!0),this.paramIndex!==this.pointIndex&&Gi.reverseIndices(t,this.paramIndex,!0),this.colorIndex!==this.pointIndex&&Gi.reverseIndices(t,this.colorIndex,!0),Gi.reverseIndices(t,this.edgeVisible,!1))}reverseIndicesSingleFacet(t,e){Gi.reverseIndicesSingleFacet(t,e,this.pointIndex,!0),this.normalIndex!==this.pointIndex&&Gi.reverseIndicesSingleFacet(t,e,this.normalIndex,!0),this.paramIndex!==this.pointIndex&&Gi.reverseIndicesSingleFacet(t,e,this.paramIndex,!0),this.colorIndex!==this.pointIndex&&Gi.reverseIndicesSingleFacet(t,e,this.colorIndex,!0),Gi.reverseIndicesSingleFacet(t,e,this.edgeVisible,!1)}reverseNormals(){this.normal&&this.normal.scaleInPlace(-1)}}Gi.planarityLocalRelTol=1e-13;class Hi extends Gi{constructor(t,e){super(t.data.normalCount>0,t.data.paramCount>0,t.data.colorCount>0,t.twoSided),this._polyface=t,this._numWrap=e,t.data.auxData&&(this.auxData=t.data.auxData.createForVisitor()),this.reset(),this._numEdges=0,this._nextFacetIndex=0,this._currentFacetIndex=-1}clientPolyface(){return this._polyface}getVisitableFacetCount(){return this._polyface.facetCount}setNumWrap(t){this._numWrap=t}get numEdgesThisFacet(){return this._numEdges}static create(t,e){return new Hi(t,e)}moveToReadIndex(t){return!!this._polyface.isValidFacetIndex(t)&&(this._currentFacetIndex=t,this._nextFacetIndex=t+1,this._numEdges=this._polyface.numEdgeInFacet(t),this.resizeAllArrays(this._numEdges+this._numWrap),this.gatherIndexedData(this._polyface.data,this._polyface.facetIndex0(this._currentFacetIndex),this._polyface.facetIndex1(this._currentFacetIndex),this._numWrap),!0)}moveToNextFacet(){return this._nextFacetIndex!==this._currentFacetIndex?this.moveToReadIndex(this._nextFacetIndex):(this._nextFacetIndex++,!0)}reset(){this.moveToReadIndex(0),this._nextFacetIndex=0}tryGetDistanceParameter(t,e){if(t<0||t>=this.numEdgesThisFacet)return;if(void 0===this.param||0===this._polyface.data.face.length)return;const i=this._polyface.tryGetFaceData(this._currentFacetIndex);return i?i.convertParamXYToDistance(this.param.getXAtUncheckedPointIndex(t),this.param.getYAtUncheckedPointIndex(t),e):void 0}tryGetNormalizedParameter(t,e){if(t<0||t>=this.numEdgesThisFacet)return;if(void 0===this.param||0===this._polyface.data.face.length)return;const i=this._polyface.tryGetFaceData(this._currentFacetIndex);return i?i.convertParamXYToNormalized(this.param.getXAtUncheckedPointIndex(t),this.param.getYAtUncheckedPointIndex(t),e):void 0}currentReadIndex(){return this._currentFacetIndex}clientPointIndex(t){return this.pointIndex[t]}clientParamIndex(t){return this.paramIndex?this.paramIndex[t]:-1}clientNormalIndex(t){return this.normalIndex?this.normalIndex[t]:-1}clientColorIndex(t){return this.colorIndex?this.colorIndex[t]:-1}clientAuxIndex(t){return this.auxData?this.auxData.indices[t]:-1}clearArrays(){this.point.length=0,this.edgeVisible.length=0,void 0!==this.param&&(this.param.length=0),void 0!==this.normal&&(this.normal.length=0),void 0!==this.color&&(this.color.length=0)}pushDataFrom(t,e){this.point.pushFromGrowableXYZArray(t.point,e),this.edgeVisible.push(t.edgeVisible[e]),this.param&&t.param&&e<t.param.length&&this.param.pushFromGrowableXYArray(t.param,e),this.normal&&t.normal&&e<t.normal.length&&this.normal.pushFromGrowableXYZArray(t.normal,e),this.color&&t.color&&e<t.color.length&&this.color.push(t.color[e])}pushInterpolatedDataFrom(t,e,i,s){e>s&&this.pushInterpolatedDataFrom(t,s,1-i,e),this.point.pushInterpolatedFromGrowableXYZArray(t.point,e,i,s);const n=(e+1)%t.edgeVisible.length===s&&t.edgeVisible[e];this.edgeVisible.push(n),this.param&&t.param&&e<t.param.length&&s<t.param.length&&this.param.pushInterpolatedFromGrowableXYArray(t.param,e,i,s),this.normal&&t.normal&&e<t.normal.length&&s<t.normal.length&&this.normal.pushInterpolatedFromGrowableXYZArray(t.normal,e,i,s),this.color&&t.color&&e<t.color.length&&s<t.color.length&&this.color.push(Q.interpolateColor(t.color[e],i,t.color[s]))}}class Ji extends Hi{constructor(t,e,i){super(t,i),this._parentFacetIndices=e.slice(),this._currentActiveIndex=-1,this._nextActiveIndex=0}isValidSubsetIndex(t){return void 0!==this._parentFacetIndices&&t>=0&&t<this._parentFacetIndices.length}static createSubsetVisitor(t,e,i=0){return new Ji(t,e,i)}moveToReadIndex(t){return!!this.isValidSubsetIndex(t)&&(this._currentActiveIndex=t,this._nextActiveIndex=t+1,super.moveToReadIndex(this._parentFacetIndices[t]))}moveToNextFacet(){return this._nextActiveIndex!==this._currentActiveIndex?this.moveToReadIndex(this._nextActiveIndex):(this._nextActiveIndex++,!0)}reset(){this.moveToReadIndex(0),this._nextActiveIndex=0}parentFacetIndex(t){return void 0===t&&(t=this._currentActiveIndex),this.isValidSubsetIndex(t)?this._parentFacetIndices[t]:void 0}getVisitableFacetCount(){return this._parentFacetIndices?this._parentFacetIndices.length:0}static createNormalComparison(t,e=$.unitZ(),i=W.createSmallAngle(),s=0){if(t instanceof ji)return this.createNormalComparison(t.createVisitor(),e,i,s);const n=t,r=[],o=$.createZero();for(n.reset();n.moveToNextFacet();)Ur.unitNormal(n.point,o)&&(o.dotProduct(e)<0||o.angleFromPerpendicular(e).isMagnitudeLessThanOrEqual(i)||r.push(n.currentReadIndex()));return Ji.createSubsetVisitor(n.clientPolyface(),r,s)}}class Qi{get paramDistanceRange(){return this._paramDistanceRange}get paramRange(){return this._paramRange}constructor(t,e){this._paramDistanceRange=t,this._paramRange=e}static createNull(){return new Qi(gt.createNull(),gt.createNull())}clone(t){return t?(this._paramDistanceRange.clone(t._paramDistanceRange),this._paramRange.clone(t._paramRange),t):new Qi(this._paramDistanceRange.clone(),this._paramRange.clone())}setNull(){this._paramDistanceRange.setNull(),this._paramRange.setNull()}convertParamXYToDistance(t,e,i){i=i||H.create();const s=this._paramRange.high.minus(this._paramRange.low);return i.x=0===s.x?t:this._paramDistanceRange.low.x+(t-this._paramRange.low.x)*(this._paramDistanceRange.high.x-this._paramDistanceRange.low.x)/s.x,i.y=0===s.y?e:this.paramDistanceRange.low.y+(e-this._paramRange.low.y)*(this._paramDistanceRange.high.y-this._paramDistanceRange.low.y)/s.y,i}convertParamXYToNormalized(t,e,i){i=i||H.create();const s=this._paramRange.high.minus(this._paramRange.low);return i.x=0===s.x?t:(t-this._paramRange.low.x)/s.x,i.y=0===s.y?e:(e-this._paramRange.low.y)/s.y,i}convertParamToDistance(t,e){return this.convertParamXYToDistance(t.x,t.y,e)}convertParamToNormalized(t,e){return this.convertParamXYToNormalized(t.x,t.y,e)}scaleDistances(t){this._paramDistanceRange.low.x*=t,this._paramDistanceRange.low.y*=t,this._paramDistanceRange.high.x*=t,this._paramDistanceRange.high.y*=t}setParamDistanceRangeFromNewFaceData(t,e,i){const s=H.create(),n=H.create();this.setNull();let r=0;const o=Hi.create(t,0);if(!o.moveToReadIndex(e)||i<=e)return!1;do{const t=o.numEdgesThisFacet,e=o.point,i=[],a=o.param,c=[];if(!a)return!1;a.extendRange(this._paramRange);const l=J.create(),h=J.create();for(let o=0;o<t;o++){if(i[2]=o,c[2]=o,o>1){a.vectorIndexIndex(c[1],c[0],l),a.vectorIndexIndex(c[1],c[2],h);const t=e.getPoint3dAtUncheckedPointIndex(i[0]).minus(e.getPoint3dAtUncheckedPointIndex(i[1])),o=e.getPoint3dAtUncheckedPointIndex(i[1]).minus(e.getPoint3dAtUncheckedPointIndex(i[2])),d=Math.abs(l.x*h.y-h.x*l.y);if(d){const e=j.createFrom(t);e.scaleInPlace(h.y),e.addScaledInPlace(o,-l.y);const i=j.createFrom(o);i.scaleInPlace(l.x),i.addScaledInPlace(t,-h.x);const a=H.create(e.magnitude()/d,i.magnitude()/d);s.x+=a.x,s.y+=a.y,n.x+=a.x*a.x,n.y+=a.y*a.y,r++}}c[0]=c[1],c[1]=c[2],i[0]=i[1],i[1]=i[2]}}while(o.moveToNextFacet()&&o.currentReadIndex()<i);if(0!==r){const t=H.create(s.x/r,s.y/r),e=H.create(Math.sqrt(Math.abs(n.x/r-t.x*t.x)),Math.sqrt(Math.abs(n.y/r-t.y*t.y)));this._paramDistanceRange.low.set(0,0),this._paramDistanceRange.high.set((t.x+e.x)*(this._paramRange.high.x-this._paramRange.low.x),(t.y+e.y)*(this._paramRange.high.y-this._paramRange.low.y))}return!0}}class Ki extends Ot{constructor(t){super(),this.geometryCategory="polyface",this.data=t}get twoSided(){return this.data.twoSided}set twoSided(t){this.data.twoSided=t}get expectedClosure(){return this.data.expectedClosure}set expectedClosure(t){this.data.expectedClosure=t}static areIndicesValid(t,e,i,s,n){if(void 0===t&&void 0===s)return!0;if(void 0===t||void 0===s)return!1;if(e<0||e>=t.length)return!1;if(i<=e||i>t.length)return!1;for(let s=e;s<i;s++)if(t[s]<0||t[s]>=n)return!1;return!0}get facetCount(){}}class ji extends Ki{constructor(t,e,i){super(t),e?this._facetStart=e.slice():(this._facetStart=[],this._facetStart.push(0)),this._facetToFaceData=i?i.slice():[]}isSameGeometryClass(t){return t instanceof ji}isAlmostEqual(t){return t instanceof ji&&this.data.isAlmostEqual(t.data)&&he.isExactEqual(this._facetStart,t._facetStart)&&he.isExactEqual(this._facetToFaceData,t._facetToFaceData)}get isEmpty(){return 0===this.data.pointCount||0===this.data.pointIndex.length}tryTransformInPlace(t){return!!this.data.tryTransformInPlace(t)&&(t.matrix.determinant()<0&&(this.reverseIndices(),this.reverseNormals()),!0)}reverseSingleFacet(t){this.data.reverseIndicesSingleFacet(t,this._facetStart)}clone(){return new ji(this.data.clone(),this._facetStart.slice(),this._facetToFaceData.slice())}cloneTransformed(t){const e=this.clone();return e.tryTransformInPlace(t),e}reverseIndices(){this.data.reverseIndices(this._facetStart)}reverseNormals(){this.data.reverseNormals()}tryGetFaceData(t){if(t<0||t>=this._facetToFaceData.length)return;const e=this._facetToFaceData[t];return e<0||e>=this.data.face.length?void 0:this.data.face[e]}addIndexedPolyface(t,e,i){const s=t.facetCount,n=this.data.point.length,r=j.create();for(let e=0;e<t.data.point.length;e++)t.data.point.getPoint3dAtUncheckedPointIndex(e,r),i?(i.multiplyPoint3d(r,r),this.addPoint(r)):this.addPoint(r);for(let i=0;i<s;i++){const s=t._facetStart[i],r=t._facetStart[i+1];if(e)for(let e=r;e-- >s;)this.addPointIndex(n+t.data.pointIndex[e],t.data.edgeVisible[e>s?e-1:r-1]);else for(let e=s;e<r;e++)this.addPointIndex(n+t.data.pointIndex[e],t.data.edgeVisible[e]);this.terminateFacet(!1)}if(void 0!==this.data.param&&void 0!==t.data.param&&void 0!==t.data.paramIndex){const i=this.data.param.length;this.data.param.pushFromGrowableXYArray(t.data.param);for(let n=0;n<s;n++){const s=t._facetStart[n],r=t._facetStart[n+1];if(e)for(let e=r;e-- >s;)this.addParamIndex(i+t.data.paramIndex[e]);else for(let e=s;e<r;e++)this.addParamIndex(i+t.data.paramIndex[e])}}if(void 0!==this.data.normal&&void 0!==t.data.normal&&void 0!==t.data.normalIndex){const n=this.data.normal.length;for(let s=0;s<t.data.normal.length;s++){const n=t.data.normal.getVector3dAtCheckedVectorIndex(s);i&&i.multiplyVector(n,n),e&&n.scaleInPlace(-1),this.addNormal(n)}for(let i=0;i<s;i++){const s=t._facetStart[i],r=t._facetStart[i+1];if(e)for(let e=r;e-- >s;)this.addNormalIndex(n+t.data.normalIndex[e]);else for(let e=s;e<r;e++)this.addNormalIndex(n+t.data.normalIndex[e])}}if(void 0!==this.data.color&&void 0!==t.data.color&&void 0!==t.data.colorIndex){const i=this.data.color.length;for(const e of t.data.color)this.addColor(e);for(let n=0;n<s;n++){const s=t._facetStart[n],r=t._facetStart[n+1];if(e)for(let e=r;e-- >s;)this.addColorIndex(i+t.data.colorIndex[e]);else for(let e=s;e<r;e++)this.addColorIndex(i+t.data.colorIndex[e])}}if(0!==t.data.face.length){const e=this.data.face.length;for(const e of t.data.face){const t=e.clone();this.data.face.push(t)}for(const i of t._facetToFaceData)this._facetToFaceData.push(e+i)}}get zeroTerminatedIndexCount(){return this.data.pointIndex.length+this._facetStart.length-1}static create(t=!1,e=!1,i=!1,s=!1){return new ji(new Gi(t,e,i,s))}addPoint(t,e){if(void 0!==e){const i=this.data.point.distanceIndexToPoint(e,t);if(void 0!==i&&Q.isSmallMetricDistance(i))return e}return this.data.point.pushXYZ(t.x,t.y,t.z),this.data.point.length-1}addPointXYZ(t,e,i){return this.data.point.pushXYZ(t,e,i),this.data.point.length-1}addParam(t){return this.data.param||(this.data.param=new Fe),this.data.param.push(t),this.data.param.length-1}addParamUV(t,e,i,s){return this.data.param||(this.data.param=new Fe),void 0!==i&&this.data.isAlmostEqualParamIndexUV(i,t,e)?i:void 0!==s&&this.data.isAlmostEqualParamIndexUV(s,t,e)?s:(this.data.param.pushXY(t,e),this.data.param.length-1)}addNormal(t,e,i){const s=e=>{const i=this.data.normal.distanceIndexToPoint(e,t);return void 0!==i&&Q.isSmallMetricDistance(i)};if(void 0!==this.data.normal){if(void 0!==e&&s(e))return e;if(void 0!==i&&s(i))return i;if(void 0!==e||void 0!==i){const t=this.data.normal.length-1;if(s(t))return t}}return this.addNormalXYZ(t.x,t.y,t.z)}addNormalXYZ(t,e,i){return this.data.normal||(this.data.normal=new nt),this.data.normal.pushXYZ(t,e,i),this.data.normal.length-1}addColor(t){return this.data.color||(this.data.color=[]),this.data.color.push(t),this.data.color.length-1}addPointIndex(t,e=!0){this.data.pointIndex.push(t),this.data.edgeVisible.push(e)}addNormalIndex(t){this.data.normalIndex||(this.data.normalIndex=[]),this.data.normalIndex.push(t)}addParamIndex(t){this.data.paramIndex||(this.data.paramIndex=[]),this.data.paramIndex.push(t)}addColorIndex(t){this.data.colorIndex||(this.data.colorIndex=[]),this.data.colorIndex.push(t)}cleanupOpenFacet(){this.data.trimAllIndexArrays(this.data.pointIndex.length)}validateAllIndices(t=0,e){const i=this.data.pointIndex.length,s=e??[];return this.data.normalIndex&&this.data.normalIndex.length!==i&&s.push("normalIndex count must match pointIndex count"),this.data.paramIndex&&this.data.paramIndex.length!==i&&s.push("paramIndex count must equal pointIndex count"),this.data.colorIndex&&this.data.colorIndex.length!==i&&s.push("colorIndex count must equal pointIndex count"),this.data.edgeVisible.length!==i&&s.push("visibleIndex count must equal pointIndex count"),Ki.areIndicesValid(this.data.pointIndex,t,i,this.data.point,this.data.point?this.data.point.length:0)||s.push("invalid point indices in the last facet"),Ki.areIndicesValid(this.data.normalIndex,t,i,this.data.normal,this.data.normal?this.data.normal.length:0)||s.push("invalid normal indices in the last facet"),Ki.areIndicesValid(this.data.paramIndex,t,i,this.data.param,this.data.param?this.data.param.length:0)||s.push("invalid param indices in the last facet"),Ki.areIndicesValid(this.data.colorIndex,t,i,this.data.color,this.data.color?this.data.color.length:0)||s.push("invalid color indices in the last facet"),0===s.length}terminateFacet(t=!0){const e=this._facetStart.length-1,i=this._facetStart[e],s=this.data.pointIndex.length;if(t){const t=[];if(s<i+2&&t.push("Less than 3 indices in the last facet"),this.validateAllIndices(i,t),t.length>0)return this.data.trimAllIndexArrays(i),t}this._facetStart.push(s)}get facetCount(){return this._facetStart.length-1}get faceCount(){return this.data.faceCount}get pointCount(){return this.data.pointCount}get colorCount(){return this.data.colorCount}get paramCount(){return this.data.paramCount}get normalCount(){return this.data.normalCount}isValidFacetIndex(t){return t>=0&&t<this.facetCount}numEdgeInFacet(t){return this.isValidFacetIndex(t)?this._facetStart[t+1]-this._facetStart[t]:0}facetIndex0(t){return this._facetStart[t]}facetIndex1(t){return this._facetStart[t+1]}createVisitor(t=0){return Hi.create(this,t)}range(t,e){return this.data.range(e,t)}extendRange(t,e){this.data.range(t,e)}getFaceDataByFacetIndex(t){return this.data.face[this._facetToFaceData[t]]}setNewFaceData(t=0){const e=this._facetToFaceData.length;if(e>=this._facetStart.length)return!1;0===t&&(t=this._facetStart.length);const i=Qi.createNull(),s=Hi.create(this,0);if(!s.moveToReadIndex(e))return!1;const n=void 0!==this.data.param,r=i.paramRange.isNull&&n;do{r&&void 0!==s.param&&s.param.extendRange(i.paramRange)}while(s.moveToNextFacet()&&s.currentReadIndex()<t);n&&0!==this.data.param.length&&i.paramDistanceRange.isNull&&i.setParamDistanceRangeFromNewFaceData(this,e,t),this.data.face.push(i);const o=this.data.face.length-1;for(let e=this._facetToFaceData.length;e<t;e++)this._facetToFaceData.push(0===this._facetStart[e]?0:o);return!0}dispatchToGeometryHandler(t){return t.handleIndexedPolyface(this)}}class $i{get tolerance(){return this._tolerance}constructor(t=Q.smallMetricDistance){this._tolerance=t}static create(t=Q.smallMetricDistance){return new $i(t)}static assignDetailInterpolatedFractionsAndPoints(t,e,i,s,n,r=!1){r?(t.fraction=i,t.fraction1=e):(t.fraction=e,t.fraction1=i),t.point=s.interpolate(t.fraction,n,t.point),t.point1=s.interpolate(t.fraction1,n,t.point1)}projectPointToSegmentXY(t,e,i){this._vectorU=$.createStartEnd(e,i,this._vectorU),this._vectorV=$.createStartEnd(e,t,this._vectorV);const s=this._vectorU.dotProductXY(this._vectorU),n=this._vectorU.dotProductXY(this._vectorV),r=Q.safeDivideFraction(n,s,0);return vt.createCurveFractionPoint(void 0,r,e.interpolate(r,i))}clampCoincidentOverlapToSegmentBounds(t,e,i,s,n,r=!1,o=!1,a=!1,c=!1){const l=Re.create(t.detailA.fraction,t.detailA.hasFraction1?t.detailA.fraction1:t.detailA.fraction),h=Re.create(t.detailB.fraction,t.detailB.hasFraction1?t.detailB.fraction1:t.detailB.fraction),d=l.signedDelta()<0,u=()=>{const r=l.x0,o=l.x1,a=h.x0,c=h.x1;return $i.assignDetailInterpolatedFractionsAndPoints(t.detailA,r,o,e,i,r>o),$i.assignDetailInterpolatedFractionsAndPoints(t.detailB,a,c,s,n,a>c),t},f=l.clampDirectedTo01(!r,!o,!1),g=h.clampDirectedTo01(!a,!c,!1);if(f&&g){if(Q.isAlmostEqualNumber(l.absoluteDelta(),h.absoluteDelta(),Q.smallFraction))return u();if(l.clampDirectedTo01(!0,!0,!1)&&h.clampDirectedTo01(!0,!0,!1))return u()}const p=(e,i,s,n)=>(e.clone(t.detailA.point),i.clone(t.detailB.point),t.detailA.fraction=s?0:1,t.detailB.fraction=n?0:1,t.detailA.collapseToStart(),t.detailB.collapseToStart(),t),m=l.clampDirectedTo01(!0,!0,!0),x=h.clampDirectedTo01(!0,!0,!0);if(m&&x){const r=t.detailA.point1??t.detailA.point;if(d){if(t.detailA.point.isAlmostEqual(e,this.tolerance))return p(e,s,!0,!0);if(r.isAlmostEqual(i,this.tolerance))return p(i,n,!1,!1)}else{if(r.isAlmostEqual(e,this.tolerance))return p(e,n,!0,!1);if(t.detailA.point.isAlmostEqual(i,this.tolerance))return p(i,s,!1,!0)}}}coincidentSegmentRangeXY(t,e,i,s,n=!0){const r=this.projectPointToSegmentXY(t,i,s);if(t.distanceXY(r.point)>this._tolerance)return;const o=this.projectPointToSegmentXY(e,i,s);if(e.distanceXY(o.point)>this._tolerance)return;const a=this.projectPointToSegmentXY(i,t,e);if(i.distanceXY(a.point)>this._tolerance)return;const c=this.projectPointToSegmentXY(s,t,e);if(s.distanceXY(c.point)>this._tolerance)return;r.fraction1=o.fraction,r.point1=o.point,a.fraction1=c.fraction,a.point1=c.point;const l=Pt.createCapture(a,r);return n?this.clampCoincidentOverlapToSegmentBounds(l,t,e,i,s):l}createDetailPair(t,e,i,s,n,r){const o=n-s,a=Q.conditionalDivideFraction(i.x0-s,o),c=Q.conditionalDivideFraction(i.x1-s,o);if(void 0!==a&&void 0!==c){const s=vt.createCurveEvaluatedFractionFraction(t,i.x0,i.x1),n=vt.createCurveEvaluatedFractionFraction(e,a,c);return r&&s.swapFractionsAndPoints(),Pt.createCapture(s,n)}}appendDetailPair(t,e){return void 0===e?t:void 0===t?[e]:(t.push(e),t)}coincidentArcIntersectionXY(t,i,s=!0){let n;if(t.center.isAlmostEqual(i.center,this.tolerance)){const s=t.matrixRef.multiplyMatrixInverseMatrix(i.matrixRef);if(s){const r=s.at(0,0),o=s.at(1,0),a=s.at(0,1),c=s.at(1,1),l=Q.hypotenuseXY(r,o),h=Q.hypotenuseXY(a,c),d=Q.dotProductXYXY(r,o,a,c),u=Q.crossProductXYXY(r,o,a,c);if(Q.isAlmostEqualNumber(l,1)&&Q.isAlmostEqualNumber(h,1)&&Q.isAlmostEqualNumber(0,d)){const s=Math.atan2(o,r),a=u>0?1:-1,c=s+a*i.sweep.startRadians,l=s+a*i.sweep.endRadians,h=a*t.sweep.sweepRadians*i.sweep.sweepRadians<0,d=At.createStartEndRadians(c,l),f=t.sweep,g=f.fractionPeriod(),p=f.radiansToPositivePeriodicFraction(d.startRadians);e(p>=0);const m=p+d.sweepRadians/f.sweepRadians,x=(e,s)=>{const r=n?n.length:0,o=e.x0,a=e.x1;if(e.clampDirectedTo01()&&!Q.isSmallRelative(e.absoluteDelta()))n=this.appendDetailPair(n,this.createDetailPair(t,i,e,o,a,h));else{const e=h?s:!s,r=this._point0=s?t.startPoint(this._point0):t.endPoint(this._point0),o=this._point1=e?i.startPoint(this._point1):i.endPoint(this._point1);if(r.isAlmostEqual(o,this.tolerance)){const a=vt.createCurveFractionPoint(t,s?0:1,r),c=vt.createCurveFractionPoint(i,e?0:1,o);n=this.appendDetailPair(n,Pt.createCapture(a,c))}}return void 0!==n&&n.length>r};x(Re.create(p,m),!1),m>=g?x(Re.create(p-g,m-g),!0):0===p&&x(Re.create(p+g,m+g),!0)}}}return n}}class ts extends Ae{constructor(t,e,i,s,n=Q.smallMetricDistance){super(),this._extendA0=e,this._extendA1=e,this._geometryB=i,this._extendB0=s,this._extendB1=s,this._worldToLocalPerspective=void 0,this._worldToLocalAffine=void 0,void 0===t||t.isIdentity()||(this._worldToLocalAffine=t.asTransform,this._worldToLocalAffine||(this._worldToLocalPerspective=t.clone())),this._coincidentGeometryContext=$i.create(n),this._results=[]}resetGeometry(t){this._geometryB=t}acceptFraction(t,e,i,s=1e-12){return!(!t&&e<-s||!i&&e>1+s)}acceptFractionOnLine(t,e,i,s,n,r=Q.smallMetricDistance){return!t&&e<0?Q.isDistanceWithinTol(e*s.distanceXY(n),r):!(!i&&e>1)||Q.isDistanceWithinTol((e-1)*s.distanceXY(n),r)}grabPairedResults(t=!1){const e=this._results;return t&&(this._results=[]),e}recordPointWithLocalFractions(t,e,i,s,n,r,o,a,c,l){let h,d,u,f;const g=void 0!==l&&l.detailA.hasFraction1&&l.detailB.hasFraction1;g?(h=Q.interpolate(i,l.detailA.fraction,s),d=Q.interpolate(o,l.detailB.fraction,a),u=Q.interpolate(i,l.detailA.fraction1,s),f=Q.interpolate(o,l.detailB.fraction1,a)):(h=u=Q.interpolate(i,t,s),d=f=Q.interpolate(o,n,a));const p=this._results.length;if(p>0&&!g){const t=this._results[p-1].detailA,i=this._results[p-1].detailB;if(c){if(i.isSameCurveAndFraction({curve:e,fraction:h})&&t.isSameCurveAndFraction({curve:r,fraction:d}))return}else if(t.isSameCurveAndFraction({curve:e,fraction:h})&&i.isSameCurveAndFraction({curve:r,fraction:d}))return}const m=vt.createCurveFractionPoint(e,h,e.fractionToPoint(h)),x=vt.createCurveFractionPoint(r,d,r.fractionToPoint(d));g?(m.captureFraction1Point1(u,e.fractionToPoint(u)),x.captureFraction1Point1(f,r.fractionToPoint(f))):(m.setIntervalRole(P.isolated),x.setIntervalRole(P.isolated)),c?this._results.push(new Pt(x,m)):this._results.push(new Pt(m,x))}recordPairs(t,e,i,s){if(void 0!==i)for(const n of i)this.recordPointWithLocalFractions(n.detailA.fraction,t,0,1,n.detailB.fraction,e,0,1,s,n)}computeSegmentSegment3D(t,e,i,s,n,r,o,a,c,l,h,d,u,f,g){const p=ts._workVector2dA,m=this._coincidentGeometryContext.coincidentSegmentRangeXY(i,n,l,d,!1);m?this._coincidentGeometryContext.clampCoincidentOverlapToSegmentBounds(m,i,n,l,d,e,o,c,f)&&this.recordPointWithLocalFractions(m.detailA.fraction,t,s,r,m.detailB.fraction,a,h,u,g,m):Mt.lineSegment3dXYTransverseIntersectionUnbounded(i,n,l,d,p)&&this.acceptFractionOnLine(e,p.x,o,i,n,this._coincidentGeometryContext.tolerance)&&this.acceptFractionOnLine(c,p.y,f,l,d,this._coincidentGeometryContext.tolerance)&&this.recordPointWithLocalFractions(p.x,t,s,r,p.y,a,h,u,g)}computeSegmentSegment3DH(t,e,i,s,n,r,o,a,c,l,h,d,u,f,g){const p=ts._workPointA0H,m=ts._workPointA1H,x=ts._workPointB0H,_=ts._workPointB1H;this._worldToLocalPerspective.multiplyPoint3d(i,1,p),this._worldToLocalPerspective.multiplyPoint3d(n,1,m),this._worldToLocalPerspective.multiplyPoint3d(l,1,x),this._worldToLocalPerspective.multiplyPoint3d(d,1,_);const y=Mt.lineSegment3dHXYTransverseIntersectionUnbounded(p,m,x,_);if(void 0!==y){const i=y.x,n=y.y;this.acceptFraction(e,i,o)&&this.acceptFraction(c,n,f)&&this.recordPointWithLocalFractions(i,t,s,r,n,a,h,u,g)}}dispatchSegmentSegment(t,e,i,s,n,r,o,a,c,l,h,d,u,f,g){this._worldToLocalAffine?(ts.setTransformedWorkPoints(this._worldToLocalAffine,i,n,l,d),this.computeSegmentSegment3D(t,e,ts._workPointA0,s,ts._workPointA1,r,o,a,c,ts._workPointB0,h,ts._workPointB1,u,f,g)):this._worldToLocalPerspective?this.computeSegmentSegment3DH(t,e,i,s,n,r,o,a,c,l,h,d,u,f,g):this.computeSegmentSegment3D(t,e,i,s,n,r,o,a,c,l,h,d,u,f,g)}dispatchSegmentArc(t,e,i,s,n,r,o,a,c,l,h){if(this._worldToLocalPerspective){const d=a.toTransformedPoint4d(this._worldToLocalPerspective),u=this._worldToLocalPerspective.multiplyPoint3d(i,1),f=this._worldToLocalPerspective.multiplyPoint3d(n,1),g=Q.tripleProductPoint4dXYW(u,f,d.center),p=Q.tripleProductPoint4dXYW(u,f,d.vector0),m=Q.tripleProductPoint4dXYW(u,f,d.vector90),x=new It(2),_=new It(2),y=new It(2),v=wt.appendImplicitLineUnitCircleIntersections(g,p,m,x,_,y);for(let i=0;i<v;i++){const n=d.center.plus2Scaled(d.vector0,x.atUncheckedIndex(i),d.vector90,_.atUncheckedIndex(i)),g=d.sweep.radiansToSignedFraction(y.atUncheckedIndex(i),c),p=Mt.lineSegment3dHXYClosestPointUnbounded(u,f,n);void 0!==p&&this.acceptFraction(e,p,o)&&this.acceptFraction(c,g,l)&&this.recordPointWithLocalFractions(p,t,s,r,g,a,0,1,h)}}else{const d=a.toTransformedVectors(this._worldToLocalAffine);let u=i,f=n;this._worldToLocalAffine&&(u=this._worldToLocalAffine.multiplyPoint3d(i),f=this._worldToLocalAffine.multiplyPoint3d(n));const g=Q.tripleProductXYW(u,1,f,1,d.center,1),p=Q.tripleProductXYW(u,1,f,1,d.vector0,0),m=Q.tripleProductXYW(u,1,f,1,d.vector90,0),x=new It(2),_=new It(2),y=new It(2),v=wt.appendImplicitLineUnitCircleIntersections(g,p,m,x,_,y),P=1e-10,A=1e-7;for(let i=0;i<v;i++){const n=d.center.plus2Scaled(d.vector0,x.atUncheckedIndex(i),d.vector90,_.atUncheckedIndex(i)),g=d.sweep.radiansToSignedFraction(y.atUncheckedIndex(i),c),p=Mt.lineSegment3dXYClosestPointUnbounded(u,f,n);void 0!==p&&this.acceptFraction(e,p,o,P)&&this.acceptFraction(c,g,l,A)&&this.recordPointWithLocalFractions(p,t,s,r,g,a,0,1,h)}}}dispatchArcArcThisOrder(t,e,i,s,n,r,o,a,c){const l=e.inverse();if(l){const e=l.multiplyMatrixMatrix(r),h=[],d=[];Tt.solveUnitCircleHomogeneousEllipseIntersection(e.coffs[2],e.coffs[5],e.coffs[8],e.coffs[0],e.coffs[3],e.coffs[6],e.coffs[1],e.coffs[4],e.coffs[7],h,d);for(let e=0;e<h.length;e++){const r=t.sweep.radiansToSignedFraction(d[e],i),l=n.sweep.radiansToSignedFraction(h[e],o);this.acceptFraction(i,r,s)&&this.acceptFraction(o,l,a)&&this.recordPointWithLocalFractions(r,t,0,1,l,n,0,1,c)}}}dispatchArcArc(t,e,i,s,n,r,o){let a,c;if(this._worldToLocalPerspective){const e=t.toTransformedPoint4d(this._worldToLocalPerspective),i=s.toTransformedPoint4d(this._worldToLocalPerspective);a=xt.createColumnsXYW(e.vector0,e.vector0.w,e.vector90,e.vector90.w,e.center,e.center.w),c=xt.createColumnsXYW(i.vector0,i.vector0.w,i.vector90,e.vector90.w,i.center,i.center.w)}else{const e=t.toTransformedVectors(this._worldToLocalAffine),i=s.toTransformedVectors(this._worldToLocalAffine);a=xt.createColumnsXYW(e.vector0,0,e.vector90,0,e.center,1),c=xt.createColumnsXYW(i.vector0,0,i.vector90,0,i.center,1)}if(a.conditionNumber()>c.conditionNumber()?this.dispatchArcArcThisOrder(t,a,e,i,s,c,n,r,o):this.dispatchArcArcThisOrder(s,c,n,r,t,a,e,i,!o),this._coincidentGeometryContext)if(this._worldToLocalPerspective);else if(this._worldToLocalAffine);else{const e=this._coincidentGeometryContext.coincidentArcIntersectionXY(t,s,!0);void 0!==e&&this.recordPairs(t,s,e,o)}}dispatchArcBsplineCurve3d(t,e,i,s,n,r,o){let a;if(this._worldToLocalPerspective){const e=t.toTransformedPoint4d(this._worldToLocalPerspective);a=xt.createColumnsXYW(e.vector0,e.vector0.w,e.vector90,e.vector90.w,e.center,e.center.w)}else{const e=t.toTransformedVectors(this._worldToLocalAffine);a=xt.createColumnsXYW(e.vector0,0,e.vector90,0,e.center,1)}const c=a.inverse();if(c){const a=s.order,l=2*a-1,h=new Float64Array(a),d=new Lt(l),u=c.at(0,0),f=c.at(0,1),g=0,p=c.at(0,2),m=c.at(1,0),x=c.at(1,1),_=0,y=c.at(1,2),v=c.at(2,0),P=c.at(2,1),A=0,I=c.at(2,2);if(c){let a;for(let c=0;a=s.getSaturatedBezierSpan3dH(c,a),a;c++){this._worldToLocalPerspective?a.tryMultiplyMatrix4dInPlace(this._worldToLocalPerspective):this._worldToLocalAffine&&a.tryTransformInPlace(this._worldToLocalAffine),d.zero(),a.poleProductsXYZW(h,u,f,g,p),d.addSquaredSquaredBezier(h,1),a.poleProductsXYZW(h,m,x,_,y),d.addSquaredSquaredBezier(h,1),a.poleProductsXYZW(h,v,P,A,I),d.addSquaredSquaredBezier(h,-1);const c=d.roots(0,!0);if(c)for(const l of c){const c=a.fractionToParentFraction(l),h=a.fractionToPoint4d(l),d=h.dotProductXYZW(u,f,g,p),v=h.dotProductXYZW(m,x,_,y),P=t.sweep.radiansToSignedFraction(Math.atan2(v,d),e);this.acceptFraction(e,P,i)&&this.acceptFraction(n,c,r)&&this.recordPointWithLocalFractions(P,t,0,1,c,s,0,1,o)}}}}}transformBeziers(t){if(this._worldToLocalAffine)for(const e of t)e.tryTransformInPlace(this._worldToLocalAffine);else if(this._worldToLocalPerspective)for(const e of t)e.tryMultiplyMatrix4dInPlace(this._worldToLocalPerspective)}getRanges(t){const e=[];e.length=0;for(const i of t)e.push(i.range());return e}dispatchBezierBezierStrokeFirst(t,e,i,s,n,r,o,a){this._xyzwA0||(this._xyzwA0=Dt.create()),this._xyzwA1||(this._xyzwA1=Dt.create()),this._xyzwPlane||(this._xyzwPlane=Dt.create()),this._xyzwB||(this._xyzwB=Dt.create()),t.fractionToPoint4d(0,this._xyzwA0);let c,l=0;const h=1/i;for(let r=1;r<=i;r++,l=c,this._xyzwA0.setFrom(this._xyzwA1)){c=r*h,t.fractionToPoint4d(c,this._xyzwA1),Dt.createPlanePointPointZ(this._xyzwA0,this._xyzwA1,this._xyzwPlane),s.poleProductsXYZW(o.coffs,this._xyzwPlane.x,this._xyzwPlane.y,this._xyzwPlane.z,this._xyzwPlane.w);const i=o.roots(0,!0);if(i)for(const r of i){let i=r;s.fractionToPoint4d(i,this._xyzwB);const o=Mt.lineSegment3dHXYClosestPointUnbounded(this._xyzwA0,this._xyzwA1,this._xyzwB);if(o&&Q.isIn01WithTolerance(o,1e-5)){let r=Q.interpolate(l,o,c);const h=new Kt(t,s),d=new Qt(h);d.setUV(r,i),d.runIterations()&&(r=d.getU(),i=d.getV());const u=t.fractionToParentFraction(r),f=s.fractionToParentFraction(i);this.acceptFraction(!1,u,!1)&&this.acceptFraction(!1,f,!1)&&this.recordPointWithLocalFractions(u,e,0,1,f,n,0,1,a)}}}}dispatchBSplineCurve3dBSplineCurve3d(t,e,i){const s=t.collectBezierSpans(!0),n=e.collectBezierSpans(!0),r=s.length,o=n.length;this.transformBeziers(s),this.transformBeziers(n);const a=this.getRanges(s),c=this.getRanges(n),l=t.order,h=e.order,d=new Lt(l),u=new Lt(h);for(let l=0;l<r;l++)for(let r=0;r<o;r++)if(a[l].intersectsRangeXY(c[r])){const o=s[l].computeStrokeCountForOptions(),a=n[r].computeStrokeCountForOptions();o<a?this.dispatchBezierBezierStrokeFirst(s[l],t,o,n[r],e,a,u,i):this.dispatchBezierBezierStrokeFirst(n[r],e,a,s[l],t,o,d,!i)}}projectPoint(t,e=1){return this._worldToLocalPerspective?this._worldToLocalPerspective.multiplyPoint3d(t,e):this._worldToLocalAffine?this._worldToLocalAffine.multiplyXYZW(t.x,t.y,t.z,e):Dt.createFromPointAndWeight(t,e)}mapNPCPlaneToWorld(t,e){this._worldToLocalAffine?this._worldToLocalAffine.multiplyTransposeXYZW(t.x,t.y,t.z,t.w,e):this._worldToLocalPerspective?this._worldToLocalPerspective.multiplyTransposePoint4d(t,e):t.clone(e)}dispatchSegmentBsplineCurve(t,e,i,s,n,r,o,a,c,l,h){const d=this.projectPoint(i),u=this.projectPoint(n),f=Dt.createPlanePointPointZ(d,u);this.mapNPCPlaneToWorld(f,f);const g=[];a.appendPlaneIntersectionPoints(f,g);for(const i of g){const n=i.fraction,f=i.point,g=this.projectPoint(f),p=Mt.lineSegment3dHXYClosestPointUnbounded(d,u,g);void 0!==p&&this.acceptFraction(e,p,o)&&this.acceptFraction(c,n,l)&&this.recordPointWithLocalFractions(p,t,s,r,n,a,0,1,h)}}dispatchLineStringBSplineCurve(t,e,i,s,n,r,o){const a=t.numPoints();if(a>1){const c=1/(a-1);let l,h;l=0;const d=ts._workPointA0,u=ts._workPointA1;t.pointAt(0,d);for(let f=1;f<a;f++,d.setFrom(u),l=h)t.pointAt(f,u),h=f*c,this.dispatchSegmentBsplineCurve(t,1===f&&e,d,l,u,h,f+1===a&&i,s,n,r,o)}}computeSegmentLineString(t,e,i,s,n,r,o){const a=t.point0Ref,c=t.point1Ref,l=ts._workPointBB0,h=ts._workPointBB1,d=s.numPoints();if(d>1){const u=1/(d-1);let f,g;f=0,s.pointAt(0,l);for(let p=1;p<d;p++,l.setFrom(h),f=g)s.pointAt(p,h),g=p*u,this.dispatchSegmentSegment(t,e,a,0,c,1,i,s,1===p&&n,l,f,h,g,p+1===d&&r,o)}}computeArcLineString(t,e,i,s,n,r,o){const a=ts._workPointBB0,c=ts._workPointBB1,l=s.numPoints();if(l>1){const h=1/(l-1);let d,u;d=0,s.pointAt(0,a);for(let f=1;f<l;f++,a.setFrom(c),d=u)s.pointAt(f,c),u=f*h,this.dispatchSegmentArc(s,1===f&&n,a,d,c,u,f+1===l&&r,t,e,i,!o)}}computeLineStringLineString(t,e,i){const s=ts._workPointAA0,n=ts._workPointAA1,r=ts._workPointBB0,o=ts._workPointBB1,a=t.numPoints(),c=e.numPoints();if(a>1&&c>1){t.pointAt(0,s);const l=1/(a-1),h=1/(c-1);let d,u,f,g=0;t.pointAt(0,s);for(let p=1;p<a;p++,s.setFrom(n),g=u){u=p*l,d=0,t.pointAt(p,n),e.pointAt(0,r);for(let l=1;l<c;l++,r.setFrom(o),d=f)e.pointAt(l,o),f=l*h,this.dispatchSegmentSegment(t,1===p&&this._extendA0,s,g,n,u,p+1===a&&this._extendA1,e,1===l&&this._extendB0,r,d,o,f,l+1===c&&this._extendB1,i)}}}static setTransformedWorkPoints(t,e,i,s,n){t.multiplyPoint3d(e,this._workPointA0),t.multiplyPoint3d(i,this._workPointA1),t.multiplyPoint3d(s,this._workPointB0),t.multiplyPoint3d(n,this._workPointB1)}dispatchCurveCollection(t,e){const i=this._geometryB;if(!(i&&i.children&&i instanceof si))return;const s=i.children,n=this._extendB0,r=this._extendB1;for(let o=0;o<s.length;o++)this.resetGeometry(s[o]),i instanceof oi&&s.length>1?0===o?this._extendB1=!1:o===s.length-1?this._extendB0=!1:this._extendB0=this._extendB1=!1:i instanceof hi&&(this._extendB0=this._extendB1=!1),e(t),this._extendB0=n,this._extendB1=r;this.resetGeometry(i)}dispatchCurveChainWithDistanceIndex(t,i){if(!(this._geometryB&&this._geometryB instanceof li))return;t instanceof li&&e(!1,"call handleCurveChainWithDistanceIndex(geomA) instead");const s=this._results.length,n=this._geometryB;this.resetGeometry(n.path),this.dispatchCurveCollection(t,i),this.resetGeometry(n),this._results=li.convertChildDetailToChainDetail(this._results,s,void 0,n,!0)}handleChildren(t){const e=t.children,i=this._extendA0,s=this._extendA1;if(e)for(let n=0;n<e.length;n++)t instanceof oi&&e.length>1?0===n?this._extendA1=!1:n===e.length-1?this._extendA0=!1:this._extendA0=this._extendA1=!1:t instanceof hi&&(this._extendA0=this._extendA1=!1),e[n].dispatchToGeometryHandler(this),this._extendA0=i,this._extendA1=s}handleLineSegment3d(t){if(this._geometryB instanceof Ce){const e=this._geometryB;this.dispatchSegmentSegment(t,this._extendA0,t.point0Ref,0,t.point1Ref,1,this._extendA1,e,this._extendB0,e.point0Ref,0,e.point1Ref,1,this._extendB1,!1)}else this._geometryB instanceof Me?this.computeSegmentLineString(t,this._extendA0,this._extendA1,this._geometryB,this._extendB0,this._extendB1,!1):this._geometryB instanceof Ti?this.dispatchSegmentArc(t,this._extendA0,t.point0Ref,0,t.point1Ref,1,this._extendA1,this._geometryB,this._extendB0,this._extendB1,!1):this._geometryB instanceof Be?this.dispatchSegmentBsplineCurve(t,this._extendA0,t.point0Ref,0,t.point1Ref,1,this._extendA1,this._geometryB,this._extendB0,this._extendB1,!1):this._geometryB instanceof si?this.dispatchCurveCollection(t,this.handleLineSegment3d.bind(this)):this._geometryB instanceof li&&this.dispatchCurveChainWithDistanceIndex(t,this.handleLineSegment3d.bind(this))}handleLineString3d(t){if(this._geometryB instanceof Me){const e=this._geometryB;this.computeLineStringLineString(t,e,!1)}else this._geometryB instanceof Ce?this.computeSegmentLineString(this._geometryB,this._extendB0,this._extendB1,t,this._extendA0,this._extendA1,!0):this._geometryB instanceof Ti?this.computeArcLineString(this._geometryB,this._extendB0,this._extendB1,t,this._extendA0,this._extendA1,!0):this._geometryB instanceof Be?this.dispatchLineStringBSplineCurve(t,this._extendA0,this._extendA1,this._geometryB,this._extendB0,this._extendB1,!1):this._geometryB instanceof si?this.dispatchCurveCollection(t,this.handleLineString3d.bind(this)):this._geometryB instanceof li&&this.dispatchCurveChainWithDistanceIndex(t,this.handleLineString3d.bind(this))}handleArc3d(t){this._geometryB instanceof Ce?this.dispatchSegmentArc(this._geometryB,this._extendB0,this._geometryB.point0Ref,0,this._geometryB.point1Ref,1,this._extendB1,t,this._extendA0,this._extendA1,!0):this._geometryB instanceof Me?this.computeArcLineString(t,this._extendA0,this._extendA1,this._geometryB,this._extendB0,this._extendB1,!1):this._geometryB instanceof Ti?this.dispatchArcArc(t,this._extendA0,this._extendA1,this._geometryB,this._extendB0,this._extendB1,!1):this._geometryB instanceof Be?this.dispatchArcBsplineCurve3d(t,this._extendA0,this._extendA1,this._geometryB,this._extendB0,this._extendB1,!1):this._geometryB instanceof si?this.dispatchCurveCollection(t,this.handleArc3d.bind(this)):this._geometryB instanceof li&&this.dispatchCurveChainWithDistanceIndex(t,this.handleArc3d.bind(this))}handleBSplineCurve3d(t){this._geometryB instanceof Ce?this.dispatchSegmentBsplineCurve(this._geometryB,this._extendB0,this._geometryB.point0Ref,0,this._geometryB.point1Ref,1,this._extendB1,t,this._extendA0,this._extendA1,!0):this._geometryB instanceof Me?this.dispatchLineStringBSplineCurve(this._geometryB,this._extendB0,this._extendB1,t,this._extendA0,this._extendA1,!0):this._geometryB instanceof Ti?this.dispatchArcBsplineCurve3d(this._geometryB,this._extendB0,this._extendB1,t,this._extendA0,this._extendA1,!0):this._geometryB instanceof Ye?this.dispatchBSplineCurve3dBSplineCurve3d(t,this._geometryB,!1):this._geometryB instanceof si?this.dispatchCurveCollection(t,this.handleBSplineCurve3d.bind(this)):this._geometryB instanceof li&&this.dispatchCurveChainWithDistanceIndex(t,this.handleBSplineCurve3d.bind(this))}handleCurveChainWithDistanceIndex(t){super.handleCurveChainWithDistanceIndex(t),this._results=li.convertChildDetailToChainDetail(this._results,0,t,void 0,!0)}handleBSplineCurve3dH(t){}}ts._workVector2dA=J.create(),ts._workPointA0H=Dt.create(),ts._workPointA1H=Dt.create(),ts._workPointB0H=Dt.create(),ts._workPointB1H=Dt.create(),ts._workPointAA0=j.create(),ts._workPointAA1=j.create(),ts._workPointBB0=j.create(),ts._workPointBB1=j.create(),ts._workPointA0=j.create(),ts._workPointA1=j.create(),ts._workPointB0=j.create(),ts._workPointB1=j.create();class es extends Ae{constructor(t,e,i){super(),this._extendA0=t,this._extendA1=t,this._geometryB=e,this._extendB0=i,this._extendB1=i,this._results=[]}resetGeometry(t){this._geometryB=t}grabPairedResults(t=!1){const e=this._results;return t&&(this._results=[]),e}acceptFraction(t,e,i,s=1e-12){return!(!t&&e<-s||!i&&e>1+s)}recordPointWithLocalFractions(t,e,i,s,n,r,o,a,c){const l=Q.interpolate(i,t,s),h=Q.interpolate(o,n,a),d=this._results.length;if(d>0){const t=this._results[d-1].detailA,i=this._results[d-1].detailB;if(c){if(i.isSameCurveAndFraction({curve:e,fraction:l})&&t.isSameCurveAndFraction({curve:r,fraction:h}))return}else if(t.isSameCurveAndFraction({curve:e,fraction:l})&&i.isSameCurveAndFraction({curve:r,fraction:h}))return}const u=e.fractionToPoint(l),f=r.fractionToPoint(h);if(!u.isAlmostEqualMetric(f))return;const g=vt.createCurveFractionPoint(e,l,u);g.setIntervalRole(P.isolated);const p=vt.createCurveFractionPoint(r,h,f);if(p.setIntervalRole(P.isolated),c){const t=new Pt(p,g);this._results.push(t)}else{const t=new Pt(g,p);this._results.push(t)}}computeSegmentSegment3D(t,e,i,s,n,r,o,a,c,l,h,d,u,f,g){const p=es._workVector2dA;Mt.lineSegment3dClosestApproachUnbounded(i,n,l,d,p)&&this.acceptFraction(e,p.x,o)&&this.acceptFraction(c,p.y,f)&&this.recordPointWithLocalFractions(p.x,t,s,r,p.y,a,h,u,g)}dispatchSegmentSegment(t,e,i,s,n,r,o,a,c,l,h,d,u,f,g){this.computeSegmentSegment3D(t,e,i,s,n,r,o,a,c,l,h,d,u,f,g)}createPlaneWithPreferredPerpendicular(t,e,i,s,n){i=Q.restrictToInterval(Math.abs(i),0,1-Q.smallFraction);const r=e.magnitudeSquared(),o=s.magnitudeSquared(),a=Math.abs(e.dotProduct(s)),c=e.unitCrossProduct(a*a<=i*i*r*o?s:n);if(c)return _t.create(t,c)}dispatchSegmentArc(t,e,i,s,n,r,o,a,c,l,h){const d=$.createStartEnd(i,n),u=this.createPlaneWithPreferredPerpendicular(i,d,.94,a.perpendicularVector,a.vector0);if(void 0!==u){const d=[];let f,g;a.appendPlaneIntersectionPoints(u,d);for(const u of d){const d=a.sweep.fractionToSignedPeriodicFraction(u.fraction,c);this.acceptFraction(c,d,l)&&(f=Mt.lineSegment3dClosestPointUnbounded(i,n,u.point),void 0!==f&&(g=i.interpolate(f,n,g),g.isAlmostEqualMetric(u.point)&&this.acceptFraction(e,f,o)&&this.recordPointWithLocalFractions(f,t,s,r,d,a,0,1,h)))}}}dispatchArcArcInPlane(t,e,i,s,n,r,o){const a=t.otherArcAsLocalVectors(s);if(void 0!==a){const c=[],l=[];Tt.solveUnitCircleHomogeneousEllipseIntersection(a.center.x,a.center.y,1,a.vector0.x,a.vector0.y,0,a.vector90.x,a.vector90.y,0,c,l);for(let a=0;a<c.length;a++){const h=t.sweep.radiansToSignedFraction(l[a],e),d=s.sweep.radiansToSignedFraction(c[a],n);this.acceptFraction(e,h,i)&&this.acceptFraction(n,d,r)&&this.recordPointWithLocalFractions(h,t,0,1,d,s,0,1,o)}}}dispatchArcArc(t,e,i,s,n,r,o){const a=_t.create(t.center,t.perpendicularVector),c=_t.create(s.center,s.perpendicularVector);if(void 0!==a&&void 0!==c)if(a.getNormalRef().isParallelTo(c.getNormalRef()))a.isPointInPlane(c.getOriginRef())&&c.isPointInPlane(a.getOriginRef())&&this.dispatchArcArcInPlane(t,e,i,s,n,r,o);else{const l=[];s.appendPlaneIntersectionPoints(a,l);const h=[];t.appendPlaneIntersectionPoints(c,h);for(const a of l)for(const c of h)if(c.point.isAlmostEqual(a.point)){const l=t.sweep.fractionToSignedPeriodicFraction(c.fraction,e),h=s.sweep.fractionToSignedPeriodicFraction(a.fraction,n);this.acceptFraction(e,l,i)&&this.acceptFraction(n,h,r)&&this.recordPointWithLocalFractions(l,t,0,1,h,s,0,1,o)}}}dispatchArcBsplineCurve3d(t,e,i,s,n,r,o){}dispatchBSplineCurve3dBSplineCurve3d(t,e,i){}dispatchSegmentBsplineCurve(t,e,i,s,n,r,o,a,c,l,h){}dispatchLineStringBSplineCurve(t,e,i,s,n,r,o){}computeSegmentLineString(t,e,i,s,n,r,o){const a=t.point0Ref,c=t.point1Ref,l=es._workPointBB0,h=es._workPointBB1,d=s.numPoints();if(d>1){const u=1/(d-1);let f,g;f=0,s.pointAt(0,l);for(let p=1;p<d;p++,l.setFrom(h),f=g)s.pointAt(p,h),g=p*u,this.dispatchSegmentSegment(t,e,a,0,c,1,i,s,1===p&&n,l,f,h,g,p+1===d&&r,o)}}computeArcLineString(t,e,i,s,n,r,o){const a=es._workPointBB0,c=es._workPointBB1,l=s.numPoints();if(l>1){const h=1/(l-1);let d,u;d=0,s.pointAt(0,a);for(let f=1;f<l;f++,a.setFrom(c),d=u)s.pointAt(f,c),u=f*h,this.dispatchSegmentArc(s,1===f&&n,a,d,c,u,f+1===l&&r,t,e,i,!o)}}computeLineStringLineString(t,e,i){const s=es._workPointAA0,n=es._workPointAA1,r=es._workPointBB0,o=es._workPointBB1,a=t.numPoints(),c=e.numPoints();if(a>1&&c>1){t.pointAt(0,s);const l=1/(a-1),h=1/(c-1);let d,u,f,g=0;t.pointAt(0,s);for(let p=1;p<a;p++,s.setFrom(n),g=u){u=p*l,d=0,t.pointAt(p,n),e.pointAt(0,r);for(let l=1;l<c;l++,r.setFrom(o),d=f)e.pointAt(l,o),f=l*h,this.dispatchSegmentSegment(t,1===p&&this._extendA0,s,g,n,u,p+1===a&&this._extendA1,e,1===l&&this._extendB0,r,d,o,f,l+1===c&&this._extendB1,i)}}}dispatchCurveCollection(t,e){const i=this._geometryB;if(!(i&&i.children&&i instanceof si))return;const s=i.children,n=this._extendB0,r=this._extendB1;for(let o=0;o<s.length;o++)this.resetGeometry(s[o]),i instanceof oi&&s.length>1?0===o?this._extendB1=!1:o===s.length-1?this._extendB0=!1:this._extendB0=this._extendB1=!1:i instanceof hi&&(this._extendB0=this._extendB1=!1),e(t),this._extendB0=n,this._extendB1=r;this.resetGeometry(i)}dispatchCurveChainWithDistanceIndex(t,i){if(!(this._geometryB&&this._geometryB instanceof li))return;t instanceof li&&e(!1,"call handleCurveChainWithDistanceIndex(geomA) instead");const s=this._results.length,n=this._geometryB;this.resetGeometry(n.path),this.dispatchCurveCollection(t,i),this.resetGeometry(n),this._results=li.convertChildDetailToChainDetail(this._results,s,void 0,n,!0)}handleChildren(t){const e=t.children,i=this._extendA0,s=this._extendA1;if(e)for(let n=0;n<e.length;n++)t instanceof oi&&e.length>1?0===n?this._extendA1=!1:n===e.length-1?this._extendA0=!1:this._extendA0=this._extendA1=!1:t instanceof hi&&(this._extendA0=this._extendA1=!1),e[n].dispatchToGeometryHandler(this),this._extendA0=i,this._extendA1=s}handleLineSegment3d(t){if(this._geometryB instanceof Ce){const e=this._geometryB;this.dispatchSegmentSegment(t,this._extendA0,t.point0Ref,0,t.point1Ref,1,this._extendA1,e,this._extendB0,e.point0Ref,0,e.point1Ref,1,this._extendB1,!1)}else this._geometryB instanceof Me?this.computeSegmentLineString(t,this._extendA0,this._extendA1,this._geometryB,this._extendB0,this._extendB1,!1):this._geometryB instanceof Ti?this.dispatchSegmentArc(t,this._extendA0,t.point0Ref,0,t.point1Ref,1,this._extendA1,this._geometryB,this._extendB0,this._extendB1,!1):this._geometryB instanceof Be?this.dispatchSegmentBsplineCurve(t,this._extendA0,t.point0Ref,0,t.point1Ref,1,this._extendA1,this._geometryB,this._extendB0,this._extendB1,!1):this._geometryB instanceof si?this.dispatchCurveCollection(t,this.handleLineSegment3d.bind(this)):this._geometryB instanceof li&&this.dispatchCurveChainWithDistanceIndex(t,this.handleLineSegment3d.bind(this))}handleLineString3d(t){if(this._geometryB instanceof Me){const e=this._geometryB;this.computeLineStringLineString(t,e,!1)}else this._geometryB instanceof Ce?this.computeSegmentLineString(this._geometryB,this._extendB0,this._extendB1,t,this._extendA0,this._extendA1,!0):this._geometryB instanceof Ti?this.computeArcLineString(this._geometryB,this._extendB0,this._extendB1,t,this._extendA0,this._extendA1,!0):this._geometryB instanceof Be?this.dispatchLineStringBSplineCurve(t,this._extendA0,this._extendA1,this._geometryB,this._extendB0,this._extendB1,!1):this._geometryB instanceof si?this.dispatchCurveCollection(t,this.handleLineString3d.bind(this)):this._geometryB instanceof li&&this.dispatchCurveChainWithDistanceIndex(t,this.handleLineString3d.bind(this))}handleArc3d(t){this._geometryB instanceof Ce?this.dispatchSegmentArc(this._geometryB,this._extendB0,this._geometryB.point0Ref,0,this._geometryB.point1Ref,1,this._extendB1,t,this._extendA0,this._extendA1,!0):this._geometryB instanceof Me?this.computeArcLineString(t,this._extendA0,this._extendA1,this._geometryB,this._extendB0,this._extendB1,!1):this._geometryB instanceof Ti?this.dispatchArcArc(t,this._extendA0,this._extendA1,this._geometryB,this._extendB0,this._extendB1,!1):this._geometryB instanceof Be?this.dispatchArcBsplineCurve3d(t,this._extendA0,this._extendA1,this._geometryB,this._extendB0,this._extendB1,!1):this._geometryB instanceof si?this.dispatchCurveCollection(t,this.handleArc3d.bind(this)):this._geometryB instanceof li&&this.dispatchCurveChainWithDistanceIndex(t,this.handleArc3d.bind(this))}handleBSplineCurve3d(t){this._geometryB instanceof Ce?this.dispatchSegmentBsplineCurve(this._geometryB,this._extendB0,this._geometryB.point0Ref,0,this._geometryB.point1Ref,1,this._extendB1,t,this._extendA0,this._extendA1,!0):this._geometryB instanceof Me?this.dispatchLineStringBSplineCurve(this._geometryB,this._extendB0,this._extendB1,t,this._extendA0,this._extendA1,!0):this._geometryB instanceof Ti?this.dispatchArcBsplineCurve3d(this._geometryB,this._extendB0,this._extendB1,t,this._extendA0,this._extendA1,!0):this._geometryB instanceof Ye?this.dispatchBSplineCurve3dBSplineCurve3d(t,this._geometryB,!1):this._geometryB instanceof si?this.dispatchCurveCollection(t,this.handleBSplineCurve3d.bind(this)):this._geometryB instanceof li&&this.dispatchCurveChainWithDistanceIndex(t,this.handleBSplineCurve3d.bind(this))}handleCurveChainWithDistanceIndex(t){super.handleCurveChainWithDistanceIndex(t),this._results=li.convertChildDetailToChainDetail(this._results,0,t,void 0,!0)}handleBSplineCurve3dH(t){}}es._workVector2dA=J.create(),es._workPointAA0=j.create(),es._workPointAA1=j.create(),es._workPointBB0=j.create(),es._workPointBB1=j.create();class is{static intersectionXYPairs(t,e,i,s,n=Q.smallMetricDistance){return is.intersectionProjectedXYPairs(void 0,t,e,i,s,n)}static intersectionProjectedXYPairs(t,e,i,s,n,r=Q.smallMetricDistance){const o=new ts(t,i,s,n,r);return e.dispatchToGeometryHandler(o),o.grabPairedResults()}static intersectionXYZPairs(t,e,i,s){const n=new es(e,i,s);return t.dispatchToGeometryHandler(n),n.grabPairedResults()}static allIntersectionsAmongPrimitivesXY(t,e=Q.smallMetricDistance){const i=new ts(void 0,!1,void 0,!1,e);for(let e=0;e<t.length;e++){const s=t[e];for(let n=e+1;n<t.length;n++)i.resetGeometry(t[n]),s.dispatchToGeometryHandler(i)}return i.grabPairedResults()}static closeApproachProjectedXYPairs(t,e,i){const s=new ui(e);return s.maxDistanceToAccept=i,t.dispatchToGeometryHandler(s),s.grabPairedResults()}static closestApproachProjectedXYPair(t,e){const i=t.range();i.extendRange(e.range());const s=i.low.distanceXY(i.high),n=this.closeApproachProjectedXYPairs(t,e,s);if(!n.length)return;let r=0,o=2*s;for(let t=0;t<n.length;++t){const e=n[t].detailA.point.distanceXY(n[t].detailB.point);e<o&&(r=t,o=e)}return n[r]}}class ss{constructor(t=Q.smallMetricDistance,e){this._chains=[],this._gapTolerance=t,this._snapTolerance=Q.smallMetricDistance,this._planeTolerance=e}findAnyChainToConnect(t,e,i=-1){for(let s=0;s<this._chains.length;s++){if(i===s)continue;const n=this._chains[s];if(this._xyzWork1=n[n.length-1].endPoint(this._xyzWork1),this._xyzWork1.isAlmostEqual(t,e))return{chainIndex:s,atEnd:!0};if(this._xyzWork1=n[0].startPoint(this._xyzWork1),this._xyzWork1.isAlmostEqual(t,e))return{chainIndex:s,atEnd:!1}}}captureCurvePrimitive(t){this._snapTolerance<this._gapTolerance&&this.attachPrimitiveToAnyChain(t,this._snapTolerance)||this.attachPrimitiveToAnyChain(t,this._gapTolerance)||this._chains.push([t])}captureCurve(t){if(t instanceof ae)this.captureCurvePrimitive(t);else if(t instanceof si)for(const e of t.children)this.captureCurve(e)}static simpleEndPointMove(t,e,i){if(t instanceof Ce)return e?t.point1Ref.setFrom(i):t.point0Ref.setFrom(i),!0;if(t instanceof Me&&t.numPoints()>0){const s=e?t.numPoints()-1:0;return t.packedPoints.setAtCheckedPointIndex(s,i),!0}return!1}static moveHeadOrTail(t,e,i){const s=t.endPoint(),n=e.startPoint(),r=.001*Q.smallMetricDistance,o=s.distanceXY(n);if(o<r)return!1;if(o<i&&(this.simpleEndPointMove(e,!1,s)||this.simpleEndPointMove(t,!0,n)))return!0;const a=is.intersectionXYPairs(t,!0,e,!0);for(const r of a){const o=r.detailA,a=r.detailB,c=o.point.distanceXY(s),l=a.point.distanceXY(n);if(c<5*i&&l<5*i&&t instanceof Ti&&e instanceof Ti){const i=t.sweep.fractionToRadians(o.fraction);t.sweep.setStartEndRadians(t.sweep.startRadians,i);const s=e.sweep.fractionToRadians(a.fraction);return e.sweep.setStartEndRadians(s,e.sweep.endRadians),!0}}return!1}attachPrimitiveToAnyChain(t,e){if(t){this._xyzWork0=t.startPoint(this._xyzWork0);let i=this.findAnyChainToConnect(this._xyzWork0,e);if(i){if(i.atEnd){const s=this._chains[i.chainIndex],n=s.length-1;return this._chains[i.chainIndex].push(t),ss.moveHeadOrTail(s[n],s[n+1],this._gapTolerance),this.searchAndMergeChainIndex(i.chainIndex,e),!0}{t.reverseInPlace();const s=this._chains[i.chainIndex];return s.splice(0,0,t),ss.moveHeadOrTail(s[0],s[1],this._gapTolerance),this.searchAndMergeChainIndex(i.chainIndex,e),!0}}if(this._xyzWork0=t.endPoint(this._xyzWork0),i=this.findAnyChainToConnect(this._xyzWork0,e),i){if(i.atEnd){t.reverseInPlace();const s=this._chains[i.chainIndex],n=s.length-1;return this._chains[i.chainIndex].push(t),ss.moveHeadOrTail(s[n],s[n+1],this._gapTolerance),this.searchAndMergeChainIndex(i.chainIndex,e),!0}{const s=this._chains[i.chainIndex];return s.splice(0,0,t),ss.moveHeadOrTail(s[0],s[1],this._gapTolerance),this.searchAndMergeChainIndex(i.chainIndex,e),!0}}}return!1}mergeChainsForwardForward(t,e){const i=this._chains[t],s=this._chains[e];for(const t of s)i.push(t);s.length=0;const n=this._chains.length-1;e!==n&&(this._chains[e]=this._chains[n]),this._chains.pop()}reverseChain(t){const e=this._chains[t];e.reverse();for(const t of e)t.reverseInPlace()}searchAndMergeChainIndex(t,e){const i=this._chains[t],s=i.length-1;this._xyzWork0=i[0].startPoint(this._xyzWork0);let n=this.findAnyChainToConnect(this._xyzWork0,e,t);return n?(n.atEnd||this.reverseChain(n.chainIndex),void this.mergeChainsForwardForward(n.chainIndex,t)):(this._xyzWork0=i[s].endPoint(this._xyzWork0),n=this.findAnyChainToConnect(this._xyzWork0,e,t),n?(n.atEnd&&this.reverseChain(n.chainIndex),void this.mergeChainsForwardForward(t,n.chainIndex)):void 0)}promoteArrayToCurves(t,e){if(0!==t.length){if(e){const e=t[0],i=t[t.length-1];if(ss._staticPointA=e.startPoint(ss._staticPointA),ss._staticPointB=i.endPoint(ss._staticPointB),ss.moveHeadOrTail(i,e,this._gapTolerance)&&(ss._staticPointA=e.startPoint(ss._staticPointA),ss._staticPointB=i.endPoint(ss._staticPointB)),ss._staticPointA.isAlmostEqual(ss._staticPointB,this._gapTolerance)){const e=Fi.createRightHandedLocalToWorld(t);if(e){const i=e.inverse();if(i){const e=Er.curveArrayRange(t,i);if(void 0!==this._planeTolerance&&e.zLength()<=this._planeTolerance)return hi.createArray(t)}}return oi.createArray(t)}}return 1===t.length?t[0]:oi.createArray(t)}}chainToLineString3d(t,e){if(0===t.length)return;const i=Me.create();for(const s of t)s.emitStrokes(i,e);return i.removeDuplicatePoints(this._gapTolerance),i}grabResult(t=!1){const e=this._chains;if(0===e.length)return;if(1===e.length)return this.promoteArrayToCurves(e[0],t);const i=ri.create();for(const s of e){const e=this.promoteArrayToCurves(s,t);i.tryAddChild(e)}return i}announceChainsAsLineString3d(t,e){const i=this._chains;if(1===i.length){const s=this.chainToLineString3d(i[0],e);s&&t(s)}else if(i.length>1)for(const s of i){const i=this.chainToLineString3d(s,e);i&&t(i)}}}!function(t){t[t.Unknown=0]="Unknown",t[t.Cap=1]="Cap",t[t.Extend=2]="Extend",t[t.Trim=-1]="Trim",t[t.JustGeometry=3]="JustGeometry",t[t.Gap=4]="Gap"}(M||(M={}));class ns{constructor(t,e,i){this.curve0=t,this.curve1=e,this.swingPoint=i,this.flexure=M.Unknown}static constructArc(t,e,i){if(void 0!==e&&Q.isSameCoordinate(t.origin.distance(e),i.origin.distance(e))){const s=t.direction.angleToXY(i.direction),n=$.createStartEnd(e,t.origin),r=n.rotate90CCWXY();return Ti.create(e,n,r,At.createStartEndRadians(0,s.radians))}}shallowExtract(){return{curve0:this.curve0,curve1:this.curve1,fraction0:this.fraction0,fraction1:this.fraction1}}static link(t,e){t.nextJoint=e,e&&(e.previousJoint=t),t.curve1&&e&&!e.curve0?e.curve0=t.curve1:!t.curve1&&e&&e.curve0&&(t.curve1=e.curve0)}nextJointFraction0(t){return this.nextJoint&&void 0!==this.nextJoint.fraction0?this.nextJoint.fraction0:t}static addStrokes(t,e){e&&e.emitStrokes(t)}static addPoint(t,e){t.packedPoints.length>0&&(t.endPoint().isAlmostEqual(e)||t.packedPoints.push(e))}static collectStrokesFromChain(t,e,i=100){let s=-2*i;ns.visitJointsOnChain(t,(t=>{if(this.addStrokes(e,t.jointCurve),t.curve1&&void 0!==t.fraction1){const i=t.fraction1,s=t.nextJointFraction0(1);let n;0===i&&1===s?n=t.curve1.clone():i<s&&(n=t.curve1.clonePartialCurve(i,s)),n&&(t.jointCurve||this.addPoint(e,n.startPoint())),this.addStrokes(e,n)}return s++<i}),i)}static collectPrimitive(t,e){if(e){if(t.length>0){const i=t[t.length-1].endPoint(),s=e.startPoint();i.isAlmostEqual(s)||t.push(Ce.create(i,s))}t.push(e)}}static adjustJointToPrimitives(t){const e=t.jointCurve;if(e instanceof Me){if(t.curve0){const i=t.curve0.endPoint(),s=e.startPoint();i.isAlmostEqual(s)||e.packedPoints.setAtCheckedPointIndex(0,i)}if(t.curve1){const i=t.curve1.startPoint(),s=e.endPoint();i.isAlmostEqual(s)||e.packedPoints.setAtCheckedPointIndex(e.packedPoints.length-1,i)}}}static collectCurvesFromChain(t,e,i=100){if(void 0===t)return;let s=-2*i;ns.visitJointsOnChain(t,(t=>{if(this.adjustJointToPrimitives(t),this.collectPrimitive(e,t.jointCurve),t.curve1&&void 0!==t.fraction1){const i=t.fraction1,s=t.nextJointFraction0(1);let n;0===i&&1===s?n=t.curve1.clone():i<s&&(n=t.curve1.clonePartialCurve(i,s)),this.collectPrimitive(e,n)}return s++<i}),i)}static annotateChain(t,e,i=100){t&&ns.visitJointsOnChain(t,(t=>(t.annotateJointMode(e),!0)),i)}static visitJointsOnChain(t,e,i=100){let s=t;if(s){let n=0;for(;void 0!==s;){if(n++>=i+5)return!0;if(!e(s))return!1;if(s=s.nextJoint,s===t)break}}return!0}annotateExtension(t){if(this.curve0&&this.curve1){const e=this.curve0.fractionToPointAndDerivative(1),i=this.curve1.fractionToPointAndDerivative(0);e.direction.z=i.direction.z=0;const s=bt.closestApproachRay3dRay3d(e,i);if(s.approachType===I.Intersection&&s.detailA.fraction>=0&&s.detailB.fraction<=0){this.fraction0=1,this.fraction1=0,this.flexure=M.Extend;const n=e.getDirectionRef().angleToXY(i.getDirectionRef());if(t.needArc(n)){const t=ns.constructArc(e,this.curve0.baseCurveEnd,i);if(t)return void(this.jointCurve=t)}const r=t.numChamferPoints(n);if(r<=1)return void(this.jointCurve=Me.create(e.origin,s.detailA.point,i.origin));if(r>1){const t=2*r,s=n.radians/t,o=ns.constructArc(e,this.curve0.baseCurveEnd,i);if(void 0!==o){const n=1/Math.cos(s),a=Me.create();this.jointCurve=a,a.addPoint(e.origin);for(let e=0;e<r;e++){const i=(1+2*e)/t;a.addPoint(o.fractionAndRadialFractionToPoint(i,n))}return void a.addPoint(i.origin)}}}this.flexure=M.Gap,this.jointCurve=Ce.create(this.curve0.fractionToPoint(1),this.curve1.fractionToPoint(0)),this.fraction0=1,this.fraction1=0}}selectIntersectionIndexByFraction(t,e,i){let s=-1,n=Number.MAX_VALUE;for(let r=0;r<i.length;r++){const o=Math.abs(i[r].detailA.fraction-t)+Math.abs(i[r].detailB.fraction-e);o<n&&(n=o,s=r)}return s}annotateJointMode(t){if(!this.curve0&&this.curve1)this.flexure=M.Cap,this.fraction1=0;else if(this.curve0&&!this.curve1)this.flexure=M.Cap,this.fraction0=1;else if(this.curve0&&this.curve1)if(this.curve0.endPoint().isAlmostEqualXY(this.curve1.startPoint()))this.fraction0=1,this.fraction1=0,this.flexure=M.Trim;else if(this.curve0 instanceof Ce&&this.curve1 instanceof Ce){const e=this.curve0.fractionToPointAndDerivative(0),i=this.curve1.fractionToPointAndDerivative(0);e.direction.z=i.direction.z=0;const s=bt.closestApproachRay3dRay3d(e,i);s.approachType!==I.Intersection&&s.approachType!==I.PerpendicularChord||(this.fraction0=s.detailA.fraction,this.fraction1=s.detailB.fraction,this.fraction0>=1&&this.fraction1<=0?this.annotateExtension(t):this.fraction0<1&&this.fraction1>0?this.flexure=M.Trim:this.fraction0>1&&this.fraction1>1&&(this.flexure=M.Gap,this.jointCurve=Ce.create(this.curve0.fractionToPoint(1),this.curve1.fractionToPoint(0)),this.fraction0=1,this.fraction1=0))}else{const e=is.intersectionXYPairs(this.curve0,!1,this.curve1,!1),i=this.selectIntersectionIndexByFraction(1,0,e);i>=0?(this.flexure=M.Trim,this.fraction0=e[i].detailA.fraction,this.fraction1=e[i].detailB.fraction):this.annotateExtension(t)}}static removeDegeneratePrimitives(t,e,i){let s=t,n=0,r=0;if(s)for(;void 0!==s&&r++<i;){const i=s.nextJoint;if(s&&i&&s.previousJoint&&i.nextJoint&&void 0!==s.fraction1&&void 0!==i.fraction0){const r=s.fraction1,o=i.fraction0,a=i.fraction1,c=i.nextJoint.fraction0,l=r>=o||r>1;if(l&&(void 0!==a&&a>1||void 0!==a&&void 0!==c&&a>=c)){const t=i.nextJoint,n=new ns(s.curve0,t.curve1,void 0);ns.link(s.previousJoint,n),ns.link(n,t.nextJoint),n.annotateJointMode(e),n.previousJoint.annotateJointMode(e),n.nextJoint&&n.nextJoint.annotateJointMode(e)}else if(l){const r=new ns(s.curve0,i.curve1,void 0);if(ns.link(s.previousJoint,r),ns.link(r,i.nextJoint),r.annotateJointMode(e),r.previousJoint.annotateJointMode(e),r.nextJoint.annotateJointMode(e),n++,s===t&&(t=r),s=r,n>=1)return{newStart:t,numJointRemoved:n}}}if(s=s.nextJoint,s===t)break}return{newStart:t,numJointRemoved:n}}}class rs{constructor(){}static createOffsetSegment(t,e,i){if($.createStartEnd(t,e,this._unitAlong),this._unitAlong.z=0,this._unitAlong.normalizeInPlace()){this._unitAlong.rotate90CCWXY(this._unitPerp);const s=Ce.create(t.plusScaled(this._unitPerp,i,this._offsetA),e.plusScaled(this._unitPerp,i,this._offsetB));return os.applyBasePoints(s,t.clone(),e.clone()),s}}constructPolygonWireXYOffset(t,e,i){e&&!t[0].isAlmostEqual(t[t.length-1])&&(e=!1);const s=Se.create(i),n=t.length;let r,o,a;for(let e=0;e+1<n;++e)if(a){const i=rs.createOffsetSegment(t[e],t[e+1],s.leftOffsetDistance);if(i){const s=new ns(r,i,t[e]);ns.link(a,s),a=s,r=i}}else(r=rs.createOffsetSegment(t[e],t[e+1],s.leftOffsetDistance))&&(a=o=new ns(void 0,r,t[e]));if(!r||!a||!o)return;const c=e?o:new ns(r,void 0,t[n-1]);ns.link(a,c),ns.annotateChain(o,s,n);for(let t=0;t++<5;){const t=ns.removeDegeneratePrimitives(o,s,n);if(o=t.newStart,0===t.numJointRemoved)break}const l=Me.create();return ns.collectStrokesFromChain(o,l,n),l.packedPoints.length>1?l.packedPoints.front().isAlmostEqual(l.packedPoints.back())?hi.create(l):oi.create(l):void 0}}rs._unitAlong=$.create(),rs._unitPerp=$.create(),rs._offsetA=j.create(),rs._offsetB=j.create();class os{constructor(){}static applyBasePoints(t,e,i){return void 0!==t&&(void 0!==e&&(t.baseCurveStart=e),void 0!==i&&(t.baseCurveEnd=i)),t}static createSingleOffsetPrimitiveXY(t,e){const i=t.constructOffsetXY(e);if(void 0!==i){if(Array.isArray(i)){const e=t.collectCurvePrimitives(void 0,!0,!0);if(e.length!==i.length)return;for(let t=0;t<e.length;++t)this.applyBasePoints(i[t],e[t].startPoint(),e[t].endPoint());return i}return this.applyBasePoints(i,t.startPoint(),t.endPoint())}}static constructCurveXYOffset(t,e){const i=t instanceof hi,s=we.create(e),n=[];for(const e of t.children){const t=os.createSingleOffsetPrimitiveXY(e,s);if(void 0===t);else if(t instanceof ae)n.push(t);else if(Array.isArray(t))for(const e of t)e instanceof ae&&n.push(e)}let r,o,a,c;for(const t of n)t&&(o=new ns(r,t,t.fractionToPoint(0)),void 0!==o&&void 0===c&&(c=o),a&&ns.link(a,o),a=o,r=t);c&&a&&t instanceof hi&&ns.link(a,c);const l=n.length;ns.annotateChain(c,s.jointOptions,l);const h=[];return ns.collectCurvesFromChain(c,h,l),Er.createLoopPathOrBagOfCurves(h,i,!0)}}class as{static sumLengths(t){let e=0;if(t instanceof ae)e+=t.curveLength();else if(t instanceof si)e+=t.sumLengths();else if(Array.isArray(t))for(const i of t)e+=this.sumLengths(i);return e}static extendRange(t,e){if(Array.isArray(e))for(const i of e)this.extendRange(t,i);else e.extendRange(t);return t}static appendXYOffsets(t,e,i){let s=0;if(t instanceof ae){const n=os.constructCurveXYOffset(oi.create(t),e);n&&(s+=this.sumLengths(n),i.push(n))}else if(t instanceof hi||t instanceof oi){const n=os.constructCurveXYOffset(t,e);n&&(s+=this.sumLengths(n),i.push(n))}else if(t instanceof ri)for(const n of t.children)s+=this.appendXYOffsets(n,e,i);else if(Array.isArray(t))for(const n of t)s+=this.appendXYOffsets(n,e,i);return s}static collectInsideAndOutsideXYOffsets(t,e,i){const s=new ss(i,i);for(const e of t)s.captureCurve(e);const n=s.grabResult(!0),r=[],o=[];return as.appendXYOffsets(n,e,r)>as.appendXYOffsets(n,-e,o)?{outsideOffsets:r,insideOffsets:o,chains:n}:{insideOffsets:r,outsideOffsets:o,chains:n}}static constructCurveXYOffset(t,e){return os.constructCurveXYOffset(t,e)}static createSingleOffsetPrimitiveXY(t,e){return os.createSingleOffsetPrimitiveXY(t,e)}static collectChains(t,e=Q.smallMetricDistance,i){const s=new ss(e,i);for(const e of t)s.captureCurve(e);return s.grabResult(!0)}static collectChainsAsLineString3d(t,e,i,s=Q.smallMetricDistance,n){const r=new ss(s);for(const e of t)r.captureCurve(e);r.announceChainsAsLineString3d(e,i)}}class cs{constructor(){this.world=new j,this.local=new j,this.a=0,this.closestEdgeIndex=0,this.closestEdgeParam=0}invalidate(){this.world.setZero(),this.local.setZero(),this.a=0,this.closestEdgeIndex=0,this.closestEdgeParam=0}static create(t){return void 0===t?t=new cs:t.invalidate(),t}copyContentsFrom(t){this.world.setFrom(t.world),this.local.setFrom(t.local),this.a=t.a,this.closestEdgeIndex=t.closestEdgeIndex,this.closestEdgeParam=t.closestEdgeParam}get isValid(){return!this.local.isZero}get isInsideOrOn(){return this.isValid&&this.local.x>=0&&this.local.y>=0&&this.local.z>=0}get classify(){if(!this.isValid)return _.Unknown;if(this.isInsideOrOn){let t=0;return 0===Math.abs(this.local.x)&&++t,0===Math.abs(this.local.y)&&++t,0===Math.abs(this.local.z)&&++t,2===t?_.OnPolygonVertex:1===t?_.OnPolygonEdgeInterior:_.InsidePolygonProjectsToEdgeInterior}return 0===this.closestEdgeParam?_.OutsidePolygonProjectsToVertex:_.OutsidePolygonProjectsToEdgeInterior}}class ls{constructor(t,e,i){this.points=[],this.points.push(t),this.points.push(e),this.points.push(i),this.edgeLength2=[],this.edgeLength2.push(e.distanceSquared(i)),this.edgeLength2.push(t.distanceSquared(i)),this.edgeLength2.push(t.distanceSquared(e))}set(t,e,i){this.points[0].setFromPoint3d(t),this.points[1].setFromPoint3d(e),this.points[2].setFromPoint3d(i),this.edgeLength2[0]=this.points[1].distanceSquared(this.points[2]),this.edgeLength2[1]=this.points[0].distanceSquared(this.points[2]),this.edgeLength2[2]=this.points[0].distanceSquared(this.points[1])}setFrom(t){for(let e=0;e<3;++e)this.points[e].setFromPoint3d(t.points[e]),this.edgeLength2[e]=t.edgeLength2[e]}static createXYZXYZXYZ(t,e,i,s,n,r,o,a,c,l){return l?(l.points[0].set(t,e,i),l.points[1].set(s,n,r),l.points[2].set(o,a,c),l):new this(j.create(t,e,i),j.create(s,n,r),j.create(o,a,c))}static create(t,e,i,s){return s?(s.set(t,e,i),s):new this(t.clone(),e.clone(),i.clone())}clone(t){return ls.create(this.points[0],this.points[1],this.points[2],t)}cloneTransformed(t,e){return ls.create(t.multiplyPoint3d(this.points[0],e?.points[0]),t.multiplyPoint3d(this.points[1],e?.points[1]),t.multiplyPoint3d(this.points[2],e?.points[2]),e)}get area(){return.5*this.points[0].crossProductToPointsMagnitude(this.points[1],this.points[2])}edgeLengthSquared(t){return this.edgeLength2[Q.cyclic3dAxis(t)]}edgeLength(t){return Math.sqrt(this.edgeLengthSquared(t))}get aspectRatio(){return Q.safeDivideFraction(this.area,this.edgeLengthSquared(0)+this.edgeLengthSquared(1)+this.edgeLengthSquared(2),0)}get perimeter(){return this.edgeLength(0)+this.edgeLength(1)+this.edgeLength(2)}normal(t){const e=this.points[0].crossProductToPoints(this.points[1],this.points[2],t);if(e.tryNormalizeInPlace())return e}fractionToPoint(t,e,i,s){return j.createAdd3Scaled(this.points[0],t,this.points[1],e,this.points[2],i,s)}pointToFraction(t,e){const i=ls._workVector0=this.normal(ls._workVector0);if(void 0===i)return cs.create(e);const s=ls._workRay=bt.create(t,i,ls._workRay);return this.intersectRay3d(s,e)}static edgeOppositeVertexIndexToStartVertexIndex(t){return Q.cyclic3dAxis(t+1)}static edgeStartVertexIndexToOppositeVertexIndex(t){return Q.cyclic3dAxis(t-1)}static isInsideTriangle(t,e,i){return t>0&&e>0&&i>0}static isInsideOrOnTriangle(t,e,i){return t>=0&&e>=0&&i>=0}static isInRegionBeyondEdge(t,e,i){return t<0&&e>=0&&i>=0?0:t>=0&&e<0&&i>=0?1:t>=0&&e>=0&&i<0?2:-1}static isInRegionBeyondVertex(t,e,i){return e<0&&i<0?0:t<0&&i<0?1:t<0&&e<0?2:-1}static isOnVertex(t,e,i){return 1===t&&0===e&&0===i?0:0===t&&1===e&&0===i?1:0===t&&0===e&&1===i?2:-1}static isOnBoundedEdge(t,e,i){return 0===t&&e>0&&i>0?0:t>0&&0===e&&i>0?1:t>0&&e>0&&0===i?2:-1}static indexOfMinimum(t){let e=0,i=t(0);const s=t(1);return i>s&&(e=1,i=s),i>t(2)&&(e=2),e}distanceSquared(t,e,i,s,n,r){return-this.edgeLengthSquared(0)*(n-e)*(r-i)-this.edgeLengthSquared(1)*(r-i)*(s-t)-this.edgeLengthSquared(2)*(s-t)*(n-e)}closestVertexIndex(t,e,i){return ls.indexOfMinimum((s=>{const n=ls._workPoint=j.createZero(ls._workPoint);return n.setAt(s,1),this.distanceSquared(n.x,n.y,n.z,t,e,i)}))}dotProductOfEdgeVectorsAtVertex(t){const e=Q.cyclic3dAxis(t),i=Q.cyclic3dAxis(e+1),s=Q.cyclic3dAxis(i+1);return Q.dotProductXYZXYZ(this.points[i].x-this.points[e].x,this.points[i].y-this.points[e].y,this.points[i].z-this.points[e].z,this.points[s].x-this.points[e].x,this.points[s].y-this.points[e].y,this.points[s].z-this.points[e].z)}computeProjectionToEdge(t,e){t=Q.cyclic3dAxis(t);const i=Q.cyclic3dAxis(t+1);return e[Q.cyclic3dAxis(i+1)]+e[t]*this.dotProductOfEdgeVectorsAtVertex(i)/this.edgeLengthSquared(t)}closestPoint(t,i,s){const n=[t,i,s];let r=-1,o=0;return ls.isInsideTriangle(t,i,s)?(r=ls.indexOfMinimum((t=>n[t]*n[t]/this.edgeLengthSquared(t))),o=this.computeProjectionToEdge(r,n)):(r=ls.isInRegionBeyondVertex(t,i,s))>=0?(r=Q.cyclic3dAxis(r+1),o=this.computeProjectionToEdge(r,n),(o<0||o>1)&&(r=Q.cyclic3dAxis(r+1),o=this.computeProjectionToEdge(r,n),(o<0||o>1)&&(o=0,r=ls.edgeStartVertexIndexToOppositeVertexIndex(this.closestVertexIndex(t,i,s))))):(r=ls.isInRegionBeyondEdge(t,i,s))>=0?(o=this.computeProjectionToEdge(r,n),o<0?o=0:o>1&&(o=0,r=Q.cyclic3dAxis(r+1))):(r=ls.isOnBoundedEdge(t,i,s))>=0?o=1-n[ls.edgeOppositeVertexIndexToStartVertexIndex(r)]:(r=ls.isOnVertex(t,i,s))>=0&&(o=0,r=ls.edgeStartVertexIndexToOppositeVertexIndex(r)),e(0===r||1===r||2===r),{closestEdgeIndex:r<0?-1:ls.edgeOppositeVertexIndexToStartVertexIndex(r),closestEdgeParam:o}}intersectRay3d(t,e){e=cs.create(e);const i=t.origin,s=t.direction,n=ls._workVector0=$.createStartEnd(this.points[0],this.points[1],ls._workVector0),r=ls._workVector1=$.createStartEnd(this.points[0],this.points[2],ls._workVector1),o=ls._workMatrix=xt.createColumns(n,r,s,ls._workMatrix),a=$.createStartEnd(this.points[0],i,ls._workVector0),c=ls._workVector1;if(void 0===o.multiplyInverse(a,c))return e;e.a=-c.z,t.fractionToPoint(e.a,e.world),e.local.set(1-c.x-c.y,c.x,c.y);const l=this.closestPoint(e.local.x,e.local.y,e.local.z);return e.closestEdgeIndex=l.closestEdgeIndex,e.closestEdgeParam=l.closestEdgeParam,e}intersectSegment(t,e,i){return ls._workRay=bt.createStartEnd(t,e,ls._workRay),this.intersectRay3d(ls._workRay,i)}snapLocationToEdge(t,e=Q.smallMetricDistance,i=Q.smallFloatingPoint){if(!t.isValid)return!1;if(i>0){let e=0,s=0;for(let n=0;n<3;n++){const r=Math.abs(t.local.at(n));r>0&&r<i&&(t.local.setAt(n,0),e++),s+=t.local.at(n)}if(e>0&&s>0)return t.local.scaleInPlace(1/s),1===e?(t.closestEdgeIndex=ls.edgeOppositeVertexIndexToStartVertexIndex(ls.isOnBoundedEdge(t.local.x,t.local.y,t.local.z)),t.closestEdgeParam=1-t.local.at(t.closestEdgeIndex)):(t.closestEdgeIndex=ls.isOnVertex(t.local.x,t.local.y,t.local.z),t.closestEdgeParam=0),this.fractionToPoint(t.local.x,t.local.y,t.local.z,t.world),!0}if(e>0){const i=t.closestEdgeIndex,s=(i+1)%3,n=(s+1)%3,r=ls._workPoint=this.points[i].interpolate(t.closestEdgeParam,this.points[s],ls._workPoint),o=t.world.distance(r);if(o>0&&o<e)return t.local.setAt(i,1-t.closestEdgeParam),t.local.setAt(s,t.closestEdgeParam),t.local.setAt(n,0),t.world.setFrom(r),!0}return!1}dotProductOfCrossProductsFromOrigin(t){return ls._workVector0=this.points[0].crossProductToPoints(this.points[1],this.points[2],ls._workVector0),ls._workVector1=t.points[0].crossProductToPoints(t.points[1],t.points[2],ls._workVector1),ls._workVector0.dotProduct(ls._workVector1)}centroid(t){return j.create((this.points[0].x+this.points[1].x+this.points[2].x)/3,(this.points[0].y+this.points[1].y+this.points[2].y)/3,(this.points[0].z+this.points[1].z+this.points[2].z)/3,t)}incenter(t){const e=this.edgeLength(0),i=this.edgeLength(1),s=this.edgeLength(2),n=Q.safeDivideFraction(1,e+i+s,0);return this.fractionToPoint(n*e,n*i,n*s,t)}circumcenter(t){const e=this.edgeLengthSquared(0),i=this.edgeLengthSquared(1),s=this.edgeLengthSquared(2),n=e*(i+s-e),r=i*(s+e-i),o=s*(e+i-s),a=Q.safeDivideFraction(1,n+r+o,0);return this.fractionToPoint(a*n,a*r,a*o,t)}isAlmostEqual(t,e){return this.points[0].isAlmostEqual(t.points[0],e)&&this.points[1].isAlmostEqual(t.points[1],e)&&this.points[2].isAlmostEqual(t.points[2],e)}}class hs{constructor(t=0){this._parentArray=[];for(let e=0;e<t;e++)this._parentArray.push(e)}get length(){return this._parentArray.length}isValidIndex(t){return 0<=t&&t<this._parentArray.length}addLeaf(){const t=this._parentArray.length;return this._parentArray.push(t),t}findRoot(t){if(!this.isValidIndex(t))return t;let e=t,i=this._parentArray[t];for(;i!==e;)e=i,i=this._parentArray[e];const s=e;for(e=t;e!==s;)i=this._parentArray[e],this._parentArray[e]=s,e=i;return s}mergeSubsets(t,e){if(!this.isValidIndex(t)||!this.isValidIndex(e))return t;const i=this.findRoot(t),s=this.findRoot(e);return i!==s&&(this._parentArray[i]=s),this.findRoot(t)}askParent(t){return this.isValidIndex(t)?this._parentArray[t]:t}countRoots(){let t=0;const e=this._parentArray.length;for(let i=0;i<e;i++)this._parentArray[i]===i&&t++;return t}countNonTrivialPaths(){let t=0;const e=this._parentArray.length;for(let i=0;i<e;i++){const e=this._parentArray[i];e!==i&&this._parentArray[e]!==e&&t++}return t}collectRootIndices(){const t=[],e=this._parentArray.length;for(let i=0;i<e;i++)this._parentArray[i]===i&&t.push(i);return t}}class ds{constructor(t,e){this._freeMasks=t,this._originalFreeMasks=t,this._firstFreeMask=e}static create(t){let e=0,i=1;for(let s=0;s<32;s++){if(i&t){e=i;break}i<<=1}if(0!==e)return new ds(t,e)}grabMask(){if(0===this._freeMasks)return 0;let t=this._firstFreeMask;for(;!(t&this._freeMasks);)t<<=1;return this._freeMasks&=~t,t}dropMask(t){t&=this._originalFreeMasks,this._freeMasks|=t}}(Z=b||(b={}))[Z.EXTERIOR=1]="EXTERIOR",Z[Z.BOUNDARY_EDGE=2]="BOUNDARY_EDGE",Z[Z.PRIMARY_EDGE=4]="PRIMARY_EDGE",Z[Z.VISITED=16]="VISITED",Z[Z.TRIANGULATED_FACE=256]="TRIANGULATED_FACE",Z[Z.NULL_FACE=512]="NULL_FACE",Z[Z.NULL_MASK=0]="NULL_MASK",Z[Z.ALL_GRAB_DROP_MASKS=4293918720]="ALL_GRAB_DROP_MASKS",Z[Z.ALL_MASK=4294967295]="ALL_MASK";class us{get id(){return this._id}get facePredecessor(){return this._facePredecessor}get faceSuccessor(){return this._faceSuccessor}get edgeMate(){return this._edgeMate}constructor(t=0,e=0,i=0,s=0){this._id=us._totalNodesCreated++,this.i=s,this.maskBits=0,this.x=t,this.y=e,this.z=i,this.sortAngle=void 0,this.sortData=void 0,this.edgeTag=void 0,this.faceTag=void 0,this._facePredecessor=this,this._faceSuccessor=this,this._edgeMate=this}faceStepY(t){let e=this;if(t>0)for(let i=0;i<t;i++)e=e.faceSuccessor;else if(t<0)for(let i=0;i>t;i--)e=e.facePredecessor;return e.y}static createHalfEdgePair(t){const e=new us,i=new us;return t&&(t.push(e),t.push(i)),us.setFaceLinks(e,i),us.setFaceLinks(i,e),us.setEdgeMates(e,i),e}static createHalfEdgePairWithCoordinates(t=0,e=0,i=0,s=0,n=0,r=0,o=0,a=0,c){const l=us.createHalfEdgePair(c),h=l._edgeMate;return l.x=t,l.y=e,l.z=i,l.i=s,h.x=n,h.y=r,h.z=o,h.i=a,l}static setFaceLinks(t,e){t._faceSuccessor=e,e._facePredecessor=t}static setEdgeMates(t,e){t._edgeMate=e,e._edgeMate=t}static splitEdge(t,e=0,i=0,s=0,n=0,r){const o=new us(e,i,s,n),a=new us(e,i,s,n);if(r&&(r.push(o),r.push(a)),void 0===t)o._faceSuccessor=o._facePredecessor=o,a._faceSuccessor=a._facePredecessor=a,us.setEdgeMates(o,a);else{const e=t._faceSuccessor,i=t._edgeMate,s=i._faceSuccessor;us.setFaceLinks(o,e),us.setFaceLinks(t,o),us.setFaceLinks(i,a),us.setFaceLinks(a,s),us.setEdgeMates(o,i),us.setEdgeMates(a,t),this.transferEdgeProperties(t,o),this.transferEdgeProperties(i,a)}return o}static splitEdgeCreateSliverFace(t,e){const i=t.edgeMate,s=new us,n=new us;return e&&(e.push(s),e.push(n)),s._faceSuccessor=s._facePredecessor=n,n._faceSuccessor=n._facePredecessor=s,us.setEdgeMates(s,i),us.setEdgeMates(n,t),s.copyDataFrom(t,!0,!0,!1,!1),n.copyDataFrom(i,!0,!0,!1,!1),s}static transferEdgeProperties(t,e){e.edgeTag=t.edgeTag;for(const i of this._edgePropertyMasks)t.getMask(i)?e.setMask(i):e.clearMask(i)}get vertexSuccessor(){return this.facePredecessor.edgeMate}get vertexPredecessor(){return this.edgeMate.faceSuccessor}setMask(t){this.maskBits|=t}getMask(t){return this.maskBits&t}clearMask(t){this.maskBits&=~t}setMaskAroundVertex(t){let e=this;do{e.setMask(t),e=e.vertexSuccessor}while(e!==this)}setXYZAroundVertex(t,e,i){let s=this;do{s.x=t,s.y=e,s.z=i,s=s.vertexSuccessor}while(s!==this)}setMaskAroundFace(t){let e=this;do{e.setMask(t),e=e.faceSuccessor}while(e!==this)}setMaskAroundEdge(t){this.setMask(t),this.edgeMate.setMask(t)}clearMaskAroundEdge(t){this.clearMask(t),this.edgeMate.clearMask(t)}countEdgesAroundFace(){let t=0,e=this;do{t++,e=e.faceSuccessor}while(e!==this);return t}findAroundVertex(t){let e=this;do{if(e===t)return!0;e=e.vertexSuccessor}while(e!==this);return!1}findAroundFace(t){let e=this;do{if(e===t)return!0;e=e.faceSuccessor}while(e!==this);return!1}isMaskedAroundFace(t,e=!0){let i=this;if(e)do{if(!i.isMaskSet(t))return!1;i=i.faceSuccessor}while(i!==this);else do{if(i.isMaskSet(t))return!1;i=i.faceSuccessor}while(i!==this);return!0}setMaskAndEdgeTagAroundFace(t,e,i=!1){let s=this;do{if(s.setMask(t),s.edgeTag=e,i){const i=s.edgeMate;i.setMask(t),i.edgeTag=e}s=s.faceSuccessor}while(s!==this)}countEdgesAroundVertex(){let t=0,e=this;do{t++,e=e.vertexSuccessor}while(e!==this);return t}countMaskAroundFace(t,e=!0){let i=0,s=this;if(e)do{s.isMaskSet(t)&&i++,s=s.faceSuccessor}while(s!==this);else do{s.isMaskSet(t)||i++,s=s.faceSuccessor}while(s!==this);return i}countMaskAroundVertex(t,e=!0){let i=0,s=this;if(e)do{s.isMaskSet(t)&&i++,s=s.vertexSuccessor}while(s!==this);else do{s.isMaskSet(t)||i++,s=s.vertexSuccessor}while(s!==this);return i}findMaskAroundVertex(t,e=!0){let i=this;do{if(i.isMaskSet(t)===e)return i;i=i.vertexSuccessor}while(i!==this)}findMaskAroundFace(t,e=!0){let i=this;do{if(i.isMaskSet(t)===e)return i;i=i.faceSuccessor}while(i!==this)}findMaskAroundEdge(t,e=!0){if(this.isMaskSet(t)===e)return this;const i=this.edgeMate;return i.isMaskSet(t)===e?i:void 0}testAndSetMask(t){const e=this.maskBits&t;return this.maskBits|=t,e}setXYZFrom(t){this.x=t.x,this.y=t.y,this.z=t.z}setXYZ(t){this.x=t.x,this.y=t.y,this.z=t.z}isMaskSet(t){return!!(this.maskBits&t)}static filterIsMaskOn(t,e){return t.isMaskSet(e)}static filterIsMaskOff(t,e){return!t.isMaskSet(e)}static createEdgeXYXY(t,e,i,s,n,r){const o=new us(e,i),a=new us(n,r);return o._faceSuccessor=o._facePredecessor=o._edgeMate=a,a._faceSuccessor=a._facePredecessor=a._edgeMate=o,o._id=t,a._id=s,o}static pinch(t,e){if(t!==e){const i=t._facePredecessor,s=e._facePredecessor;e._facePredecessor=i,t._facePredecessor=s,s._faceSuccessor=t,i._faceSuccessor=e}}yankFromVertexLoop(){const t=this.edgeMate.faceSuccessor;if(t!==this)return us.pinch(this,t),t}decommission(){this._facePredecessor=void 0,this._faceSuccessor=void 0,this._edgeMate=void 0}static nodeToSelf(t){return t}static nodeToId(t){return t.id}static nodeToIdString(t){return t.id.toString()}static nodeToIdMaskXY(t){return{id:t.id,mask:us.nodeToMaskString(t),xy:[t.x,t.y]}}static nodeToIdXYString(t){return`${t.id.toString()}+${us.nodeToMaskString(t)}[${t.x},${t.y}]`}static nodeToIdXYZString(t){return`[${t.id.toString()}: ${t.x},${t.y},${t.z}]`}static nodeToMaskString(t){let e="";return t.isMaskSet(b.BOUNDARY_EDGE)&&(e+="B"),t.isMaskSet(b.PRIMARY_EDGE)&&(e+="P"),t.isMaskSet(b.EXTERIOR)&&(e+="X"),t.isMaskSet(b.NULL_FACE)&&(e+="N"),e}static nodeToXY(t){return[t.x,t.y]}vectorToFaceSuccessorXY(t){return J.create(this.faceSuccessor.x-this.x,this.faceSuccessor.y-this.y,t)}vectorToFaceSuccessor(t){const e=this.faceSuccessor;return $.create(e.x-this.x,e.y-this.y,e.z-this.z,t)}vectorToFacePredecessor(t){const e=this.facePredecessor;return $.create(e.x-this.x,e.y-this.y,e.z-this.z,t)}static isNodeVisibleInSector(t,e){if(e.vertexSuccessor===e)return!0;const i=e.faceSuccessor,s=e.facePredecessor,n=this.crossProductXYToTargets(e,i,t),r=this.crossProductXYToTargets(s,e,t);if(n>0&&r>0)return!0;const o=this.crossProductXYToTargets(s,e,i);return r<=0&&n<=0?0===r&&0===n&&0===o&&(s===i&&e.vertexSuccessor!==e?t===i:us.dotProductNodeToNodeVectorsXY(s,e,e,t)>0):0===o&&0!==r&&0!==n?s!==i:o<0}static crossProductXYToTargets(t,e,i){return Q.crossProductXYXY(e.x-t.x,e.y-t.y,i.x-t.x,i.y-t.y)}static dotProductNodeToNodeVectorsXY(t,e,i,s){return Q.dotProductXYXY(e.x-t.x,e.y-t.y,s.x-i.x,s.y-i.y)}static crossProductXYAlongChain(t,e,i){return Q.crossProductXYXY(e.x-t.x,e.y-t.y,i.x-e.x,i.y-e.y)}static isSectorConvex(t,e,i,s=0){const n=.5*us.crossProductXYAlongChain(t,e,i);return s=s??0,Math.abs(n)<=Math.abs(s)?us.dotProductNodeToNodeVectorsXY(t,e,e,i)>0:n>-s}isSectorConvex(t){return void 0===t&&(t=Q.smallMetricDistanceSquared*this.signedFaceArea()),us.isSectorConvex(this.facePredecessor,this,this.faceSuccessor,t)}isFaceConvex(t=Q.smallMetricDistanceSquared){let e=this;const i=t>0?t*e.signedFaceArea():0;do{if(!e.isSectorConvex(i))return!1;e=e.faceSuccessor}while(e!==this);return!0}isolateEdge(){const t=this.edgeMate;this.yankFromVertexLoop(),t.yankFromVertexLoop()}get isIsolatedEdge(){return this===this.vertexSuccessor&&this.edgeMate===this.edgeMate.vertexSuccessor}belowYX(t){return this.y<t.y||!(this.y>t.y)&&this.x<t.x}static testNodeMaskNotExterior(t){return!t.isMaskSet(b.EXTERIOR)}static testMateMaskExterior(t){return t.edgeMate.isMaskSet(b.EXTERIOR)}static sectorSweepRadiansXYZ(t,e){const i=t.faceSuccessor,s=t.facePredecessor;return W.orientedRadiansBetweenVectorsXYZ(i.x-t.x,i.y-t.y,i.z-t.z,s.x-t.x,s.y-t.y,s.z-t.z,e.x,e.y,e.z,!0)}static testFacePositiveAreaXY(t){return t.countEdgesAroundFace()>2&&t.signedFaceArea()>0}isEqualXY(t){return this.x===t.x&&this.y===t.y}distanceXY(t){return Q.distanceXYXY(this.x,this.y,t.x,t.y)}distanceXYZ(t){return Q.distanceXYZXYZ(this.x,this.y,this.z,t.x,t.y,t.z)}collectAroundFace(t){const e=[];let i=this;do{e.push(t?t(i):i),i=i.faceSuccessor}while(i!==this);return e}collectMaskedEdgesAroundVertex(t,e=!0,i){void 0===i?i=[]:i.length=0;let s=this;do{s.isMaskSet(t)===e&&i.push(s),s=s.vertexSuccessor}while(s!==this);return i}collectAroundVertex(t){const e=[];let i=this;do{e.push(t?t(i):i),i=i.vertexSuccessor}while(i!==this);return e}sumAroundFace(t){let e=this,i=0;do{i+=t(e),e=e.faceSuccessor}while(e!==this);return i}sumAroundVertex(t){let e=this,i=0;do{i+=t(e),e=e.vertexSuccessor}while(e!==this);return i}clearMaskAroundFace(t){let e=this;do{e.clearMask(t),e=e.faceSuccessor}while(e!==this)}clearMaskAroundVertex(t){let e=this;do{e.clearMask(t),e=e.vertexSuccessor}while(e!==this)}signedFaceArea(){let t=0,e=this.x,i=0;const s=this.y;let n,r=0,o=0,a=this;do{n=a.faceSuccessor,i=n.x,o=n.y-s,t+=(e-i)*(r+o),e=i,r=o,a=n}while(a!==this);return.5*t}fractionToPoint2d(t,e){const i=this.faceSuccessor;return H.create(this.x+(i.x-this.x)*t,this.y+(i.y-this.y)*t,e)}fractionToPoint3d(t,e){const i=this.faceSuccessor;return j.create(this.x+(i.x-this.x)*t,this.y+(i.y-this.y)*t,this.z+(i.z-this.z)*t,e)}fractionAlongAndPerpendicularToPoint2d(t,e,i){const s=this.faceSuccessor,n=s.x-this.x,r=s.y-this.y;return H.create(this.x+n*t-r*e,this.y+r*t+n*e,i)}getPoint3d(t){return j.create(this.x,this.y,this.z,t)}getPoint2d(t){return H.create(this.x,this.y,t)}getVector3dAlongEdge(t){const e=this.faceSuccessor;return $.create(e.x-this.x,e.y-this.y,e.z-this.z,t)}getVector2dAlongEdge(t){const e=this.faceSuccessor;return J.create(e.x-this.x,e.y-this.y,t)}fractionToX(t){const e=this.faceSuccessor;return this.x+(e.x-this.x)*t}fractionToY(t){const e=this.faceSuccessor;return this.y+(e.y-this.y)*t}fractionToZ(t){const e=this.faceSuccessor;return this.z+(e.z-this.z)*t}static transverseIntersectionFractions(t,e,i){const s=t.faceSuccessor,n=e.faceSuccessor;if(i||(i=J.create()),Mt.linearSystem2d(s.x-t.x,e.x-n.x,s.y-t.y,e.y-n.y,e.x-t.x,e.y-t.y,i))return i}static horizontalScanFraction(t,e){const i=t.faceSuccessor,s=i.y-t.y;return Q.isSameCoordinate(e,t.y)&&Q.isSameCoordinate(e,i.y)?t:Q.isSameCoordinate(s,0)?void 0:Q.conditionalDivideFraction(e-t.y,s)}static horizontalScanFraction01(t,e){const i=t.faceSuccessor,s=i.y-t.y;if(Q.isSameCoordinate(e,t.y)&&Q.isSameCoordinate(e,i.y))return;if(Q.isSameCoordinate(s,0))return;const n=Q.conditionalDivideFraction(e-t.y,s);return void 0!==n&&n>=0&&n<=1?n:void 0}copyDataFrom(t,e,i,s,n){e&&(this.x=t.x,this.y=t.y,this.z=t.z),i&&(this.i=t.i),s&&(us.transferEdgeProperties(t,this),this.edgeTag=t.edgeTag),n&&(this.faceTag=t.faceTag)}}us._totalNodesCreated=0,us._edgePropertyMasks=[b.BOUNDARY_EDGE,b.EXTERIOR,b.PRIMARY_EDGE,b.NULL_FACE];class fs{constructor(){this._numNodesCreated=0,this.allHalfEdges=[],this._maskManager=ds.create(b.ALL_GRAB_DROP_MASKS)}grabMask(t=!0){const e=this._maskManager.grabMask();return t&&this.clearMask(e),e}dropMask(t){this._maskManager.dropMask(t)}createEdgeXYZXYZ(t=0,e=0,i=0,s=0,n=0,r=0,o=0,a=0){return us.createHalfEdgePairWithCoordinates(t,e,i,s,n,r,o,a,this.allHalfEdges)}createEdgeIdId(t=0,e=0){return us.createHalfEdgePairWithCoordinates(0,0,0,t,0,0,0,e,this.allHalfEdges)}createEdgeXYZHalfEdge(t=0,e=0,i=0,s=0,n,r=0){const o=us.createHalfEdgePairWithCoordinates(t,e,i,s,n.x,n.y,n.z,r,this.allHalfEdges),a=o.faceSuccessor;return us.pinch(n,a),o}createEdgeHalfEdgeHalfEdge(t,e,i,s=0){const n=us.createHalfEdgePairWithCoordinates(t.x,t.y,t.z,e,i.x,i.y,i.z,s,this.allHalfEdges),r=n.faceSuccessor;return us.pinch(t,n),us.pinch(i,r),n}createEdgeXYAndZ(t,e,i,s){return us.createHalfEdgePairWithCoordinates(t.x,t.y,t.z,e,i.x,i.y,i.z,s,this.allHalfEdges)}splitEdge(t,e=0,i=0,s=0,n=0){return us.splitEdge(t,e,i,s,n,this.allHalfEdges)}splitEdgeCreateSliverFace(t){return us.splitEdgeCreateSliverFace(t,this.allHalfEdges)}splitEdgeAtFraction(t,e){return us.splitEdge(t,t.fractionToX(e),t.fractionToY(e),t.fractionToZ(e),0,this.allHalfEdges)}decommission(){for(const t of this.allHalfEdges)t.decommission();this.allHalfEdges.length=0,this.allHalfEdges=void 0}addEdgeXY(t,e,i,s){const n=us.createEdgeXYXY(this._numNodesCreated,t,e,this._numNodesCreated+1,i,s);return this._numNodesCreated+=2,this.allHalfEdges.push(n),this.allHalfEdges.push(n.faceSuccessor),n}clearMask(t){for(const e of this.allHalfEdges)e.maskBits&=~t}setMask(t){for(const e of this.allHalfEdges)e.maskBits|=t}reverseMask(t){for(const e of this.allHalfEdges)e.maskBits^=t}countMask(t){let e=0;for(const i of this.allHalfEdges)i.isMaskSet(t)&&e++;return e}collectSegments(){const t=[];for(const e of this.allHalfEdges)e.id<e.edgeMate.id&&t.push(Ce.create(j.create(e.x,e.y),j.create(e.faceSuccessor.x,e.faceSuccessor.y)));return t}countVertexLoops(){let t=0;return this.announceVertexLoops(((e,i)=>(t++,!0))),t}countFaceLoops(){let t=0;return this.announceFaceLoops(((e,i)=>(t++,!0))),t}countFaceLoopsWithMaskFilter(t,e){let i=0;return this.announceFaceLoops(((s,n)=>(t(n,e)&&i++,!0))),i}collectVertexLoops(){const t=[];return this.announceVertexLoops(((e,i)=>(t.push(i),!0))),t}collectFaceLoops(){const t=[];return this.announceFaceLoops(((e,i)=>(t.push(i),!0))),t}announceVertexLoops(t){this.clearMask(b.VISITED);for(const e of this.allHalfEdges)if(!e.getMask(b.VISITED)&&(e.setMaskAroundVertex(b.VISITED),!t(this,e)))break}announceFaceLoops(t){this.clearMask(b.VISITED);for(const e of this.allHalfEdges)if(!e.getMask(b.VISITED)&&(e.setMaskAroundFace(b.VISITED),!t(this,e)))break}announceEdges(t){this.clearMask(b.VISITED);for(const e of this.allHalfEdges){if(e.getMask(b.VISITED))continue;const i=e.edgeMate;if(e.setMask(b.VISITED),i.setMask(b.VISITED),!t(this,e))break}}announceNodes(t){for(const e of this.allHalfEdges)if(!t(this,e))break}countNodes(){return this.allHalfEdges.length}transformInPlace(t){for(const e of this.allHalfEdges)t.multiplyXYAndZInPlace(e)}yankAndDeleteEdges(t){const e=this.allHalfEdges.length;let i=0;for(let s=0;s<e;s++){const e=this.allHalfEdges[s];t(e)?e.yankFromVertexLoop():this.allHalfEdges[i++]=e}const s=e-i;return this.allHalfEdges.length=i,s}deleteIsolatedEdges(){const t=this.allHalfEdges.length;let e=0;for(let i=0;i<t;i++){const t=this.allHalfEdges[i];t.isIsolatedEdge||(this.allHalfEdges[e++]=t)}const i=t-e;return this.allHalfEdges.length=e,i}}class gs{constructor(t,e=Le){this._array=[],this._compare=t,this._clone=e}get length(){return this._array.length}get isEmpty(){return 0===this.length}[Symbol.iterator](){return this._array[Symbol.iterator]()}_swap(t,e){const i=this._array[t];this._array[t]=this._array[e],this._array[e]=i}_heapify(t){let e=-1;for(;;){const i=2*(t+1),s=i-1;if(e=s<this.length&&this._compare(this._array[s],this._array[t])<0?s:t,i<this.length&&this._compare(this._array[i],this._array[e])<0&&(e=i),e===t)break;this._swap(e,t),t=e}}sort(){for(let t=Math.ceil(this.length/2);t>=0;t--)this._heapify(t)}push(t){const e=this._clone(t);let i=this.length;for(this._array.push(e);0!==i;){const t=Math.floor((i-1)/2);if(!(this._compare(this._array[i],this._array[t])<0))break;this._swap(i,t),i=t}return e}append(t){const e=this._clone(t);return this._array.push(e),e}get front(){return this._peek(0)}pop(){return this._pop(0)}clear(){this._array.length=0}_pop(t){if(t<0||t>=this.length)return;const e=this._array[t];return this._swap(t,this.length-1),this._array.length--,this._heapify(t),e}_peek(t){return t<0||t>=this.length?void 0:this._array[t]}}class ps{constructor(t=(t,e)=>Gs.compareNodesYXUp(t,e)){this.priorityQueue=new gs(t),this.activeEdges=[]}popQueueToArray(){if(this.priorityQueue.isEmpty)return;const t=this.priorityQueue.pop();return this.activeEdges.push(t),t}popArrayToArrayIndex(t){if(t<this.activeEdges.length){const e=this.activeEdges.pop();this.activeEdges[t]=e}}removeArrayMembersWithY1Below(t){let e=0;const i=this.activeEdges.length;for(let s=0;s<i;s++){const i=this.activeEdges[s];i.faceSuccessor.y>=t&&(e<s&&(this.activeEdges[e]=i),e++)}this.activeEdges.length=e}}class ms{constructor(t){this.graph=t,this.upEdges=[],this.downEdges=[],this.bottomPeaks=[],this.topPeaks=[],this.localMin=[],this.localMax=[]}collectVerticalEventsAroundFace(t){let e,i,s,n,r=t;this.upEdges.length=0,this.downEdges.length=0,this.topPeaks.length=0,this.bottomPeaks.length=0,this.localMin.length=0,this.localMax.length=0;do{e=r.faceSuccessor,i=e.faceSuccessor,s=Gs.compareNodesYXUp(r,e)<0,n=Gs.compareNodesYXUp(e,i)<0,s?(this.upEdges.push(r),n||(Gs.crossProductToTargets(e,r,i)<0?this.localMax.push(e):this.topPeaks.push(e))):(this.downEdges.push(r),n&&(Gs.crossProductToTargets(e,r,i)>0?this.bottomPeaks.push(e):this.localMin.push(e))),r=e}while(r!==t)}collectVerticalEventFromEdgesInAndArray(t){let e,i,s,n,r;for(e of(this.upEdges.length=0,this.downEdges.length=0,this.topPeaks.length=0,this.bottomPeaks.length=0,this.localMin.length=0,this.localMax.length=0,t))i=e.faceSuccessor,s=i.faceSuccessor,n=Gs.compareNodesYXUp(e,i)<0,r=Gs.compareNodesYXUp(i,s)<0,n?(this.upEdges.push(e),r||(Gs.crossProductToTargets(i,e,s)<0?this.localMax.push(i):this.topPeaks.push(i))):(this.downEdges.push(e),r&&(Gs.crossProductToTargets(i,e,s)>0?this.bottomPeaks.push(i):this.localMin.push(i)))}swapArrays(){let t=this.downEdges;this.downEdges=this.upEdges,this.upEdges=t,t=this.localMax,this.localMax=this.localMin,this.localMin=t,t=this.topPeaks,this.topPeaks=this.bottomPeaks,this.bottomPeaks=t}findTopVisibleEdge(t,e,i){const s=t.y,n=t.x;let r,o,a=Number.MAX_SAFE_INTEGER;for(const c of e){const e=c.faceSuccessor;if(c===t||e===t)continue;if(Gs.compareNodesYXUp(t,c)*Gs.compareNodesYXUp(t,e)>=0)continue;const l=us.horizontalScanFraction01(c,s);void 0!==l&&(r=i*(c.fractionToX(l)-n),r>0&&r<a&&(o=c,a=r))}return o}highestUpPeakConnection(t,e,i){let s;for(const n of this.topPeaks){const r=n.y,o=n.x;if(!(void 0!==s&&Gs.compareNodesYXUp(n,s)<0)&&Gs.compareNodesYXUp(n,t)<0){if(e){const t=us.horizontalScanFraction01(e,r);if(void 0===t)continue;if(o<=e.fractionToX(t))continue}if(i){const t=us.horizontalScanFraction01(i,r);if(void 0===t)continue;if(i.fractionToX(t)<=o)continue}s=n}}return s}updateMaxNode(t,e,i){return t?e&&i(t,e)<0?e:t:e}negateXY(){for(const t of this.graph.allHalfEdges)t.x*=-1,t.y*=-1}downwardConnectionFromBottomPeak(t){let e;const i=(t,e)=>Gs.compareNodesYXUp(t,e),s=this.findTopVisibleEdge(t,this.upEdges,1),n=this.findTopVisibleEdge(t,this.downEdges,-1);e=this.updateMaxNode(e,s,i),n&&(e=this.updateMaxNode(e,n.faceSuccessor,i));const r=this.highestUpPeakConnection(t,n,s);return void 0!==r&&(e=this.updateMaxNode(e,r,i)),e}findVisibleSector(t,e){let i=t;do{if(us.isNodeVisibleInSector(e,i))return i;i=i.vertexSuccessor}while(i!==t)}joinNodes(t,e,i){const s=this.graph.createEdgeXYZXYZ(t.x,t.y,t.z,0,e.x,e.y,e.z,0),n=this.findVisibleSector(t,e),r=this.findVisibleSector(e,t);if(void 0!==n&&void 0!==r)return us.pinch(n,s),us.pinch(r,s.edgeMate),ms.announceEdge&&ms.announceEdge(this.graph,t,e,i),s}runRegularization(t=!0,e=!0){if(t){this.bottomPeaks.sort(((t,e)=>Gs.compareNodesYXUp(t,e)));for(const t of this.bottomPeaks){if(!Gs.isDownPeak(t))continue;const e=this.downwardConnectionFromBottomPeak(t);void 0!==e&&this.joinNodes(t,e,1)}}if(e){this.negateXY(),this.swapArrays(),this.bottomPeaks.sort(((t,e)=>Gs.compareNodesYXUp(t,e)));for(const t of this.bottomPeaks){if(!Gs.isDownPeak(t))continue;const e=this.downwardConnectionFromBottomPeak(t);void 0!==e&&this.joinNodes(t,e,-1)}this.negateXY(),this.swapArrays()}}regularizeFace(t,e=!0,i=!0){this.collectVerticalEventsAroundFace(t),this.runRegularization(e,i)}regularizeGraph(t=!0,e=!0){this.collectVerticalEventFromEdgesInAndArray(this.graph.allHalfEdges),this.runRegularization(t,e)}static isMonotoneFace(t){let e,i=0,s=0,n=t;do{const t=n.faceSuccessor,r=t.faceSuccessor,o=Gs.compareNodesYXUp(n,t),a=Gs.compareNodesYXUp(t,r);o*a<=0&&(o>0&&(i++,e=t),a>0&&s++)}while((n=n.faceSuccessor)!==t);return 1===i&&1===s?e:void 0}static collectMappedFaceRepresentatives(t,e,i,s,n){s&&(s.length=0),n&&(n.length=0);const r=b.VISITED;t.clearMask(r);for(const o of t.allHalfEdges)if(!o.getMask(r)&&(o.setMaskAroundFace(r),!e||o.signedFaceArea()>0)){const t=i(o);t?s&&s.push(t):n&&n.push(o)}}}class xs extends si{isSameGeometryClass(t){return t instanceof xs}get children(){return this._children}constructor(){super(),this.curveCollectionType="unionRegion",this._children=[]}static create(...t){const e=new xs;for(const i of t)e.tryAddChild(i);return e}dgnBoundaryType(){return 5}announceToCurveProcessor(t,e=-1){return t.announceUnionRegion(this,e)}cloneStroked(t){const e=new xs;let i;for(i of this._children){const s=i.cloneStroked(t);s&&e.children.push(s)}return e}cloneEmptyPeer(){return new xs}tryAddChild(t){return!(!t||!(t instanceof bi||t instanceof hi)||(this._children.push(t),0))}getChild(t){if(t<this._children.length)return this._children[t]}dispatchToGeometryHandler(t){return t.handleUnionRegion(this)}}class _s{constructor(){this._cachedObjects=[],this.numDrop=0,this.numCreate=0,this.numReuse=0}dropToCache(t){t&&(this.numDrop++,this.clearForCache(t),this._cachedObjects.push(t))}grabFromCache(){let t=this._cachedObjects.pop();return void 0===t?(t=this.createForCache(),this.numCreate++):this.numReuse++,t}dropAllToCache(t){for(;t.length>0;)this.dropToCache(t.pop())}}class ys extends _s{clearForCache(t){t.length=0}createForCache(){return new nt(10)}constructor(){super()}grabAndFill(t){const e=this.grabFromCache();return e.pushFrom(t),e}}class vs{get convexSets(){return this._convexSets}constructor(){this._convexSets=[]}toJSON(){const t=[];for(const e of this._convexSets)t.push(e.toJSON());return t}static fromJSON(t,e){if((e=e||new vs)._convexSets.length=0,!Array.isArray(t))return e;for(const i of t)e._convexSets.push(kn.fromJSON(i));return e}static createEmpty(t){return t?(t._convexSets.length=0,t):new vs}isAlmostEqual(t){if(this._convexSets.length!==t._convexSets.length)return!1;for(let e=0;e<this._convexSets.length;e++)if(!this._convexSets[e].isAlmostEqual(t._convexSets[e]))return!1;return!0}static createConvexSets(t,e){e=e||new vs;for(const i of t)e._convexSets.push(i);return e}clone(t){(t=t||new vs)._convexSets.length=0;for(const e of this._convexSets)t._convexSets.push(e.clone());return t}addConvexSet(t){t&&this._convexSets.push(t)}hasIntersectionWithRay(t,e){if(void 0===e){for(const e of this._convexSets)if(e.hasIntersectionWithRay(t))return!0;return!1}e.setNull();const i=ft.createNull();for(const s of this._convexSets)s.hasIntersectionWithRay(t,i)&&e.extendRange(i);return!e.isNull}isPointInside(t){for(const e of this._convexSets)if(e.isPointInside(t))return!0;return!1}isPointOnOrInside(t,e=Q.smallMetricDistance){for(const i of this._convexSets)if(i.isPointOnOrInside(t,e))return!0;return!1}isSphereInside(t,e){for(const i of this._convexSets)if(i.isSphereInside(t,e))return!0;return!1}isAnyPointInOrOnFromSegment(t){for(const e of this._convexSets)if(e.announceClippedSegmentIntervals(0,1,t.point0Ref,t.point1Ref))return!0;return!1}appendIntervalsFromSegment(t,e){for(const i of this._convexSets)i.announceClippedSegmentIntervals(0,1,t.point0Ref,t.point1Ref,((t,i)=>e.push(Re.create(t,i))))}transformInPlace(t){for(const e of this._convexSets)e.transformInPlace(t)}classifyPointContainment(t,e){for(const i of this._convexSets){const s=i.classifyPointContainment(t,e);if(s!==D.StronglyOutside)return s}return D.StronglyOutside}polygonClip(t,e){e.length=0,Array.isArray(t)&&(t=nt.create(t));const i=new nt;for(const s of this._convexSets){const n=new nt;s.polygonClip(t,n,i),0!==n.length&&e.push(n)}}announceClippedSegmentIntervals(t,e,i,s,n){let r=0;for(const o of this._convexSets)o.announceClippedSegmentIntervals(t,e,i,s,n)&&r++;return r>0}announceClippedArcIntervals(t,e){const i=vs._clipArcFractionArray;i.clear();for(const e of this._convexSets)for(const s of e.planes)s.appendIntersectionRadians(t,i);return t.sweep.radiansArrayToPositivePeriodicFractions(i),Rs.selectIntervals01(t,i,this,e)}computePlanePlanePlaneIntersectionsInAllConvexSets(t,e,i,s=!0){let n=0;for(const r of this._convexSets)n+=r.computePlanePlanePlaneIntersections(t,e,i,s);return n}multiplyPlanesByMatrix4d(t,e=!0,i=!0){if(e){const e=t.createInverse();return!!e&&this.multiplyPlanesByMatrix4d(e,!1,i)}for(const e of this._convexSets)e.multiplyPlanesByMatrix4d(t,!1,i);return!0}setInvisible(t){for(const e of this._convexSets)e.setInvisible(t)}addOutsideZClipSets(t,e,i){if(e){const i=kn.createEmpty();i.addZClipPlanes(t,e),this._convexSets.push(i)}if(i){const e=kn.createEmpty();e.addZClipPlanes(t,void 0,i),this._convexSets.push(e)}}takeConvexSets(t){let e;for(;void 0!==(e=t._convexSets.pop());)this._convexSets.push(e)}appendPolygonClip(t,e,i,s){const n=i.length,r=e.length;let o,a,c=[s.grabAndFill(t)],l=[];for(const t of this._convexSets){for(;void 0!==(a=c.pop());)t.appendPolygonClip(a,e,l,s),s.dropToCache(a);o=l,l=c,c=o}for(;void 0!==(a=c.pop());)i.push(a);i.length===n?Rs.restoreSingletonInPlaceOfMultipleShards(e,r,t,s):e.length===r&&Rs.restoreSingletonInPlaceOfMultipleShards(i,n,t,s)}}vs._clipArcFractionArray=new It;class Ps{static advanceIntervalDifference(t,e,i,s){const n=e.length;let r=t.low,o=t.high;for(;i<n;){const t=e[i];if(t.high<r)i++;else{if(!(t.high<=o)){t.low<o&&(o=t.low);break}t.low>r&&s.push(ft.createXX(r,t.low)),r=t.high,i++}}return r<o&&s.push(ft.createXX(r,o)),s}static differenceSorted(t,e){const i=t.length,s=[];for(let n=0;n<i;n++)Ps.advanceIntervalDifference(t[n],e,0,s);return s}static advanceIntervalIntersection(t,e,i){return e.low>t.high||(e.high>=t.high?(i.push(ft.createXX(e.low,t.high)),!0):(i.push(ft.createXX(e.low,e.high)),!1))}static intersectSorted(t,e){let i=0,s=0;const n=t.length,r=e.length,o=[];for(;i<n&&s<r;){const n=t[i],r=e[s];n.low<=r.low?Ps.advanceIntervalIntersection(n,r,o)?i++:s++:Ps.advanceIntervalIntersection(r,n,o)?s++:i++}return o}static advanceIntervalUnion(t,e,i){if(i>=e.length)return!1;const s=e[i];return!(s.low>t.high||(s.high>t.high&&(t.high=s.high),0))}static unionSorted(t,e){const i=t.length,s=e.length;let n=0,r=0;const o=[];for(;n<i&&r<s;){const i=t[n],s=e[r];let a;i.low<=s.low?(a=i.clone(),n++):(a=s.clone(),r++);let c=!0;do{const i=Ps.advanceIntervalUnion(a,t,n),s=Ps.advanceIntervalUnion(a,e,r);i&&n++,s&&r++,i||s||(c=!1)}while(c);o.push(a)}for(;n<i;)o.push(t[n++]);for(;r<s;)o.push(e[r++]);return o}static paritySorted(t,e){const i=[];for(const e of t)i.push(e.clone());for(const t of e)i.push(t.clone());return i.sort(As),Ps.simplifySortParity(i,!0),i}static sort(t){t.sort(As)}static simplifySortUnion(t,e=!1){if(t.length<2)return;t.sort(As);let i=0;for(let e=1;e<t.length;e++)t[e].low<=t[i].high?t[e].high>t[i].high&&(t[i].high=t[e].high):(i++,t[i].setFrom(t[e]));if(t.length=i+1,e){i=-1;for(let e=0;e<t.length;e++)t[e].low<t[e].high&&i<e&&t[++i].setFrom(t[e])}}static simplifySortParity(t,e=!1){const i=[];for(const e of t)e.low!==e.high&&(i.push(e.low),i.push(e.high));const s=i.length;i.sort(((t,e)=>t<e?-1:t>e?1:0));let n,r,o=0;for(let a=0;a<s;a+=2)if(n=i[a],r=i[a+1],e){for(;a+2<s&&i[a+2]===r;)a+=2,r=i[a+1];r>n&&ft.createXX(n,r,t[o++])}else ft.createXX(n,r,t[o++]);t.length=o}static testUnion(t,e){return this.countContainingRanges(t,e)>0}static testParity(t,e){let i=!1;for(const s of t)s.containsX(e)&&(i=!i);return i}static countContainingRanges(t,e){let i=0;for(const s of t)s.containsX(e)&&i++;return i}static getBreaks(t,e,i=!1,s=!1,n=!0){e||(e=new It(2*t.length)),n&&e.clear();for(const i of t)e.push(i.low),e.push(i.high);return i&&e.sort(),s&&e.compressAdjacentDuplicates(),e}static appendFractionalPoints(t,e,i,s,n,r,o,a){const c=t.length;if(c>0){void 0!==e&&a.push(t[0].fractionToPoint(e));for(let e=0;e<c;e++)void 0===i||!s&&t[e].low===t[e].high||a.push(t[e].fractionToPoint(i)),e>1&&void 0!==n&&(r||t[e].low!==t[e].high)&&a.push(Q.interpolate(t[e-1].high,n,t[e].low));void 0!==o&&a.push(t[c-1].fractionToPoint(o))}return a}static firstLowToLastHigh(t){return 0===t.length?ft.createNull():ft.createXX(t[0].low,t[t.length-1].high)}static sumLengths(t){let e=0;for(const i of t)e+=i.length();return e}static isSorted(t,e=!0){const i=t.length;if(e){for(let e=0;e+1<i;e++)if(t[e].high>=t[e+1].low)return!1}else for(let e=0;e+1<i;e++)if(t[e].high>t[e+1].low)return!1;return!0}}function As(t,e){return t.low<e.low?-1:t.low>e.low?1:t.high<e.high?-1:t.high>e.high?1:0}class Is{constructor(){this.points=[],this.planes=kn.createEmpty(),this.children=[],this.startIdx=-1,this.numPoints=-1}static createWithIndices(t,e,i){return(i=i||new Is).startIdx=t,i.numPoints=e,i.children.length=0,i}static createTreeForPolygon(t,e){return(e=e||new Is).empty(),Ss.createPointsRef(t).buildHullTree(e),e}static createHullAndInletsForPolygon(t,e){return(e=e||new Is).empty(),Ss.createPointsRef(t).buildHullAndInletsForPolygon(e),e}extractLoopsGo(t){t.push(ue.clonePoint3dArray(this.points));for(const e of this.children)e.extractLoopsGo(t)}extractLoops(){const t=[];return this.extractLoopsGo(t),t}empty(){this.points.length=0,this.planes.planes.length=0,this.children.length=0,this.startIdx=-1,this.numPoints=-1}clone(t){t=t||new Is;for(const e of this.points)t.points.push(e.clone());t.planes=kn.createEmpty();for(const e of this.planes.planes)t.planes.planes.push(e.clone());for(const e of this.children)t.children.push(e.clone());return t.startIdx=this.startIdx,t.numPoints=this.numPoints,t}addEmptyChild(t,e){const i=Is.createWithIndices(t,e);this.children.push(i)}addPlane(t){this.planes.addPlaneToConvexSet(t)}isPointOnOrInside(t){if(!this.planes.isPointOnOrInside(t,0))return!1;for(const e of this.children)if(e.isPointOnOrInside(t))return!1;return!0}captureConvexClipPlaneSetAsVoid(t){this.children.push(t)}appendCurvePrimitiveClipIntervals(t,e,i){(new ws).appendSingleClipPrimitive(this,t,e,i)}appendCurveCollectionClipIntervals(t,e,i){(new ws).appendCurveCollectionClip(this,t,e,i)}appendPolygonClip(t,e,i,s){const n=i.length,r=this.planes.clipInsidePushOutside(t,i,s);if(void 0===r)Rs.restoreSingletonInPlaceOfMultipleShards(i,n,t,s);else{let t,n,o=[r],a=[];for(const e of this.children){for(a.length=0;void 0!==(n=o.pop());)e.appendPolygonClip(n,i,a,s),s.dropToCache(n);t=a,a=o,o=t}for(;void 0!==(n=o.pop());)e.push(n)}}depth(){let t=0;for(const e of this.children)t=Math.max(t,e.depth());return 1+t}}class Ss{constructor(){this._points=[],this._stack=[]}static createPointsRef(t,e){return(e=e||new Ss)._points=t,Ur.areaXY(t)<0&&e._points.reverse(),e._points[e._points.length-1].isAlmostEqualMetric(e._points[0])&&e._points.pop(),e}get period(){return this._points.length}indexAfter(t){return(t+1)%this._points.length}indexBefore(t){return(t+this._points.length-1)%this._points.length}pushIndex(t){this._stack.push(t)}static cross(t,e,i){return t.crossProductToPointsXY(e,i)}cyclicStackPoint(t){let e;const i=this._stack;return e=t>0?t:t+10*i.length,e%=i.length,this._points[i[e]]}signFromStackTip(t,e){const i=this.cyclicStackPoint(-2),s=this.cyclicStackPoint(-1),n=this._points[t];return e*Ss.cross(i,s,n)>=0?1:-1}get indexOfMaxX(){let t=0;const e=this._points,i=this._points.length;for(let s=1;s<i;s++)e[s].x>e[t].x&&(t=s);return t}extendHullChain(t,e,i){for(;this._stack.length>1&&this.signFromStackTip(t,e)<0;)this._stack.pop();i&&this.pushIndex(t)}collectHullChain(t,e,i){if(this._stack.length=0,e>2){let s=t;for(let t=0;t<e;t++)this.extendHullChain(s,i,!0),s=this.indexAfter(s)}}collectHullPointsInArray(t,e,i,s){if(t.length=0,i>2){let s=e;for(let e=0;e<i;e++)t.push(this._points[s]),s=this.indexAfter(s)}}buildHullTreeGo(t,e,i=!0){this.collectHullChain(t.startIdx,t.numPoints,e?1:-1),t.points.length=0;const s=this._stack,n=this._points,r=s.length;for(let i=0;i<r;i++){const o=s[i];if(t.points.push(n[o]),i+1<r){let r=s[i+1];if(r===this.indexAfter(o)){const i=Wr.createEdgeAndUpVector(n[o],n[r],$.create(0,0,1),W.createRadians(0));void 0!==i&&(e&&i.negateInPlace(),t.addPlane(i))}else r<o&&(r+=this.period),t.addEmptyChild(o,r-o+1)}}if(i)for(const i of t.children)this.buildHullTreeGo(i,!e);else for(const i of t.children)this.collectHullPointsInArray(i.points,i.startIdx,i.numPoints,e?-1:1);return!0}buildHullAndInletsForPolygon(t){return Is.createWithIndices(this.indexOfMaxX,this.period+1,t),this.buildHullTreeGo(t,!0,!1)}buildHullTree(t){return Is.createWithIndices(this.indexOfMaxX,this.period+1,t),this.buildHullTreeGo(t,!0)}}class ws{constructor(){this._stackDepth=0,this._intervalStack=[]}setCurveRef(t){this._curve=t}popSegmentFrame(){this._stackDepth>0&&(this._topOfStack.length=0,this._stackDepth-=1)}clearSegmentStack(){for(;this._stackDepth>0;)this.popSegmentFrame()}pushEmptySegmentFrame(){for(this._stackDepth+=1;this._intervalStack.length<this._stackDepth;)this._intervalStack.push([]);this._topOfStack.length=0}get _topOfStack(){return this._intervalStack[this._stackDepth-1]}set _topOfStack(t){const e=this._stackDepth;e>0&&(this._intervalStack[e-1]=t)}stackEntry(t){return t<=this._stackDepth?this._intervalStack[this._stackDepth-1-t]:[]}isTopOfStackEmpty(){return 0===this._topOfStack.length}appendSingleClipToStack(t,e){const i=ws._fractionIntervals;if(this._curve instanceof Ce){let i,s;return this._curve.announceClipIntervals(t,((t,e,n)=>{i=t,s=e}))&&e.push(ft.createXX(i,s)),!0}if(this._curve instanceof Ti){const s=this._curve;i.length=0,s.announceClipIntervals(t,((t,e,s)=>{i.push(t),i.push(e)}));for(let t=0;t<i.length;t+=2)e.push(ft.createXX(i[t],i[t+1]));return!0}if(this._curve instanceof Me&&this._curve.points.length>1){const i=this._curve;let s,n;const r=i.points.length,o=1/(r-1);for(let a=0;a<r-1;a++)Ce.create(i.points[a],i.points[a+1]).announceClipIntervals(t,((t,e,i)=>{s=t,n=e}))&&e.push(ft.createXX((a+s)*o,(a+n)*o));return!0}if(this._curve instanceof Be){const s=this._curve;i.length=0,s.announceClipIntervals(t,((t,e,s)=>{i.push(t),i.push(e)}));for(let t=0;t<i.length;t+=2)e.push(ft.createXX(i[t],i[t+1]));return!0}return!1}recurse(t){if(this.pushEmptySegmentFrame(),this.appendSingleClipToStack(t.planes,this._topOfStack),Ps.sort(this._topOfStack),!this.isTopOfStackEmpty())for(const e of t.children){if(this.recurse(e),this.isTopOfStackEmpty())this.popSegmentFrame();else{const t=Ps.differenceSorted(this.stackEntry(1),this.stackEntry(0));this.popSegmentFrame(),this._topOfStack=t}if(this.isTopOfStackEmpty())break}}appendSingleClipPrimitive(t,e,i,s){if(this.setCurveRef(e),this.clearSegmentStack(),this.recurse(t),1!==this._stackDepth)return;const n=this._topOfStack;for(const t of n){const s=t.low,n=t.high,r=e.fractionToPoint(s),o=e.fractionToPoint(n);i.push(Pt.createCapture(vt.createCurveFractionPoint(e,s,r),vt.createCurveFractionPoint(e,n,o)))}this.popSegmentFrame()}appendCurveCollectionClip(t,e,i,s){for(const n of e.children)n instanceof ae?this.appendSingleClipPrimitive(t,n,i,s):n instanceof si&&this.appendCurveCollectionClip(t,n,i,s)}}ws._fractionIntervals=[],function(t){t[t.None=0]="None",t[t.XLow=1]="XLow",t[t.XHigh=2]="XHigh",t[t.YLow=4]="YLow",t[t.YHigh=8]="YHigh",t[t.ZLow=16]="ZLow",t[t.ZHigh=32]="ZHigh",t[t.XAndY=15]="XAndY",t[t.All=63]="All"}(E||(E={}));class Cs{fetchClipPlanesRef(){return this.ensurePlaneSets(),this._clipPlanes}get invisible(){return this._invisible}constructor(t,e=!1){this._clipPlanes=t,this._invisible=e}static createCapture(t,e=!1){let i;return t instanceof vs&&(i=t),t instanceof kn&&(i=vs.createConvexSets([t])),new Cs(i,e)}toJSON(){const t={};return this._clipPlanes&&(t.clips=this._clipPlanes.toJSON()),this._invisible&&(t.invisible=!0),{planes:t}}arePlanesDefined(){return void 0!==this._clipPlanes}clone(){const t=this._clipPlanes?this._clipPlanes.clone():void 0;return new Cs(t,this._invisible)}ensurePlaneSets(){}pointInside(t,e=Q.smallMetricDistanceSquared){this.ensurePlaneSets();let i=!0;return this._clipPlanes&&(i=this._clipPlanes.isPointOnOrInside(t,e)),i}isPointOnOrInside(t,e=Q.smallMetricDistanceSquared){this.ensurePlaneSets();let i=!0;return this._clipPlanes&&(i=this._clipPlanes.isPointOnOrInside(t,e)),i}announceClippedSegmentIntervals(t,e,i,s,n){this.ensurePlaneSets();let r=!1;return this._clipPlanes&&(r=this._clipPlanes.announceClippedSegmentIntervals(t,e,i,s,n)),r}announceClippedArcIntervals(t,e){this.ensurePlaneSets();let i=!1;return this._clipPlanes&&(i=this._clipPlanes.announceClippedArcIntervals(t,e)),i}multiplyPlanesByMatrix4d(t,e=!0,i=!0){if(e){const e=t.createInverse();return!!e&&this.multiplyPlanesByMatrix4d(e,!1,i)}return this._clipPlanes&&this._clipPlanes.multiplyPlanesByMatrix4d(t),!0}transformInPlace(t){return this._clipPlanes&&this._clipPlanes.transformInPlace(t),!0}setInvisible(t){this._invisible=t}containsZClip(){if(void 0!==this.fetchClipPlanesRef())for(const t of this._clipPlanes.convexSets)for(const e of t.planes)if(Math.abs(e.inwardNormalRef.z)>1e-6&&Math.abs(e.distance)!==Number.MAX_VALUE)return!0;return!1}classifyPointContainment(t,e){this.ensurePlaneSets();const i=this._clipPlanes;let s=D.StronglyInside;if(i&&(s=i.classifyPointContainment(t,!1)),this._invisible&&!e)switch(s){case D.StronglyInside:return D.StronglyOutside;case D.StronglyOutside:return D.StronglyInside;case D.Ambiguous:return D.Ambiguous}return s}static fromJSON(t){if(!t)return;return Fs.fromClipShapeJSON(t)||Cs.fromJSONClipPrimitive(t)}static fromJSONClipPrimitive(t){const e=t?.planes;if(!e)return;const i=e.clips?vs.fromJSON(e.clips):void 0,s=void 0!==e.invisible&&e.invisible;return new Cs(i,s)}}class Ts{constructor(t,e,i,s){this.pointA=j.create(t.x,t.y,s),this.pointB=j.create(e.x,e.y,s),this.normal=i}static makeUnitPerpendicularToBisector(t,e,i){let s=e.normal.minus(t.normal);if(void 0!==s.normalize(s)||(s=$.createStartEnd(t.pointA,e.pointB),void 0!==s.normalize(s)))return i&&s.scale(-1,s),s}}class Fs extends Cs{constructor(t=[],e,i,s,n=!1,r=!1){super(void 0,r),this._isMask=!1,this._polygon=t,this.initSecondaryProps(n,e,i,s)}get invisible(){return this._invisible}get transformFromClip(){return this._transformFromClip}get transformToClip(){return this._transformToClip}get transformValid(){return void 0!==this.transformFromClip}get zLowValid(){return void 0!==this._zLow}get zHighValid(){return void 0!==this._zHigh}get transformIsValid(){return void 0!==this._transformFromClip}get zLow(){return this._zLow}get zHigh(){return this._zHigh}get polygon(){return this._polygon}get isMask(){return this._isMask}setPolygon(t){t[0].isAlmostEqual(t[t.length-1])||t.push(t[0].clone()),this._polygon=t}ensurePlaneSets(){void 0===this._clipPlanes&&(this._clipPlanes=vs.createEmpty(),this.parseClipPlanes(this._clipPlanes),this._transformFromClip&&this._clipPlanes.transformInPlace(this._transformFromClip))}initSecondaryProps(t,e,i,s){this._isMask=t,this._zLow=e,this._zHigh=i,void 0!==s?(this._transformFromClip=s,this._transformToClip=s.inverse()):(this._transformFromClip=pt.createIdentity(),this._transformToClip=pt.createIdentity())}toJSON(){const t={points:this._polygon.map((t=>t.toJSON()))};return this.invisible&&(t.invisible=!0),this._transformFromClip&&!this._transformFromClip.isIdentity&&(t.trans=this._transformFromClip.toJSON()),this.isMask&&(t.mask=!0),void 0!==this.zLow&&this.zLow!==-Number.MAX_VALUE&&(t.zlow=this.zLow),void 0!==this.zHigh&&this.zHigh!==Number.MAX_VALUE&&(t.zhigh=this.zHigh),{shape:t}}static fromClipShapeJSON(t,e){const i=t?.shape;if(!i)return;const s=i.points?i.points.map((t=>j.fromJSON(t))):[],n=i.trans?pt.fromJSON(i.trans):void 0,r="number"==typeof i.zlow?i.zlow:void 0,o="number"==typeof i.zhigh?i.zhigh:void 0,a="boolean"==typeof i.mask&&i.mask,c="boolean"==typeof i.invisible&&i.invisible;return Fs.createShape(s,r,o,n,a,c,e)}static createFrom(t,e){const i=Fs.createEmpty(!1,!1,void 0,e);i._invisible=t._invisible;for(const e of t._polygon)i._polygon.push(e.clone());return i._isMask=t._isMask,i._zLow=t._zLow,i._zHigh=t._zHigh,i._transformToClip=t._transformToClip?t._transformToClip.clone():void 0,i._transformFromClip=t._transformFromClip?t._transformFromClip.clone():void 0,i}static createShape(t=[],e,i,s,n=!1,r=!1,o){if(t.length<3)return;const a=t.slice(0);return a[0].isAlmostEqual(a[a.length-1])?a[0].clone(a[a.length-1]):a.push(a[0].clone()),o?(o._clipPlanes=void 0,o._invisible=r,o._polygon=a,o.initSecondaryProps(n,e,i,s),o):new Fs(a,e,i,s,n,r)}static createBlock(t,e,i=!1,s=!1,n,r){const o=t.low,a=t.high,c=[];for(let t=0;t<5;t++)c.push(j.create());return c[0].x=c[3].x=c[4].x=o.x,c[1].x=c[2].x=a.x,c[0].y=c[1].y=c[4].y=o.y,c[2].y=c[3].y=a.y,Fs.createShape(c,E.None!==(e&E.ZLow)?o.z:void 0,E.None!==(e&E.ZHigh)?a.z:void 0,n,i,s,r)}static createEmpty(t=!1,e=!1,i,s){return s?(s._clipPlanes=void 0,s._invisible=e,s._polygon.length=0,s.initSecondaryProps(t,void 0,void 0,i),s):new Fs([],void 0,void 0,i,t,e)}get isValidPolygon(){return!(this._polygon.length<3||!this._polygon[0].isExactEqual(this._polygon[this._polygon.length-1]))}clone(t){return Fs.createFrom(this,t)}parseClipPlanes(t){const e=this._polygon;if(3===e.length&&!this._isMask&&e[0].isExactEqual(e[e.length-1]))return this.parseLinearPlanes(t,this._polygon[0],this._polygon[1]),!0;if(!this.isMask){const e=Ur.testXYPolygonTurningDirections(this.polygon);if(0!==e)return this.parseConvexPolygonPlanes(t,this._polygon,e,!1),!0}return this.parsePolygonPlanes(t,this._polygon,this.isMask),!0}parseLinearPlanes(t,e,i,s){const n=e.vectorTo(i);if(0===n.magnitude())return!1;n.normalize(n);const r=kn.createEmpty();if(void 0===s){const t=J.create(-n.y,n.x);r.planes.push(Wr.createNormalAndPoint($.create(n.x,n.y),j.createFrom(e),this._invisible)),r.planes.push(Wr.createNormalAndPoint($.create(-n.x,-n.y),j.createFrom(i),this._invisible)),r.planes.push(Wr.createNormalAndPoint($.create(t.x,t.y),j.createFrom(e),this._invisible)),r.planes.push(Wr.createNormalAndPoint($.create(-t.x,-t.y),j.createFrom(e),this._invisible))}else{const t=j.create(e.x,e.y,-s),n=j.create(i.x,i.y,-s),o=$.createFrom(n),a=o.crossProduct($.createFrom(t)).normalize();let c=$.createFrom(t).crossProduct(a).normalize();r.planes.push(Wr.createNormalAndDistance(a,0,this._invisible)),r.planes.push(Wr.createNormalAndDistance(c,0,this._invisible)),a.negate(),c=o.crossProduct(a).normalize(),r.planes.push(Wr.createNormalAndDistance(a,0,this._invisible)),r.planes.push(Wr.createNormalAndDistance(c,0,this._invisible))}return r.addZClipPlanes(this._invisible,this._zLow,this._zHigh),t.addConvexSet(r),!0}parseConvexPolygonPlanes(t,e,i,s,n){const r=[],o=i<0;for(let t=0;t<e.length-1;t++){const i=void 0===n?0:-n,s=$.createStartEnd(e[t],e[t+1]),a=s.magnitude();if(s.normalize(s),a>1e-8){const n=$.create(o?s.y:-s.y,o?-s.x:s.x);r.push(new Ts(e[t],e[t+1],n,i))}}if(r.length<3)return!1;if(s){const e=r.length-1;for(let i=0;i<=e;i++){const s=r[i],n=r[i?i-1:e],a=r[i===e?0:i+1],c=kn.createEmpty(),l=Ts.makeUnitPerpendicularToBisector(n,s,!o),h=Ts.makeUnitPerpendicularToBisector(s,a,o);l&&c.planes.push(Wr.createNormalAndPoint(l,s.pointA,this._invisible,!0)),c.planes.push(Wr.createNormalAndPoint(s.normal,s.pointB,this._invisible,!1)),h&&c.planes.push(Wr.createNormalAndPoint(h,a.pointA,this._invisible,!0)),t.addConvexSet(c),t.addOutsideZClipSets(this._invisible,this._zLow,this._zHigh)}}else{const e=kn.createEmpty();if(void 0===n)for(const t of r)e.planes.push(Wr.createNormalAndPoint($.create(t.normal.x,t.normal.y),t.pointA));else if(o)for(const t of r)e.planes.push(Wr.createNormalAndDistance($.createFrom(t.pointA).crossProduct($.createFrom(t.pointB)).normalize(),0));else for(const t of r)e.planes.push(Wr.createNormalAndDistance($.createFrom(t.pointB).crossProduct($.createFrom(t.pointA)).normalize(),0));e.addZClipPlanes(this._invisible,this._zLow,this._zHigh),t.addConvexSet(e)}return!0}parsePolygonPlanes(t,e,i,s){const n=Mi.compressDanglers(e,!0),r=(e,i)=>{if(!i.isMaskSet(b.EXTERIOR)){const e=i.collectAroundFace((t=>{if(!t.isMaskSet(b.EXTERIOR))return j.create(t.x,t.y,0)}));e.push(e[0].clone());const n=Ur.testXYPolygonTurningDirections(e);this.parseConvexPolygonPlanes(t,e,n,!1,s)}return!0};if(i){const e=ue.clonePoint3dArray(n),i=Is.createHullAndInletsForPolygon(e).extractLoops();if(0===i.length)return!1;const o=i[0],a=Ur.testXYPolygonTurningDirections(o);this.parseConvexPolygonPlanes(t,o,-a,!0,s);for(let t=1;t<i.length;t++){const e=Us.createTriangulatedGraphFromSingleLoop(i[t]);e&&(Us.flipTriangles(e),e.announceFaceLoops(r))}return!0}{const t=Us.createTriangulatedGraphFromSingleLoop(n);if(void 0===t)return!1;Us.flipTriangles(t),t.announceFaceLoops(r)}return!0}multiplyPlanesByMatrix4d(t,e=!0,i=!0){return this.ensurePlaneSets(),super.multiplyPlanesByMatrix4d(t,e,i)}transformInPlace(t){return t.isIdentity||(super.transformInPlace(t),this._transformFromClip?t.multiplyTransformTransform(this._transformFromClip,this._transformFromClip):this._transformFromClip=t.clone(),this._transformToClip=this._transformFromClip.inverse()),!0}get isXYPolygon(){return 0!==this._polygon.length&&(void 0===this._transformFromClip||this._transformFromClip.matrix.columnZ().magnitudeXY()<1e-8)}performTransformToClip(t){void 0!==this._transformToClip&&this._transformToClip.multiplyPoint3d(t,t)}performTransformFromClip(t){void 0!==this._transformFromClip&&this._transformFromClip.multiplyPoint3d(t,t)}}class ks{constructor(t){this._keepInside=t,this._clippers=[],this._intervalsA=[],this._intervalsB=[]}toJSON(){const t=[];for(const e of this._clippers){const i=e;i.toJSON&&t.push(i.toJSON())}const e={};return e[this.operationName]=t,e}captureChild(t){if(Array.isArray(t))for(const e of t)this.captureChild(e);else this._clippers.push(t)}toggleResult(){return this.selectResult(!this._keepInside)}selectResult(t){const e=this._keepInside;return this._keepInside=t,e}testedAnnounceNN(t,e,i){return t<e?(i&&i(t,e),1):0}testedAnnounceNNC(t,e,i,s){return t<e?(s&&s(t,e,i),1):0}swapAB(){const t=this._intervalsA;this._intervalsA=this._intervalsB,this._intervalsB=t}announcePartsNN(t,e,i,s,n){let r=0;if(t)for(const t of e)r+=this.testedAnnounceNN(t.low,t.high,n);else{let t=i;for(const i of e)r+=this.testedAnnounceNN(t,i.low,n),t=i.high;r+=this.testedAnnounceNN(t,s,n)}return r>0}announcePartsNNC(t,e,i,s,n,r){let o=0;if(t)for(const t of e)o+=this.testedAnnounceNNC(t.low,t.high,n,r);else{let t=i;for(const i of e)o+=this.testedAnnounceNNC(t,i.low,n,r),t=i.high;o+=this.testedAnnounceNNC(t,s,n,r)}return o>0}isPointOnOrInside(t){const e=this.isPointOnOrInsideChildren(t);return this._keepInside?e:!e}announceClippedSegmentIntervals(t,e,i,s,n){this._intervalsA.length=0;const r=(t,e)=>{this._intervalsB.push(ft.createXX(t,e))};let o=0;for(const n of this._clippers)this._intervalsB.length=0,n.announceClippedSegmentIntervals(t,e,i,s,r),Ps.simplifySortUnion(this._intervalsB),0===o?this.swapAB():this._intervalsA=this.combineIntervals(this._intervalsA,this._intervalsB),o++;return this.announcePartsNN(this._keepInside,this._intervalsA,t,e,n)}announceClippedArcIntervals(t,e){this._intervalsA.length=0;const i=(t,e)=>{this._intervalsB.push(ft.createXX(t,e))};let s=0;for(const e of this._clippers)this._intervalsB.length=0,e.announceClippedArcIntervals(t,i),Ps.simplifySortUnion(this._intervalsB),0===s?this.swapAB():this._intervalsA=this.combineIntervals(this._intervalsA,this._intervalsB),s++;return this.announcePartsNNC(this._keepInside,this._intervalsA,0,1,t,e)}}class Ms extends ks{get operationName(){return this._keepInside?"AND":"NAND"}constructor(t){super(t)}isPointOnOrInsideChildren(t){for(const e of this._clippers)if(!e.isPointOnOrInside(t))return!1;return!0}combineIntervals(t,e){return Ps.intersectSorted(t,e)}appendPolygonClip(t,e,i,s){Rs.doPolygonClipSequence(t,this._clippers,this._keepInside?e:i,this._keepInside?i:e,void 0,X.passToNextStep,X.acceptOut,X.acceptIn,s)}}class bs{get clips(){return this._clips}constructor(t){this.boundingRange=ut.createNull(),this._clips=t||[]}get isValid(){return this._clips.length>0}static createEmpty(t){return t?(t._clips.length=0,t):new bs}static createCapture(t,e){return e?(e._clips=t,e):new bs(t)}static create(t,e){const i=[];for(const e of t)i.push(e.clone());return bs.createCapture(i,e)}clone(t){const e=t||new bs;e._clips.length=0;for(const t of this._clips)e._clips.push(t.clone());return e.boundingRange.setFrom(this.boundingRange),e}toJSON(){return this.isValid?this.clips.map((t=>t.toJSON())):[]}static fromJSON(t,e){if((e=e||new bs).clear(),!Array.isArray(t))return e;try{for(const i of t){const t=Cs.fromJSON(i);t&&e._clips.push(t)}}catch{e.clear()}return e}clear(){this._clips.length=0}appendClone(t){this._clips.push(t.clone())}appendReference(t){this._clips.push(t)}appendShape(t,e,i,s,n=!1,r=!1){const o=Fs.createShape(t,e,i,s,n,r);return!!o&&(this._clips.push(o),!0)}pointInside(t,e=Q.smallMetricDistanceSquared){return this.isPointOnOrInside(t,e)}isPointOnOrInside(t,e=Q.smallMetricDistanceSquared){if(!this.boundingRange.isNull&&!this.boundingRange.containsPoint(t))return!1;for(const i of this._clips)if(!i.pointInside(t,e))return!1;return!0}ensureProxyClipNode(){if(this._clipNodeProxy)return!0;this._clipNodeProxy=new Ms(!0);let t=0;for(const e of this._clips){const i=e.fetchClipPlanesRef();i&&(t++,this._clipNodeProxy.captureChild(i))}return t>0}announceClippedSegmentIntervals(t,e,i,s,n){return this.ensureProxyClipNode(),!!this._clipNodeProxy&&this._clipNodeProxy.announceClippedSegmentIntervals(t,e,i,s,n)}announceClippedArcIntervals(t,e){return this.ensureProxyClipNode(),!!this._clipNodeProxy&&this._clipNodeProxy.announceClippedArcIntervals(t,e)}appendPolygonClip(t,e,i,s){this.ensureProxyClipNode(),this._clipNodeProxy&&this._clipNodeProxy.appendPolygonClip(t,e,i,s)}transformInPlace(t){for(const e of this._clips)if(!1===e.transformInPlace(t))return!1;return this.boundingRange.isNull||t.multiplyRange(this.boundingRange,this.boundingRange),!0}extractBoundaryLoops(t,e){let i=E.None,s=-Number.MAX_VALUE,n=Number.MAX_VALUE;const r=[];let o,a=0;if(0===this._clips.length)return r;const c=pt.createIdentity();for(const e of this._clips)if(e instanceof Fs){if(void 0!==o&&e!==o){let t=pt.createIdentity(),i=pt.createIdentity();o.transformValid&&e.transformValid&&(t=e.transformFromClip.clone(),i=o.transformToClip.clone()),c.setFrom(i.multiplyTransformTransform(t))}if(o||(o=e),t[a]=[],void 0!==e.polygon){i=E.XAndY,e.zHighValid&&(i|=E.ZHigh,n=e.zHigh),e.zLowValid&&(i|=E.ZLow,s=e.zLow);for(const i of e.polygon)t[a].push(i.clone());c.multiplyPoint3dArray(t[a],t[a]),a++}}return r.push(i),r.push(s),r.push(n),e&&o&&e.setFrom(o.transformFromClip),r}setInvisible(t){for(const e of this._clips)e.setInvisible(t)}parseClipPlanes(){for(const t of this._clips)t.fetchClipPlanesRef()}multiplyPlanesByMatrix4d(t,e=!0,i=!0){if(e){const e=t.createInverse();return!!e&&this.multiplyPlanesByMatrix4d(e,!1,i)}for(const e of this._clips)e.multiplyPlanesByMatrix4d(t,!1,i);return!0}classifyPointContainment(t,e=!1){let i=D.Ambiguous;for(const s of this._clips){const n=s.classifyPointContainment(t,e);if(D.Ambiguous===n)return D.Ambiguous;if(D.Ambiguous===i)i=n;else if(i!==n)return D.Ambiguous}return i}classifyRangeContainment(t,e){const i=t.corners();return this.classifyPointContainment(i,e)}isAnyLineStringPointInside(t){for(const e of this._clips){const i=e.fetchClipPlanesRef();if(void 0!==i)for(let e=0;e+1<t.length;e++){const s=Ce.create(t[e],t[e+1]);if(i.isAnyPointInOrOnFromSegment(s))return!0}}return!1}sumSizes(t,e,i){let s=0;for(let n=e;n<i;n++)s+=t[n].x1-t[n].x0;return s}isLineStringCompletelyContained(t){const e=[];for(let i=0;i+1<t.length;i++){const s=Ce.create(t[i],t[i+1]);let n=0,r=0;for(const t of this._clips){const i=t.fetchClipPlanesRef();if(void 0!==i){i.appendIntervalsFromSegment(s,e);const t=e.length;if(n+=this.sumSizes(e,r,t),r=t,n>=bs._TARGET_FRACTION_SUM)break}}if(n<bs._TARGET_FRACTION_SUM)return!1}return!0}toCompactString(){function t(t){return`${t.toString()}_`}function i(i){let s=i.invisible?1:0;return s|=i.interior?2:0,`${function(t){const i=t.toString();return e(1===i.length),i}(s)}${n=i.inwardNormalRef,`${t(n.x)}${t(n.y)}${t(n.z)}`}${t(i.distance)}`;var n}function s(t){let e="";for(const s of t.planes)e=`${e}${i(s)}`;return`${e}_`}function n(t){let i=(t.invisible?1:0).toString();e(1===i.length);const n=t.fetchClipPlanesRef();if(n)for(const t of n.convexSets)i=`${i}${s(t)}`;return`${i}_`}let r="";for(const t of this.clips)r=`${r}${n(t)}`;return`${r}_`}}bs._TARGET_FRACTION_SUM=.99999999,function(t){t.fromClipVector=function(t){if(!t||!t.isValid)return;const i=t;void 0===i.clipString&&(i.clipString=t.toCompactString());const s=i;return e(void 0!==s.clipString),s}}(R||(R={}));class Es{constructor(t,e){this._positiveOffsetLeft=t,this._positiveOffsetRight=e,this._turnDegrees=60}static createUnit(t,e,i,s=!0){let n=e,r=e+1;const o=t.length-1;i?e<0?(n=o-1,r=o):e>=o&&(n=0,r=1):0===e?(n=0,r=1):r>o&&(n=o-1,r=o);const a=t.vectorIndexIndex(n,r);if(a)return s&&(a.z=0),a.normalize(a)}static createDirectedPlane(t,e,i,s,n=!1){return Wr.createNormalAndPointXYZXYZ(e.x*s,e.y*s,e.z*s,t.x+i*e.x,t.y+i*e.y,t.z+i*e.z,n,n)}createChamferCut(t,e,i,s){const n=i.angleToXY(s).degrees;if(Math.abs(n)>this._turnDegrees){const r=i.interpolate(.5,s);r.rotate90CCWXY(r),r.normalizeInPlace(),n>0?t.addPlaneToConvexSet(Es.createDirectedPlane(e,r,-this._positiveOffsetRight,1,!1)):t.addPlaneToConvexSet(Es.createDirectedPlane(e,r,this._positiveOffsetLeft,-1,!1))}}createOffsetFromSegment(t,e,i,s,n){if(void 0===s)return;void 0===i&&(i=s),void 0===n&&(n=s);const r=i.interpolate(.5,s);r.normalizeInPlace();const o=s.rotate90CCWXY(),a=s.interpolate(.5,n);a.normalizeInPlace();const c=kn.createEmpty();return c.addPlaneToConvexSet(Es.createDirectedPlane(t,o,this._positiveOffsetLeft,-1,!1)),c.addPlaneToConvexSet(Es.createDirectedPlane(t,o,-this._positiveOffsetRight,1,!1)),c.addPlaneToConvexSet(Es.createDirectedPlane(t,r,0,1,!0)),c.addPlaneToConvexSet(Es.createDirectedPlane(e,a,0,-1,!0)),this.createChamferCut(c,t,i,s),this.createChamferCut(c,e,s,n),c}static createClipBetweenOffsets(t,e,i,s,n){const r=new Es(e,i),o=vs.createEmpty();if(t.length>1){const e=Q.isSmallMetricDistance(t.distanceIndexIndex(0,t.length-1));for(let i=0;i+1<t.length;i++){const a=this.createUnit(t,i-1,e),c=this.createUnit(t,i,e),l=this.createUnit(t,i+1,e),h=r.createOffsetFromSegment(t.getPoint3dAtUncheckedPointIndex(i),t.getPoint3dAtUncheckedPointIndex(i+1),a,c,l);h?.addZClipPlanes(!1,s,n),h&&o.addConvexSet(h)}}else{const t=kn.createEmpty();t?.addZClipPlanes(!1,s,n),t.planes.length>0&&o.addConvexSet(t)}return o}}!function(t){t[t.StronglyInside=1]="StronglyInside",t[t.Ambiguous=2]="Ambiguous",t[t.StronglyOutside=3]="StronglyOutside"}(D||(D={})),(q=X||(X={}))[q.acceptIn=1]="acceptIn",q[q.acceptOut=-1]="acceptOut",q[q.passToNextStep=0]="passToNextStep",function(t){t[t.ClipRequired=0]="ClipRequired",t[t.TrivialReject=1]="TrivialReject",t[t.TrivialAccept=2]="TrivialAccept"}(z||(z={}));class Rs{static selectIntervals01(t,e,i,s){e.push(0),e.push(1),e.sort();let n,r,o=e.atUncheckedIndex(0);const a=Rs._selectIntervals01TestPoint,c=e.length;for(let l=1;l<c;l++)if(n=e.atUncheckedIndex(l),n>o+Q.smallFraction){if(r=.5*(o+n),r>=0&&r<=1&&(t.fractionToPoint(r,a),i.isPointOnOrInside(a))){if(!s)return!0;s(o,n,t)}o=n}return!1}static announceNNC(t,e,i){if(i)for(const s of t)i(s.low,s.high,e);return t.length>0}static collectClippedCurves(t,e){const i=[];return t.announceClipIntervals(e,((t,e,s)=>{if(e!==t){const n=s.clonePartialCurve(t,e);n&&i.push(n)}})),i}static clipAnyRegion(t,e){let i;const s=Rs._workTransform=Fi.createRightHandedFrame(void 0,t,Rs._workTransform);if(!s)return i;const n=s?.inverse();if(!n)return i;const r=t.cloneTransformed(n);if(!r)return i;const o=Rs._workRange=r.range(),a=o.xLength(),c=o.yLength(),l=Me.createRectangleXY(o.low,a,c,!0);l.tryTransformInPlace(s);const h=[],d=new ys;if(e.appendPolygonClip?.(l.packedPoints,h,[],d),0===h.length)return i;for(const t of h){const e=hi.createPolygon(t);e.tryTransformInPlace(n);const o=Er.regionBooleanXY(r,e,U.Intersection);o&&(o.tryTransformInPlace(s),i?i.tryAddChild(o)||i.children.push(...o.children):i=o instanceof xs?o:xs.create(o))}return i}static clipAnyCurve(t,e){if(t instanceof ae)return Rs.collectClippedCurves(t,e);if(t.isAnyRegion()){const i=Rs.clipAnyRegion(t,e);return i?[i]:[]}const i=[];if(t instanceof oi||t instanceof ri)for(const s of t.children){const t=Rs.clipAnyCurve(s,e);i.push(...t)}return i}static clipPolygonToClipShape(t,e){const i=this.clipPolygonToClipShapeReturnGrowableXYZArrays(t,e),s=[];for(const t of i)s.push(t.getPoint3dArray());return s}static clipPolygonToClipShapeReturnGrowableXYZArrays(t,e){const i=[],s=e.fetchClipPlanesRef();return s&&s.polygonClip(t,i),i}static pointSetSingleClipStatus(t,e,i){if(0===e.convexSets.length)return z.TrivialAccept;for(const s of e.convexSets){let e=!1,n=!1;for(const r of s.planes){let s=0,o=0;const a=r.distance-i,c=j.create(),l=$.create();for(let e=0;e<t.length;e++)t.getPoint3dAtUncheckedPointIndex(e,c),l.setFrom(c),l.dotProduct(r.inwardNormalRef)>a?s++:o++;if(n=0!==o||n,0===s){e=!0;break}}if(!n)return z.TrivialAccept;if(!e)return z.ClipRequired}return z.TrivialReject}static announceLoopsOfConvexClipPlaneSetIntersectRange(t,e,i,s=!0,n=!0,r=!1){const o=new nt;if(s)if(t instanceof kn)for(const s of t.planes){if(r&&s.invisible)continue;const n=s.intersectRange(e,!0),a=new nt;n&&(t.polygonClip(n,a,o,s),a.length>0&&i(a))}else if(r&&t.invisible);else{const s=t.intersectRange(e,!0);s&&i(s)}if(n){const s=e.corners();for(let e=0;e<6;e++){const n=ut.faceCornerIndices(e),r=new nt,a=Me.createIndexedPoints(s,n);t instanceof kn?(t.polygonClip(a.packedPoints,r,o),r.length>0&&i(r)):(t.clipConvexPolygonInPlace(a.packedPoints,o),a.packedPoints.length>0&&i(a.packedPoints))}}}static loopsOfConvexClipPlaneIntersectionWithRange(t,e,i=!0,s=!0,n=!1){const r=[];if(t instanceof vs)for(const o of t.convexSets)this.announceLoopsOfConvexClipPlaneSetIntersectRange(o,e,(t=>{t.length>0&&r.push(hi.createPolygon(t))}),i,s,n);else(t instanceof kn||t instanceof Wr)&&this.announceLoopsOfConvexClipPlaneSetIntersectRange(t,e,(t=>{t.length>0&&r.push(hi.createPolygon(t))}),i,s,n);return r}static rangeOfConvexClipPlaneSetIntersectionWithRange(t,e){const i=ut.createNull();return this.announceLoopsOfConvexClipPlaneSetIntersectRange(t,e,(t=>{t.length>0&&i.extendArray(t)}),!0,!0,!1),i}static rangeOfClipperIntersectionWithRange(t,e,i=!0){if(void 0===t)return e.clone();if(t instanceof kn)return this.rangeOfConvexClipPlaneSetIntersectionWithRange(t,e);if(t instanceof vs){const i=ut.createNull();for(const s of t.convexSets){const t=this.rangeOfConvexClipPlaneSetIntersectionWithRange(s,e);i.extendRange(t)}return i}if(t instanceof Cs)return i&&t.invisible?e.clone():this.rangeOfClipperIntersectionWithRange(t.fetchClipPlanesRef(),e);if(t instanceof bs){const s=e.clone();for(const n of t.clips)if(i&&n.invisible);else{const t=this.rangeOfClipperIntersectionWithRange(n,e,i);s.intersect(t,s)}return s}return e.clone()}static doesClipperIntersectRange(t,e,i=!0){if(void 0===t)return!0;if(t instanceof kn)return this.doesConvexClipPlaneSetIntersectRange(t,e);if(t instanceof vs){for(const i of t.convexSets)if(this.doesConvexClipPlaneSetIntersectRange(i,e))return!0;return!1}if(t instanceof Cs)return!(!i||!t.invisible)||this.doesClipperIntersectRange(t.fetchClipPlanesRef(),e);if(t instanceof bs){const s=e.clone();for(const n of t.clips)if(i&&n.invisible);else{const t=this.rangeOfClipperIntersectionWithRange(n,e,i);s.intersect(t,s)}return!s.isNull}return!1}static doesConvexClipPlaneSetIntersectRange(t,e,i=!0,s=!0,n=!1){const r=new nt;if(i)for(const i of t.planes){if(n&&i.invisible)continue;const s=i.intersectRange(e,!0);if(s){const e=new nt;if(t.polygonClip(s,e,r,i),e.length>0)return!0}}if(s){const i=e.corners();for(let e=0;e<6;e++){const s=ut.faceCornerIndices(e),n=new nt,o=Me.createIndexedPoints(i,s);if(t.polygonClip(o.packedPoints,n,r),n.length>0)return!0}}return!1}static createClipperFromTransformedRange3d(t,i,s){i||(i=pt.createIdentity());const n=ar.create();n.addTransformedRangeMesh(i,t);const r=n.claimPolyface(),o=this._workClipper=kn.createConvexPolyface(r,this._workClipper).clipper;if(o.planes.length>0)return o;if(s){e(r.data.point.length<=2);for(let t=0;t<2;++t){const e=r.data.point.getPoint3dAtCheckedPointIndex(t);e&&s.push(e)}}}static rangeIntersectPointOrSegment(t,e,i,s){const n=s?(t,e,n)=>{s.extendPoint(n.fractionToPoint(t),i),s.extendPoint(n.fractionToPoint(e),i)}:void 0;let r=!1;if(e.length>1){const i=Ce.createCapture(e[0],e[1]),s=kn.createRange3dPlanes(t);r=i.announceClipIntervals(s,n)}else e.length>0&&(r=t.containsPoint(e[0]),r&&s&&s.extendPoint(e[0],i));return r}static doLocalRangesIntersect(t,e,i,s,n){const r=this._workTransform=s.inverse(this._workTransform);if(!r)return!1;let o=i;n&&(o=this._workRange=i.clone(this._workRange),o.expandInPlace(n));const a=[],c=r.multiplyTransformTransform(e,r),l=this.createClipperFromTransformedRange3d(t,c,a);return l?this.doesClipperIntersectRange(l,o):this.rangeIntersectPointOrSegment(o,a,s)}static rangeOfIntersectionOfLocalRanges(t,e,i,s,n){const r=ut.createNull(n),o=this._workTransform=s.inverse(this._workTransform);if(!o)return r;const a=[],c=o.multiplyTransformTransform(e,o),l=this.createClipperFromTransformedRange3d(t,c,a);return l?this.announceLoopsOfConvexClipPlaneSetIntersectRange(l,i,(t=>{t.extendRange(r,s)})):this.rangeIntersectPointOrSegment(i,a,s,r),r}static isClipper(t){return!!(t&&t.isPointOnOrInside&&t.announceClippedSegmentIntervals&&t.announceClippedArcIntervals)}static restoreSingletonInPlaceOfMultipleShards(t,e,i,s){if(t&&t.length>e+1){for(;t.length>e;){const e=t.pop();s.dropToCache(e)}t.push(s.grabAndFill(i))}}static createXYOffsetClipFromLineString(t,e,i,s,n){return Array.isArray(t)?Es.createClipBetweenOffsets(new ce(t),e,i,s,n):Es.createClipBetweenOffsets(t,e,i,s,n)}static captureOrDrop(t,e,i,s){t.length>=e?i.push(t):s.dropToCache(t)}static clipSegmentToLLeftOfLineXY(t,e,i,s,n,r=1e-14){const o=e.x-t.x,a=e.y-t.y,c=-(o*(i.y-t.y)-a*(i.x-t.x)),l=-(o*(s.y-t.y)-a*(s.x-t.x));if(!(c<r&&l<r))if(c*l>0)c>0&&n.setNull();else{if(c*l<0){const t=-c/(l-c);return c<0?n.intersectRangeXXInPlace(0,t):n.intersectRangeXXInPlace(t,1)}c>0?n.intersectRangeXXInPlace(1,1):l>0&&n.intersectRangeXXInPlace(0,0)}}static clipSegmentToCCWTriangleXY(t,e,i,s,n,r,o=1e-14){r.isNull||(this.clipSegmentToLLeftOfLineXY(t,e,s,n,r,o),r.isNull||(this.clipSegmentToLLeftOfLineXY(e,i,s,n,r,o),r.isNull||this.clipSegmentToLLeftOfLineXY(i,t,s,n,r,o)))}static clipSegmentBelowPlaneXY(t,e,i,s,n=1e-14){const r=t.altitudeXY(e.x,e.y),o=t.altitudeXY(i.x,i.y);if(!(r<n&&o<n))if(r*o>0)r>0&&s.setNull();else{if(r*o<0){const t=-r/(o-r);return r<0?s.intersectRangeXXInPlace(0,t):s.intersectRangeXXInPlace(t,1)}r>0?s.intersectRangeXXInPlace(1,1):o>0&&s.intersectRangeXXInPlace(0,0)}}static clipSegmentBelowPlanesXY(t,e,i,s,n=1e-14){const r=t.length;for(let o=0;!s.isNull&&o<r;o++)this.clipSegmentBelowPlaneXY(t[o],e,i,s,n)}static announcePolylineClip(t,e,i){for(let s=0;s+1<e.length;s++)t.announceClippedSegmentIntervals(0,1,e[s],e[s+1],((t,n)=>{i(e[s].interpolate(t,e[s+1]),e[s].interpolate(n,e[s+1]))}))}static sumPolylineClipLength(t,e){let i=0;for(let s=0;s+1<e.length;s++){const n=e[s].distance(e[s+1]);t.announceClippedSegmentIntervals(0,1,e[s],e[s+1],((t,e)=>{i+=Math.abs(e-t)*n}))}return i}static doPolygonClipSequence(t,e,i,s,n,r,o,a,c){void 0===c&&(c=new ys);let l=[c.grabAndFill(t)],h=[];const d=[],u=[],f=i?i.length:0,g=s?s.length:0;let p;for(const t of e)if(t.appendPolygonClip){for(;void 0!==(p=l.pop());)t.appendPolygonClip(p,d,u,c),Xs(r,d,i,s,h,c),Xs(o,u,i,s,h,c),c.dropToCache(p);const e=l;l=h,h=e}Xs(a,l,i,s,n,c),s?.length===g&&Rs.restoreSingletonInPlaceOfMultipleShards(i,f,t,c),i?.length===f&&Rs.restoreSingletonInPlaceOfMultipleShards(s,g,t,c)}static doPolygonClipParitySequence(t,e,i,s,n){void 0===n&&(n=new ys);let r=[n.grabAndFill(t)],o=[],a=[],c=[];const l=[],h=[];let d;for(const t of e)if(t.appendPolygonClip){for(;void 0!==(d=o.pop());)t.appendPolygonClip(d,l,h,n),Xs(X.acceptOut,l,a,c,void 0,n),Xs(X.acceptIn,h,a,c,void 0,n),n.dropToCache(d);for(;void 0!==(d=r.pop());)t.appendPolygonClip(d,l,h,n),Xs(X.acceptIn,l,a,c,void 0,n),Xs(X.acceptOut,h,a,c,void 0,n),n.dropToCache(d);const e=o;o=a,a=e;const i=r;r=c,c=i}0===r.length?i?.push(n.grabAndFill(t)):0===r.length?s?.push(n.grabAndFill(t)):(Ds(o,i,n),Ds(r,s,n))}static createComplementaryClips(t){const e=t.planes,i=ft.createNull(),s=e.length,n=[];for(const t of e){const e=kn.createEmpty();e.addPlaneToConvexSet(t.cloneNegated()),n.push(e)}for(let r=0;r<s;r++)for(let o=r+1;o<s;o++){const s=Ln.planePlaneIntersectionRay(e[r],e[o]);if(s&&t.hasIntersectionWithRay(s,i)){const t=e[o].inwardNormalRef.minus(e[r].inwardNormalRef),i=Wr.createNormalAndPoint(t,s.origin);if(i){const t=i.cloneNegated();n[r].addPlaneToConvexSet(i),n[o].addPlaneToConvexSet(t)}}}return vs.createConvexSets(n)}}function Ds(t,e,i){if(void 0===e)i.dropAllToCache(t);else for(const i of t)e.push(i);t.length=0}function Xs(t,e,i,s,n,r){let o;if(t===X.acceptIn?o=i:t===X.acceptOut?o=s:t===X.passToNextStep&&(o=n),void 0===o)r.dropAllToCache(e);else for(const t of e)o.push(t);e.length=0}Rs._selectIntervals01TestPoint=j.create();class zs{constructor(t,e){this._graph=t,this._candidates=[],this._mask=e,this._graph.clearMask(e)}clear(){for(;void 0!==this.chooseAndRemoveAny(););}getLength(){let t=0;for(const e of this._candidates)e.isMaskSet(this._mask)&&t++;return t}getNumCandidates(){return this._candidates.length}get graph(){return this._graph}teardown(){this._graph.dropMask(this._mask),this._candidates.length=0}get mask(){return this._mask}popAndReturn(){const t=this._candidates.length;if(0===t)return;const e=this._candidates[t-1];return this._candidates.pop(),e}getAtIndex(t){if(t>=0&&t<this._candidates.length){const e=this._candidates[t];if(e.isMaskSet(this._mask))return e}}addToSet(t){return!t.isMaskSet(this._mask)&&(this._candidates.push(t),this.setMaskInScope(t),!0)}isCandidateInSet(t){return t.isMaskSet(this._mask)}removeFromSet(t){return!!t.isMaskSet(this._mask)&&(this.clearMaskInScope(t),!0)}chooseAndRemoveAny(){for(;;){const t=this.popAndReturn();if(!t)return;if(this.removeFromSet(t))return t}}[Symbol.iterator](){return new Os(this)}addAroundFace(t){let e=t;do{this.addToSet(e),e=e.faceSuccessor}while(e!==t)}addAroundVertex(t){let e=t;do{this.addToSet(e),e=e.vertexSuccessor}while(e!==t)}}class Ns extends zs{constructor(t,e){super(t,e)}static create(t){const e=t.grabMask();if(e!==b.NULL_MASK)return new Ns(t,e)}setMaskInScope(t){t.setMaskAroundEdge(this._mask)}clearMaskInScope(t){t.clearMaskAroundEdge(this._mask)}countHalfEdgesAroundCandidate(t){return t?2:0}}class Os{constructor(t){this._markSet=t,this._nextReadIndex=0}next(){const t=this._markSet.getNumCandidates();for(;this._nextReadIndex<t;){const t=this._markSet.getAtIndex(this._nextReadIndex++);if(void 0!==t)return{done:!1,value:t}}return{done:!0,value:void 0}}[Symbol.iterator](){return this}}class Ys{constructor(t,e,i,s,n,r){this._x=e,this._y=i,this._z=s,this._u=n,this._v=r,this._node=t}set(t,e,i,s,n,r){return this._x=e,this._y=i,this._z=s,this._u=n,this._v=r,this._node=t,this}setFrom(t){this._x=t.x,this._y=t.y,this._z=t.z,this._u=t.u,this._v=t.v,this._node=t.node}static createNodeAndRayOrigin(t,e,i){const s=t.x,n=t.y,r=t.z,o=s-e.origin.x,a=n-e.origin.y,c=Q.dotProductXYXY(o,a,e.direction.x,e.direction.y),l=Q.crossProductXYXY(e.direction.x,e.direction.y,o,a);return i?i.set(t,s,n,r,c,l):new Ys(t,s,n,r,c,l)}static create(t,e=0,i=0,s=0,n=0,r=0){return new Ys(t,e,i,s,n,r)}get node(){return this._node}get x(){return this._x}get y(){return this._y}get z(){return this._z}get u(){return this._u}get v(){return this._v}getXYZAsPoint3d(t){return j.create(this._x,this._y,this._z,t)}getUVAsPoint2d(t){return H.create(this._u,this._v,t)}classifyU(t,e){const i=this.u-t;return Math.abs(i)<=e?0:i>=0?1:-1}classifyV(t,e){const i=t-this._v;return Math.abs(i)<=e?0:i>=0?1:-1}}!function(t){t[t.None=0]="None",t[t.Vertex=1]="Vertex",t[t.Edge=2]="Edge",t[t.Face=3]="Face",t[t.ExteriorFace=4]="ExteriorFace"}(N||(N={}));class Bs{constructor(t,e,i,s,n,r,o,a,c){this._node=t,this.x=e,this.y=i,this.z=s,this._topo=n,this._edgeFraction=r,this._iTag=o,this._dTag=a,this._isExteriorTarget=c}setFrom(t){this._node=t._node,this.x=t.x,this.y=t.y,this.z=t.z,this._topo=t._topo,this._edgeFraction=t._edgeFraction,this._iTag=t._iTag,this._dTag=t._dTag}resetAsUnknown(){this._node=void 0,this._topo=N.None}static create(){return new Bs(void 0,0,0,0,N.None)}getITag(){return this._iTag}setITag(t){this._iTag=t}getDTag(){return this._dTag}setDTag(t){this._dTag=t}getTopo(){return this._topo}static createEdgeAtFraction(t,e){const i=t.faceSuccessor,s=Q.interpolate(t.x,e,i.x),n=Q.interpolate(t.y,e,i.y),r=Q.interpolate(t.z,e,i.z);return new Bs(t,s,n,r,N.Edge,e)}resetAsFace(t,e){return this._topo=N.Face,t&&(this._node=t),e&&(this.x=e.x,this.y=e.y,this.z=e.z),this._isExteriorTarget=void 0,this}resetAsUndefinedWithTag(t){return this._topo=N.None,this._dTag=0,this._iTag=0,this._dTag=t,this._node=void 0,this._isExteriorTarget=void 0,this}resetAtEdgeAndFraction(t,e){this._topo=N.Edge,this._node=t;const i=t.faceSuccessor;return this._edgeFraction=e,this.x=Q.interpolate(t.x,e,i.x),this.y=Q.interpolate(t.y,e,i.y),this.z=Q.interpolate(t.z,e,i.z),this._isExteriorTarget=void 0,this}static createVertex(t){return new Bs(t,t.x,t.y,t.z,N.Vertex)}resetAsVertex(t){return this._topo=N.Vertex,this._node=t,this._edgeFraction=0,this.setXYZFromNode(t),this._isExteriorTarget=void 0,this}setIsExteriorTarget(t){this._isExteriorTarget=t}setXYZFromNode(t){this.x=t.x,this.y=t.y,this.z=t.z}get edgeFraction(){return this._edgeFraction}get isExteriorTarget(){return void 0!==this._isExteriorTarget&&this._isExteriorTarget}get isFace(){return this._topo===N.Face}get isEdge(){return this._topo===N.Edge}get isVertex(){return this._topo===N.Vertex}get isUnclassified(){return this._topo===N.None}get node(){return this._node}clonePoint(t){return j.create(this.x,this.y,this.z,t)}isAtXY(t,e){return this._topo!==N.None&&Q.isSameCoordinate(this.x,t)&&Q.isSameCoordinate(this.y,e)}}!function(t){t[t.NoHits=0]="NoHits",t[t.TargetOnVertex=1]="TargetOnVertex",t[t.TargetOnEdge=2]="TargetOnEdge",t[t.Bracket=3]="Bracket",t[t.TargetBefore=4]="TargetBefore",t[t.TargetAfter=5]="TargetAfter"}(O||(O={}));class Vs{constructor(t){this._tol=t}static create(t=Q.smallMetricDistance){return new Vs(t)}panic(){return Bs.create()}reAimFromEdge(t,i,s){const n=t.node,r=Ys.createNodeAndRayOrigin(n,i),o=Ys.createNodeAndRayOrigin(n.edgeMate,i),a=-r.classifyV(0,this._tol),c=-o.classifyV(0,this._tol);let l;if(a*c<0)l=a>0?t.resetAsFace(r.node):t.resetAsFace(o.node);else if(0===a||0===c){const i=r.classifyU(s,this._tol),n=o.classifyU(s,this._tol);if(0===a&&0===i)l=t.resetAsVertex(r.node),l.setITag(1);else if(0===c&&0===n)l=t.resetAsVertex(o.node),l.setITag(1);else if(0===a&&0===c)if(i*n<0){const e=(s-r.u)/(o.u-r.u);l=t.resetAtEdgeAndFraction(r.node,e),l.setITag(1)}else i<0&&n<0?l=r.u>o.u?t.resetAsVertex(r.node):t.resetAsVertex(o.node):(t.resetAsUnknown(),l=this.panic());else 0===a?l=0===r.classifyU(0,this._tol)?t.resetAsVertex(r.node):t.resetAsFace(c>0?o.node:r.node):(e(0===c),l=0===o.classifyU(0,this._tol)?t.resetAsVertex(o.node):t.resetAsFace(a>0?r.node:o.node))}else t.resetAsUnknown(),l=this.panic();return l}reAimFromVertex(t,i,s){e(i.origin.isExactEqual(t));const n=t.node;let r=n;const o=e=>{if(Math.abs(e-s)<=this._tol)t.resetAsVertex(r.faceSuccessor).setITag(1);else if(e>s)t.resetAtEdgeAndFraction(r,s/e);else{if(!(e>this._tol))return!1;t.resetAsVertex(r.faceSuccessor)}return!0};do{const e=Ys.createNodeAndRayOrigin(r.faceSuccessor,i),s=Ys.createNodeAndRayOrigin(r.facePredecessor,i),n=e.u,a=s.u,c=e.v,l=s.v;if(Math.abs(c)<=this._tol){if(o(n))return t;if(Math.abs(n)<=this._tol&&c<=0&&l>this._tol&&(n>=0||n<0&&a>this._tol))return t.resetAsFace(r,r)}else if(c<-this._tol){if(l>this._tol)return t.resetAsFace(r,r);if(l>=-this._tol)if(Math.abs(a)<=this._tol){if(l>0&&(a>=0||n>this._tol&&a<0))return t.resetAsFace(r,r)}else if(n>this._tol&&a<0)return t.resetAsVertex(r.faceSuccessor)}r=r.vertexSuccessor}while(r!==n);return this.panic()}reAimAroundFace(t,i,s,n,r){e(!t.isMaskSet(b.EXTERIOR)),n.resetAsUndefinedWithTag(-Number.MAX_VALUE),r.resetAsUndefinedWithTag(Number.MAX_VALUE);const o=Ys.createNodeAndRayOrigin(t,i);let a,c=t;do{const t=c.faceSuccessor;a=Ys.createNodeAndRayOrigin(t,i,a);const e=o.u,l=a.u,h=o.v,d=a.v;if(Math.abs(d)<this._tol){const e=Bs.createVertex(t);if(e.setDTag(l),Math.abs(l-s)<this._tol)return r.setFrom(e),n.setFrom(e),O.TargetOnVertex;l>s&&l<r.getDTag()&&r.setFrom(e),l<s&&l>n.getDTag()&&n.setFrom(e)}else if(h*d<0){const t=-h/(d-h),i=Q.interpolate(e,t,l),a=Bs.createEdgeAtFraction(o.node,t);if(a.setDTag(i),Math.abs(i-s)<=this._tol)return r.setFrom(a),n.setFrom(a),O.TargetOnEdge;i>s&&i<r.getDTag()&&r.setFrom(a),i<s&&i>n.getDTag()&&n.setFrom(a)}o.setFrom(a),c=c.faceSuccessor}while(c!==t);return r.setITag(0),n.setITag(0),n.isUnclassified?r.isUnclassified?O.NoHits:O.TargetBefore:r.isUnclassified?O.TargetAfter:O.Bracket}setSearchRay(t,e,i){i.origin.setFromPoint3d(t),$.createStartEnd(i.origin,e,i.direction),i.direction.z=0;const s=i.direction.magnitudeXY();return!(s<this._tol||(i.a=s,i.direction.scaleInPlace(1/s),0))}}!function(t){t[t.Ignore=0]="Ignore",t[t.Replace=1]="Replace",t[t.ReplaceIfLarger=2]="ReplaceIfLarger",t[t.ReplaceIfSmaller=3]="ReplaceIfSmaller"}(Y||(Y={}));class Ls{constructor(t,e){this._graph=t,this._edgeSet=Ns.create(t),this._searcher=Bs.create(),this._tolerance=e}static create(t,e=Q.smallMetricDistance){return new Ls(t,e)}get graph(){return this._graph}retriangulateFromBaseVertex(t){const e=t.countEdgesAroundFace();if(e<4||t.isMaskSet(b.EXTERIOR))return;this._edgeSet.addAroundFace(t);const i=e-3;let s=t.faceSuccessor,n=t;for(let t=0;t<i;t++)s=s.faceSuccessor,n=this._graph.createEdgeHalfEdgeHalfEdge(n,0,s,0),s=n.faceSuccessor,this._edgeSet.addToSet(n)}reset(){this._searcher=Bs.create()}get currentPosition(){return this._searcher}searchForNearestEdgeOrVertex(t){const e=Bs.create();e.setDTag(Number.MAX_VALUE);const i=j.create();let s,n;for(const r of this._graph.allHalfEdges){const o=r.faceSuccessor;s=Mt.lineSegment3dXYClosestPointUnbounded(r,o,t),void 0!==s&&(s>1?(n=t.distanceXY(o),n<e.getDTag()&&(e.resetAsVertex(o),e.setDTag(n))):s<0?(n=t.distanceXY(r),n<e.getDTag()&&(e.resetAsVertex(r),e.setDTag(n))):(r.fractionToPoint3d(s,i),n=t.distanceXY(i),n<e.getDTag()&&e.resetAtEdgeAndFraction(r,s)))}return e}searchForNearestVertex(t){const e=Bs.create();let i;e.setDTag(Number.MAX_VALUE);for(const s of this._graph.allHalfEdges)i=t.distanceXY(s),i<e.getDTag()&&(e.resetAsVertex(s),e.setDTag(i));return e}resetSearch(t,e){this._searcher=e?this.searchForNearestEdgeOrVertex(t):this.searchForNearestVertex(t)}reclassifyFaceHit(t){if(void 0===this._searcher.node||!this._searcher.isFace||this._searcher.node.isMaskSet(b.EXTERIOR))return!1;const i=j.create(t.x,t.y),s=this._searcher.node.collectAroundFace((t=>{const e=j.create(t.x,t.y);return e.node=t,e})),n=Ur.closestPointOnBoundary(s,i,this._tolerance);if(e(n.code===_.OnPolygonEdgeInterior),n.a>this._tolerance)return!1;const r=s[n.closestEdgeIndex].node,o=n.closestEdgeParam<.5?r:r.faceSuccessor;return n.point.distanceSquaredXY(o)<=this._tolerance*this._tolerance?this._searcher.resetAsVertex(o):this._searcher.resetAtEdgeAndFraction(r,n.closestEdgeParam),!0}reclassifyEdgeHit(t){if(void 0===this._searcher.node||!this._searcher.isEdge||this._searcher.node.isMaskSet(b.BOUNDARY_EDGE))return!1;const e=j.create(t.x,t.y),i=[];for(let t=this._searcher.node.faceSuccessor;t!==this._searcher.node;t=t.faceSuccessor){const e=j.create(t.x,t.y);e.node=t,i.push(e)}for(let t=this._searcher.node.vertexPredecessor;t!==this._searcher.node.edgeMate;t=t.faceSuccessor){const e=j.create(t.x,t.y);e.node=t,i.push(e)}const s=Ur.closestPointOnBoundary(i,e,this._tolerance);if(s.a>this._tolerance)return!1;const n=i[s.closestEdgeIndex].node,r=s.closestEdgeParam<.5?n:n.faceSuccessor;return s.code===_.OnPolygonVertex||s.point.distanceSquaredXY(r)<=this._tolerance*this._tolerance?this._searcher.resetAsVertex(r):this._searcher.resetAtEdgeAndFraction(n,s.closestEdgeParam),!0}updateZAroundVertex(t,e,i){Y.Ignore!==i&&(Y.ReplaceIfLarger===i&&e.z<=t.z||Y.ReplaceIfSmaller===i&&e.z>=t.z||t.setXYZAroundVertex(t.x,t.y,e.z))}insertAndRetriangulate(t,e){if(this.moveToPoint(this._searcher,t),void 0===this._searcher.node)return!1;if(this.reclassifyFaceHit(t)||this.reclassifyEdgeHit(t),this._searcher.isFace){if(!this._searcher.node.isMaskSet(b.EXTERIOR)){const e=this._graph.createEdgeXYZHalfEdge(t.x,t.y,t.z,0,this._searcher.node,0);this.retriangulateFromBaseVertex(e),Us.flipTrianglesInEdgeSet(this._graph,this._edgeSet),this._searcher.resetAsVertex(e)}}else if(this._searcher.isEdge){const e=this._graph.splitEdgeAtFraction(this._searcher.node,this._searcher.edgeFraction),i=e.vertexPredecessor;this.updateZAroundVertex(e,t,Y.Replace),this.retriangulateFromBaseVertex(e),this.retriangulateFromBaseVertex(i),Us.flipTrianglesInEdgeSet(this._graph,this._edgeSet),this._searcher.resetAsVertex(e)}else this._searcher.isVertex&&this.updateZAroundVertex(this._searcher.node,t,e);return!0}moveToPoint(t,e,i){const s=Vs.create(this._tolerance);if(t.setITag(0),t.isUnclassified&&(function(t,e,i,s){for(const i of t.allHalfEdges)if(!i.isMaskSet(s))return e.resetAtEdgeAndFraction(i,.5),!0}(this.graph,t,0,b.NULL_MASK),t.isUnclassified))return!1;let n=0;const r=bt.createXAxis();for(;0===t.getITag()&&n<2&&(void 0===i||i(t));){if(!s.setSearchRay(t,e,r))return!1;if(t.isFace){const i=Bs.create(),o=Bs.create();switch(s.reAimAroundFace(t.node,r,r.a,i,o)){case O.NoHits:t.resetAsUnknown();break;case O.TargetOnVertex:case O.TargetOnEdge:t.setFrom(i),t.setITag(1);break;case O.Bracket:t.resetAsFace(i.node,e),t.setITag(1);break;case O.TargetBefore:t.resetAsFace(t.node,e),t.setITag(1);break;case O.TargetAfter:t.node===i.node&&t.isFace&&(i.isEdge||i.isVertex)?n++:n=0,t.setFrom(i)}}else if(t.isEdge){if(s.reAimFromEdge(t,r,r.a),t.isUnclassified)break}else if(t.isVertex&&(s.reAimFromVertex(t,r,r.a),t.isUnclassified))break}return!!t.isAtXY(e.x,e.y)||n>1&&(void 0!==t.node&&t.setIsExteriorTarget(!0),!1)}}class Us{static flipEdgeBetweenTriangles(t,e,i,s,n,r){us.pinch(t,n),us.pinch(i,s),us.pinch(r,i),us.pinch(n,e),n.x=e.x,n.y=e.y,n.z=e.z,n.i=e.i,i.i=r.i,i.x=r.x,i.y=r.y,i.z=r.z}static computeInCircleDeterminantIsStrongPositive(t){const e=t.faceSuccessor,i=e.faceSuccessor;if(i.faceSuccessor!==t)return!1;const s=t.edgeMate,n=s.faceSuccessor.faceSuccessor;if(n.faceSuccessor!==s)return!1;const r=e.x-t.x,o=e.y-t.y,a=i.x-t.x,c=i.y-t.y;if(Q.crossProductXYXY(r,o,a,c)<0)return!1;const l=n.x-t.x,h=n.y-t.y,d=l*l+h*h,u=a*a+c*c,f=r*r+o*o,g=Q.tripleProduct(l,h,d,a,c,u,r,o,f);return!(g<0)&&g>1e-12*(Math.abs(l*c*f)+Math.abs(h*u*r)+Math.abs(d*a*o)+Math.abs(l*u*o)+Math.abs(h*a*f)+Math.abs(d*c*r))}static flipTriangles(t){const e=Ns.create(t);for(const i of t.allHalfEdges)e.addToSet(i);const i=this.flipTrianglesInEdgeSet(t,e);return e.teardown(),i}static flipTrianglesInEdgeSet(t,e){const i=b.EXTERIOR|b.PRIMARY_EDGE|b.BOUNDARY_EDGE,s=10*t.allHalfEdges.length;let n,r=0,o=0;for(;void 0!==(n=e.chooseAndRemoveAny())&&(n.isMaskSet(i)||(Us.computeInCircleDeterminantIsStrongPositive(n)?(Us.flipEdgeBetweenTriangles(n.edgeMate.faceSuccessor,n.edgeMate.facePredecessor,n.edgeMate,n.faceSuccessor,n,n.facePredecessor),e.addAroundFace(n),e.addAroundFace(n.edgeMate),r++):o++,!(r+o>s))););return r}static createTriangulatedGraphFromPoints(t,e=Y.ReplaceIfLarger,i=Q.smallMetricDistance){if(t.length<3)return;const s=[],n=[];ue.computeConvexHullXY(t,s,n,!0);const r=new fs,o=Ls.create(r,i),a=Us.createFaceLoopFromCoordinates(r,s,!0,!0);if(void 0!==a){for(const t of n)o.insertAndRetriangulate(t,e);return a.countEdgesAroundFace()>3?Us.createTriangulatedGraphFromSingleLoop(s):r}}static createTriangulatedGraphFromLoops(t){if(t.length<1)return;const e=b.BOUNDARY_EDGE|b.PRIMARY_EDGE,i=new fs,s=[];let n=-1e4,r=-1;for(let o=0;o<t.length;o++){let a=Us.directCreateFaceLoopFromCoordinates(i,t[o]);if(a){a=a.faceSuccessor;const t=a.vertexSuccessor;a.setMaskAroundFace(e),t.setMaskAroundFace(e);const i=a.signedFaceArea(),c=Math.abs(i);s.push(i>=0?a:t),(0===o||c>n)&&(n=c,r=o)}}if(0===s.length)return;const o=s[r];s[r]=s[s.length-1],s.pop(),o.vertexSuccessor.setMaskAroundFace(b.EXTERIOR);for(let t=0;t<s.length;t++){const e=s[t];e.setMaskAroundFace(b.EXTERIOR),s[t]=this.getLeftmost(e.vertexSuccessor)}const a=Us.spliceLeftMostNodesOfHoles(i,o,s);return a&&Us.triangulateSingleFace(i,a)?i:void 0}static triangulateAllPositiveAreaFaces(t){const e=t.collectFaceLoops();let i=0;for(const s of e)s.countEdgesAroundFace()>3&&s.signedFaceArea()>0&&(Us.triangulateSingleFace(t,s)||i++);return 0===i}static triangulateAllInteriorFaces(t,e){const i=t.collectFaceLoops(),s=e?t.grabMask():b.NULL_MASK;let n,r,o=0,a=0;for(const s of i)if(s.countEdgesAroundFace()>3){if(s.getMask(b.EXTERIOR))continue;if(e&&(o=t.countNodes(),r=s.collectAroundFace(),n=this._workTransform=Fi.createRightHandedLocalToWorld(r,this._workTransform),n?.multiplyInversePoint3dArrayInPlace(r)),Us.triangulateSingleFace(t,s,e)||a++,n&&r){for(let e=o;e<t.countNodes();++e)r.push(t.allHalfEdges[e]);n.multiplyPoint3dArrayInPlace(r)}}return t.dropMask(s),0===a}static createTriangulatedGraphFromSingleLoop(t){const e=new fs,i=Us.createFaceLoopFromCoordinates(e,t,!0,!0);if(i&&!(e.countNodes()<6)&&Us.triangulateSingleFace(e,i))return Us.flipTriangles(e),e}static interiorEdgeSplit(t,e,i){let s=0,n=0,r=0;if(Array.isArray(i))s=i[0],n=i[1],r=i.length>2?i[3]:0;else{const t=i;t.hasOwnProperty("x")&&(s=t.x),t.hasOwnProperty("y")&&(n=t.y),t.hasOwnProperty("z")&&(r=t.z)}return e&&Us.isAlmostEqualXAndYXY(e,s,n)?e:t.splitEdge(e,s,n,r)}static getUnwrappedLength(t){let e,i,s,n,r=t.length;for(;r>1&&(t instanceof it?(e=t.getXAtUncheckedPointIndex(0),i=t.getYAtUncheckedPointIndex(0),s=t.getXAtUncheckedPointIndex(r-1),n=t.getYAtUncheckedPointIndex(r-1)):Q.isArrayOfNumberArray(t,r,2)?(e=t[0][0],i=t[0][1],s=t[r-1][0],n=t[r-1][1]):(e=t[0].x,i=t[0].y,s=t[r-1].x,n=t[r-1].y),Q.isAlmostEqualNumber(e,s)&&Q.isAlmostEqualNumber(i,n));)--r;return r}static directCreateFaceLoopFromCoordinates(t,e){const i=this.getUnwrappedLength(e);let s;if(e instanceof it){const n=j.create();for(let r=0;r<i;r++)e.getPoint3dAtCheckedPointIndex(r,n),s=Us.interiorEdgeSplit(t,s,n)}else for(let n=0;n<i;n++)s=Us.interiorEdgeSplit(t,s,e[n]);return s}static directCreateChainsFromCoordinates(t,e,i=0){const s=new Zs(t,i);return ht.streamXYZ(e,s),s.claimSeeds()}static maskAndOrientNewFaceLoop(t,e,i,s,n){if(e){const t=(e=e.faceSuccessor).signedFaceArea(),r=e.edgeMate;s!==b.NULL_MASK&&(e.setMaskAroundFace(s),r.setMaskAroundFace(s));let o=e;i&&t<0&&(o=r);const a=o.vertexSuccessor;return n!==b.NULL_MASK&&a.setMaskAroundFace(n),o}}static createFaceLoopFromCoordinates(t,e,i,s){const n=Us.directCreateFaceLoopFromCoordinates(t,e);return Us.maskAndOrientNewFaceLoop(t,n,i,b.BOUNDARY_EDGE|b.PRIMARY_EDGE,s?b.EXTERIOR:b.NULL_MASK)}static createFaceLoopFromCoordinatesAndMasks(t,e,i,s,n){const r=Us.directCreateFaceLoopFromCoordinates(t,e);return Us.maskAndOrientNewFaceLoop(t,r,i,s,n)}static joinNeighborsOfEar(t,e){const i=t.createEdgeXYZXYZ(e.facePredecessor.x,e.facePredecessor.y,e.facePredecessor.z,e.facePredecessor.i,e.faceSuccessor.x,e.faceSuccessor.y,e.faceSuccessor.z,e.faceSuccessor.i),s=i.edgeMate;us.pinch(e.faceSuccessor,s),us.pinch(e.facePredecessor,i),e.setMaskAroundFace(b.TRIANGULATED_FACE)}static isInteriorTriangle(t){if(!t.isMaskSet(b.TRIANGULATED_FACE)||t.isMaskSet(b.EXTERIOR))return!1;const e=t.faceSuccessor;if(!e.isMaskSet(b.TRIANGULATED_FACE)||e.isMaskSet(b.EXTERIOR))return!1;const i=e.faceSuccessor;return!(!i.isMaskSet(b.TRIANGULATED_FACE)||i.isMaskSet(b.EXTERIOR))&&i.faceSuccessor===t}static doPostCutFlips(t){let e=t,i=e.facePredecessor,s=i.edgeMate;for(;Us.isInteriorTriangle(i)&&Us.isInteriorTriangle(s)&&Us.computeInCircleDeterminantIsStrongPositive(i);){const t=s.faceSuccessor;Us.flipEdgeBetweenTriangles(t,t.faceSuccessor,t.facePredecessor,e,e.facePredecessor,e.faceSuccessor),e=i,i=e.facePredecessor,s=i.edgeMate}return e}static triangulateSingleFace(t,e,i=!1){if(!e)return Us.setDebugGraph(t),!1;let s,n,r,o=e.countEdgesAroundFace(),a=0;for(e.clearMaskAroundFace(b.TRIANGULATED_FACE);!e.isMaskSet(b.TRIANGULATED_FACE);){if(r=e?.facePredecessor,s=e.faceSuccessor,n=s.faceSuccessor,s===e||n===e)return!0;if(n.faceSuccessor===e)return e.setMaskAroundFace(b.TRIANGULATED_FACE),!0;if(!Q.isAlmostEqualXAndY(n,r)||n.findAroundVertex(r)){if(++a>o)return Us.setDebugGraph(t),!1;Us.isEar(e)?(o--,a=0,e.faceSuccessor.faceSuccessor!==e.facePredecessor?(Us.joinNeighborsOfEar(t,e),i||(e=Us.doPostCutFlips(e)),e=e.faceSuccessor.edgeMate.faceSuccessor):(e.setMaskAroundFace(b.TRIANGULATED_FACE),e=s.faceSuccessor)):e=s}else{const t=n.faceSuccessor;if(this.nodeInTriangle(r,e,s,t)){const t=n.vertexPredecessor;us.pinch(r.vertexSuccessor,t)}else us.pinch(r,n),e.setMaskAroundFace(b.TRIANGULATED_FACE);e=n}}return!0}static claimDebugGraph(){const t=Us.sDebugGraph;return Us.sDebugGraph=void 0,Us.sEnableDebugGraphCapture=!1,t}static setDebugGraph(t){Us.sEnableDebugGraphCapture&&(Us.sDebugGraph=t)}static clearAndEnableDebugGraphCapture(t){Us.sEnableDebugGraphCapture=t,Us.sDebugGraph=void 0}static findAroundOrAtVertex(t,e){return!!t.findAroundVertex(e)||Q.isAlmostEqualXAndY(t,e)}static isEar(t){const e=t.facePredecessor,i=t,s=t.faceSuccessor,n=Us.signedTolerancedCCWTriangleArea(e,i,s);if(n<=0)return!1;const r=this._planes;if(!_t.createOriginAndTargetXY(e,i,r[0])||!_t.createOriginAndTargetXY(i,s,r[1])||!_t.createOriginAndTargetXY(s,e,r[2]))return!1;const o=this._earRange,a=this._edgeRange,c=this._edgeInterval;gt.createXYXYXY(e.x,e.y,i.x,i.y,s.x,s.y,o),o.expandInPlace(Q.smallMetricDistance);let l=s;const h=1e-10*n;for(;l!==e;){const t=l.faceSuccessor;if(gt.createXYXY(l.x,l.y,t.x,t.y,a),o.intersectsRange(a)&&(ft.createXX(-1e-8,1.00000001,c),Rs.clipSegmentBelowPlanesXY(r,l,t,c,h),!c.isNull))if(c.low>.99999999){if(!this.findAroundOrAtVertex(e,t)&&!this.findAroundOrAtVertex(i,t)&&!this.findAroundOrAtVertex(s,t))return!1}else if(c.high<1e-8){if(!this.findAroundOrAtVertex(e,l)&&!this.findAroundOrAtVertex(i,l)&&!this.findAroundOrAtVertex(s,l))return!1}else if(this.findAroundOrAtVertex(i,t)&&this.findAroundOrAtVertex(s,l));else if(!this.findAroundOrAtVertex(e,t)||!this.findAroundOrAtVertex(i,l))return!1;l=l.faceSuccessor}return!0}static spliceLeftMostNodesOfHoles(t,e,i){i.sort(((t,e)=>Us.compareX(t,e)));let s=0;for(const n of i)Us.eliminateHole(t,n,e)||s++;return 0===s?e:void 0}static compareX(t,e){return t.x-e.x}static eliminateHole(t,e,i){const s=Us.findHoleBridge(e,i);return!!s&&void 0!==Us.splitFace(t,s,e)}static findHoleBridge(t,e){let i=e;if(!i)return;const s=t.x,n=t.y;let r,o=-1/0;do{if(n<=i.y&&n>=i.faceSuccessor.y&&i.faceSuccessor.y!==i.y){const t=i.x+(n-i.y)*(i.faceSuccessor.x-i.x)/(i.faceSuccessor.y-i.y);if(t<=s&&t>o){if(o=t,t===s){if(n===i.y)return i;if(n===i.faceSuccessor.y)return i.faceSuccessor}r=i.x<i.faceSuccessor.x?i:i.faceSuccessor}}i=i.faceSuccessor}while(i!==e);if(!r)return;if(s===o)return r.facePredecessor;const a=r,c=r.x,l=r.y;let h,d=1/0;for(i=r.faceSuccessor;i!==a;)s>=i.x&&i.x>=c&&s!==i.x&&Us.pointInTriangle(n<l?s:o,n,c,l,n<l?o:s,n,i.x,i.y)&&(h=Math.abs(n-i.y)/(s-i.x),(h<d||h===d&&i.x>r.x)&&Us.locallyInside(i,t)&&(r=i,d=h)),i=i.faceSuccessor;return r}static getLeftmost(t){let e=t,i=t;do{e.x<i.x&&(i=e),e=e.faceSuccessor}while(e!==t);return i}static pointInTriangle(t,e,i,s,n,r,o,a){return(n-o)*(e-a)-(t-o)*(r-a)>=0&&(t-o)*(s-a)-(i-o)*(e-a)>=0&&(i-o)*(r-a)-(n-o)*(s-a)>=0}static nodeInTriangle(t,e,i,s){return Us.signedTolerancedCCWTriangleArea(t,e,s)>0&&Us.signedTolerancedCCWTriangleArea(e,i,s)>0&&Us.signedTolerancedCCWTriangleArea(i,t,s)>0}static signedCWTriangleArea(t,e,i){return.5*((e.y-t.y)*(i.x-e.x)-(e.x-t.x)*(i.y-e.y))}static signedTolerancedCCWTriangleArea(t,e,i,s=1e-12){const n=e.x-t.x,r=e.y-t.y,o=i.x-t.x,a=i.y-t.y,c=.5*(n*a-r*o);return c<0?c:c<s*(n*n+r*r+(o*o+a*a))?0:c}static isAlmostEqualXAndYXY(t,e,i){return Q.isAlmostEqualNumber(t.x,e)&&Q.isAlmostEqualNumber(t.y,i)}static locallyInside(t,e){return Us.signedCWTriangleArea(t.facePredecessor,t,t.faceSuccessor)<0?Us.signedCWTriangleArea(t,e,t.faceSuccessor)>=0&&Us.signedCWTriangleArea(t,t.facePredecessor,e)>=0:Us.signedCWTriangleArea(t,e,t.facePredecessor)<0||Us.signedCWTriangleArea(t,t.faceSuccessor,e)<0}static splitFace(t,e,i){if(us.isNodeVisibleInSector(e,i)&&us.isNodeVisibleInSector(i,e)){const s=t.createEdgeXYZXYZ(e.x,e.y,e.z,e.i,i.x,i.y,i.z,i.i),n=s.faceSuccessor;return us.pinch(e,s),us.pinch(i,n),s}}static triangulateSingleMonotoneFace(t,e){let i,s=e.facePredecessor,n=e.faceSuccessor;for(;s!==n&&n!==e&&n.faceSuccessor!==s;){if(us.crossProductXYAlongChain(s,e,n)<=0)return!1;if(!e.belowYX(s))return!1;if(!e.belowYX(n))return!1;if(s.belowYX(n)){let r=s,o=e,a=n;for(;r!==a&&r.belowYX(n);){for(;a!==n&&a!==r&&a!==o&&us.crossProductXYAlongChain(r,o,a)>0;){if(i=Us.splitFace(t,r,a),void 0===i)return!1;r=i,o=r.faceSuccessor,a=o.faceSuccessor}a=o,o=r,r=r.facePredecessor}for(s=o,a=n,o=a.facePredecessor,r=o.facePredecessor;a.faceSuccessor!==r&&r!==s;){if(i=Us.splitFace(t,r,a),void 0===i)return!1;o=i,r=o.facePredecessor}if(a.faceSuccessor!==r){if(i=Us.splitFace(t,r,a),void 0===i)return!1;r=i}n=(e=r).faceSuccessor,s=e.facePredecessor}else{let r=s,o=e,a=n;for(;r!==a&&a.belowYX(s);){for(;r!==s&&a!==r&&a!==o&&us.crossProductXYAlongChain(r,o,a)>0;){if(i=Us.splitFace(t,r,a),void 0===i)return!1;r=i.facePredecessor,o=i}r=o,o=a,a=a.faceSuccessor}for(n=o,r=s,o=r.faceSuccessor,a=o.faceSuccessor;a.faceSuccessor!==r&&a!==n;){if(i=Us.splitFace(t,r,a),void 0===i)return!1;r=i,a=a.faceSuccessor}if(a.faceSuccessor!==r&&void 0===Us.splitFace(t,r,a))return!1;n=(e=n).faceSuccessor,s=e.facePredecessor}}return!0}}Us.sEnableDebugGraphCapture=!1,Us._edgeInterval=ft.createNull(),Us._earRange=gt.createNull(),Us._edgeRange=gt.createNull(),Us._planes=[_t.createXYPlane(),_t.createXYPlane(),_t.createXYPlane()];class Zs extends ot{constructor(t,e){super(),this._graph=t,this._id=e}startChain(t,e){super.startChain(t,e),this._baseNode=void 0,this._nodeB=void 0}handleXYZXYZ(t,e,i,s,n,r){this._nodeC=this._graph.createEdgeXYZXYZ(t,e,i,this._id,s,n,r,this._id),void 0===this._baseNode?(this._baseNode=this._nodeC,this._nodeB=this._baseNode.faceSuccessor):(us.pinch(this._nodeB,this._nodeC),this._nodeB=this._nodeC.faceSuccessor)}endChain(t,e){super.endChain(t,e),void 0!==this._baseNode&&(void 0===this._seeds&&(this._seeds=[]),this._seeds.push(this._baseNode)),this._baseNode=void 0,this._nodeB=void 0,this._nodeC=void 0}claimSeeds(){return void 0===this._seeds?[]:this._seeds}}class qs{constructor(){this.numUpEdge=0,this.numIntersectionTest=0,this.numSplit=0,this.numPopOut=0,this.numA0B0=0,this.numA0B1=0}}class Ws{constructor(t,e,i,s){this.index=t,this.radiusOfCurvature=e,this.node=i,this.radians=s}}class Gs{static compareNodesYXUp(t,e){return t.y<e.y?-1:t.y>e.y?1:t.x<e.x?-1:t.x>e.x?1:0}static isDownPeak(t){const e=t.facePredecessor,i=t.faceSuccessor;return this.compareNodesYXUp(t,e)<0&&this.compareNodesYXUp(t,i)<0&&this.crossProductToTargets(t,e,i)>0}static crossProductToTargets(t,e,i){return Q.crossProductXYXY(e.x-t.x,e.y-t.y,i.x-t.x,i.y-t.y)}static graphRange(t){const e=ut.create();for(const i of t.allHalfEdges)e.extendXYZ(i.x,i.y,i.z);return e}static segmentArrayToGraphEdges(t,e,i){const s=[];let n=0;for(const r of t){const t=e.createEdgeXYZXYZ(r.point0Ref.x,r.point0Ref.y,r.point0Ref.z,n,r.point1Ref.x,r.point1Ref.y,r.point1Ref.z,n+1),o=t.edgeMate;n+=2,t.setMaskAroundFace(i),s.push(t),s.push(o)}return s}static isolateAllEdges(t){for(const e of t.allHalfEdges){const t=e.vertexPredecessor;us.pinch(e,t)}}static isSectorConvexAfterEdgeRemoval(t,e,i,s=0){let n=t;do{if(n.isMaskSet(i)||n.edgeMate.isMaskSet(i))break;n=n.vertexSuccessor}while(n!==t&&n.isMaskSet(e));if(n===t)return!1;let r=t;do{if(r.isMaskSet(i)||r.edgeMate.isMaskSet(i))break;r=r.vertexPredecessor}while(r!==t&&r.isMaskSet(e));return r!==t&&us.isSectorConvex(n.edgeMate,t,r.faceSuccessor,s)}static markRemovableEdgesToExpandConvexFaces(t,e,i=b.BOUNDARY_EDGE){if(b.NULL_MASK===e)return 0;const s=t.grabMask(!0);let n=0;for(const r of t.allHalfEdges){if(!r.isMaskSet(s)&&!r.isMaskSet(i)&&!r.edgeMate.isMaskSet(i)){const t=Q.smallMetricDistanceSquared*(r.signedFaceArea()+r.edgeMate.signedFaceArea());this.isSectorConvexAfterEdgeRemoval(r,e,i,t)&&this.isSectorConvexAfterEdgeRemoval(r.edgeMate,e,i,t)&&(r.setMaskAroundEdge(e),++n)}r.setMaskAroundEdge(s)}return t.dropMask(s),n}static collectRemovableEdgesToExpandConvexFaces(t,e=b.BOUNDARY_EDGE){const i=[],s=t.grabMask(!0);if(0<this.markRemovableEdgesToExpandConvexFaces(t,s,e)){const e=t.grabMask(!0);for(const n of t.allHalfEdges)n.isMaskSet(s)&&!n.isMaskSet(e)&&(n.setMaskAroundEdge(e),i.push(n));t.dropMask(e)}return t.dropMask(s),i}static expandConvexFaces(t,i=b.BOUNDARY_EDGE){const s=t.grabMask(!0),n=this.markRemovableEdgesToExpandConvexFaces(t,s,i);return n>0&&e(.5*t.yankAndDeleteEdges((t=>t.getMask(s)))===n),t.dropMask(s),n}static isEveryFaceConvex(t,e=b.EXTERIOR){const i=t.collectFaceLoops();for(const t of i)if(!t.isMaskedAroundFace(e)&&!t.isFaceConvex())return!1;return!0}}class Hs{static getCommonThetaEndIndex(t,e,i,s){let n=i+1;const r=t.getExtraData(e[i],0);for(;n<s;){const i=t.getExtraData(e[n],0);if(!W.isAlmostEqualRadiansAllowPeriodShift(r,i))return n;n++}return n}static set announceVertexNeighborhoodFunction(t){this._announceVertexNeighborhoodFunction=t}static doAnnounceVertexNeighborhood(t,e,i,s,n){if(this._announceVertexNeighborhoodFunction){const r=[];for(let o=s;o<n;o++){const s=t.getExtraData(e[o],1),n=t.getExtraData(e[o],0),a=i[s],c=this.curvatureSortKey(a);r.push(new Ws(e[o],c,a,n))}this._announceVertexNeighborhoodFunction(r)}}static secondarySortAroundVertex(t,e,i,s,n){const r=[];for(let o=s;o<n;){const s=this.getCommonThetaEndIndex(t,e,o,n);if(o+1<s){r.length=0;for(let n=o;n<s;n++){const s=i[t.getExtraData(e[n],1)],o=this.curvatureSortKey(s);r.push(new Ws(e[n],o,s))}r.sort(((t,e)=>t.radiusOfCurvature-e.radiusOfCurvature));for(let t=0;t<r.length;t++)e[o+t]=r[t].index}o=s}}static curvatureSortKey(t){const e=t.edgeTag;if(void 0!==e){const i=e.fraction,s=e.curve;if(s){let e=s.fractionToSignedXYRadiusOfCurvature(i);return void 0!==t.sortData&&t.sortData<0&&(e=-e),e}}return 0}static isNullFace(t){return t.isMaskSet(b.NULL_FACE)&&t.faceSuccessor.isMaskSet(b.NULL_FACE)&&t===t.faceSuccessor.faceSuccessor}static clusterAndMergeXYTheta(t,e){const i=t.allHalfEdges,s=i.length;t.clearMask(b.NULL_FACE);const n=new Ni(2,2,s);for(let t=0;t<s;t++){const e=i[t],s=e.x,r=e.y;us.pinch(e,e.vertexSuccessor),n.addDirect(s,r,0,t)}const r=Q.smallMetricDistance,o=n.clusterIndicesLexical(r);let a=0;const c=o.length;for(let t=0;t<c;t++)if(o[t]===Ni.clusterTerminator){if(t>a){const e=i[n.getExtraData(o[a],1)];for(let s=a+1;s<t;s++){const t=i[n.getExtraData(o[s],1)];t.x=e.x,t.y=e.y}}a=t+1}for(const t of o)if(t!==Ni.clusterTerminator){const s=i[t],r=s.faceSuccessor;let o=e;if(o){const t=s.edgeTag;(void 0===t||void 0===t.curve||t.curve instanceof Ce)&&(o=void 0)}let a=o?o(s):Math.atan2(r.y-s.y,r.x-s.x);W.isAlmostEqualRadiansAllowPeriodShift(a,-Math.PI)&&(a=Math.PI),n.setExtraData(t,0,a)}n.sortSubsetsBySingleKey(o,2);const l=[];let h,d;a=0;for(let t=0;t<c;t++)if(o[t]===Ni.clusterTerminator){if(t>a){t>a+1&&this.secondarySortAroundVertex(n,o,i,a,t),this.doAnnounceVertexNeighborhood(n,o,i,a,t);const e=n.getExtraData(o[a],1);h=n.getExtraData(o[a],0);let s=i[e];for(let e=a+1;e<t;e++){const t=n.getExtraData(o[e],1);d=n.getExtraData(o[e],0);const a=i[t];if(s.isMaskSet(b.NULL_FACE)){const t=l.findIndex((t=>s===t));t>=0&&(l[t]=l[l.length-1],l.pop()),s=a,h=d}else if(a.isMaskSet(b.NULL_FACE)){const t=l.findIndex((t=>a===t));t>=0&&(l[t]=l[l.length-1],l.pop())}else{if(us.pinch(s,a),W.isAlmostEqualRadiansAllowPeriodShift(h,d)){const t=s.faceSuccessor,e=a.edgeMate;if(t.isEqualXY(e)){const i=this.curvatureSortKey(s),n=this.curvatureSortKey(a);Q.isSameCoordinate(i,n,r)&&(us.pinch(t,e),s.setMask(b.NULL_FACE),e.setMask(b.NULL_FACE),l.push(e))}}s=a,h=d}}}a=t+1}}static buildVerticalSweepPriorityQueue(t){const e=new ps;for(const i of t.allHalfEdges)Gs.compareNodesYXUp(i,i.faceSuccessor)<0&&e.priorityQueue.push(i);return e}static snapFractionToNode(t,e,i,s){return Q.isSameCoordinate(t.x,i.x)&&Q.isSameCoordinate(t.y,i.y)?s:e}static computeIntersectionFractionsOnEdges(t,e,i,s,n){const r=t.faceSuccessor,o=t.x,a=t.y,c=r.x-o,l=r.y-a,h=e.faceSuccessor,d=e.x,u=e.y,f=h.x-d,g=h.y-u;return!!Mt.lineSegmentXYUVTransverseIntersectionUnbounded(o,a,c,l,d,u,f,g,i)&&(s.x=o+i.x*c,s.y=a+i.x*l,n.x=d+i.y*f,n.y=u+i.y*g,i.x=this.snapFractionToNode(s,i.x,t,0),i.x=this.snapFractionToNode(s,i.x,r,1),i.y=this.snapFractionToNode(n,i.y,e,0),i.y=this.snapFractionToNode(n,i.y,h,1),Q.isIn01(i.x)&&Q.isIn01(i.y))}static splitIntersectingEdges(t){const e=new qs,i=this.buildVerticalSweepPriorityQueue(t);let s,n;const r=.99999999;let o;const a=J.create(),c=H.create(),l=H.create();let h;const d=Q.smallMetricDistance;for(;void 0!==(s=i.priorityQueue.pop());){e.numUpEdge++;const u=i.activeEdges.length;for(i.removeArrayMembersWithY1Below(s.y-d),e.numPopOut+=u-i.activeEdges.length,o=0;o<i.activeEdges.length;o++)if(h=i.activeEdges[o],n=h.faceSuccessor,Q.isSameCoordinateXY(s.x,s.y,h.x,h.y))e.numA0B0++;else if(Q.isSameCoordinateXY(n.x,n.y,s.x,s.y))e.numA0B1++;else if(e.numIntersectionTest++,this.computeIntersectionFractionsOnEdges(s,h,a,c,l)){if(a.x>1e-8&&a.x<r){const n=t.splitEdgeAtFraction(s,a.x);i.priorityQueue.push(n),e.numSplit++}if(a.y>1e-8&&a.y<r){const s=t.splitEdgeAtFraction(h,a.y);i.priorityQueue.push(s),e.numSplit++}}i.activeEdges.push(s)}return e}static formGraphFromSegments(t){const e=new fs;return Gs.segmentArrayToGraphEdges(t,e,b.BOUNDARY_EDGE),this.splitIntersectingEdges(e),this.clusterAndMergeXYTheta(e),e}static formGraphFromChains(t,e=!0,i=b.PRIMARY_EDGE){if(t.length<1)return;const s=new fs,n=Us.directCreateChainsFromCoordinates(s,t);for(const t of n)t.setMaskAroundFace(i);return this.splitIntersectingEdges(s),this.clusterAndMergeXYTheta(s),e&&new ms(s).regularizeGraph(!0,!0),s}}class Js{static createPrimarySortVector(t){return void 0===t&&(t=this._defaultPrimarySortDirection.clone()),t.normalizeWithDefault(Js._defaultPrimarySortDirection.x,Js._defaultPrimarySortDirection.y,Js._defaultPrimarySortDirection.z)}constructor(t,e){this.tolerance=t,this.primarySortDirection=e}static createFromUnValidated(t){const e=new Js(Q.smallMetricDistance,Js.createPrimarySortVector());return void 0!==t&&(void 0!==t.tolerance&&(e.tolerance=t.tolerance),void 0!==t.primarySortDirection&&(e.primarySortDirection=Js.createPrimarySortVector())),e}clone(){return new Js(this.tolerance,this.primarySortDirection)}}Js._defaultPrimarySortDirection=$.create(.294234298,.72391399,.45234328798);class Qs{constructor(t){this._graph=new fs,this._options=t}set plane(t){this._plane=t}get plane(){return this._plane}set convexClipper(t){this._convexClipper=t}get convexClipper(){return this._convexClipper}static create(t){const e=Js.createFromUnValidated(t);return new Qs(e)}addSegment(t,e){this._graph.createEdgeXYZXYZ(t.x,t.y,t.z,0,e.x,e.y,e.z,0)}addLineSegment3dArray(t){for(const e of t)this.addSegment(e.point0Ref,e.point1Ref)}addSegmentsOnPlane(t,e=!1){if(!this._plane)return;const i=this._plane;let s,n=e?t.length-1:0,r=t.evaluateUncheckedIndexPlaneAltitude(n,i),o=e?0:1;for(;o<t.length;n=o++,r=s)s=t.evaluateUncheckedIndexPlaneAltitude(o,i),Q.isSmallMetricDistance(r)&&Q.isSmallMetricDistance(s)&&this._graph.createEdgeXYZXYZ(t.getXAtUncheckedPointIndex(n),t.getYAtUncheckedPointIndex(n),t.getZAtUncheckedPointIndex(n),0,t.getXAtUncheckedPointIndex(o),t.getYAtUncheckedPointIndex(o),t.getZAtUncheckedPointIndex(o),0)}primarySortKey(t){return this._options.primarySortDirection.dotProductXYZ(t.x,t.y,t.z)}static nodeCompareSortData(t,e){return t.sortData-e.sortData}static isIsolatedEnd(t){return t.vertexSuccessor===t}static isChainInteriorVertex(t){const e=t.vertexSuccessor;return e!==t&&e.vertexSuccessor===t}clusterAndMergeVerticesXYZ(){Gs.isolateAllEdges(this._graph);for(const t of this._graph.allHalfEdges)t.sortData=this.primarySortKey(t);const t=this._graph.allHalfEdges.slice();t.sort(((t,e)=>Qs.nodeCompareSortData(t,e)));const e=this._options.tolerance,i=t.length;for(let s=0;s<i;s++){const n=t[s],r=n.sortData+e;if(Qs.isIsolatedEnd(n))for(let o=s+1;o<i;o++){const i=t[o];if(Qs.isIsolatedEnd(i)){if(i.sortData>r)break;n.distanceXYZ(i)<=e&&(us.pinch(n,i),i.setXYZFrom(n))}}}}collectMaximalLineString3dFromStartNode(t,e,i){if(!e.isMaskSet(i)){const s=Me.create();for(s.addPointXYZ(e.x,e.y,e.z);e.setMask(i),e.edgeMate.setMask(i),e=e.faceSuccessor,s.addPointXYZ(e.x,e.y,e.z),!e.isMaskSet(i)&&Qs.isChainInteriorVertex(e););t.push(s)}}collectMaximalGrowableXYXArrayFromStartNode(t,e,i){if(!e.isMaskSet(i)){const s=new nt;for(s.pushXYZ(e.x,e.y,e.z);e.setMask(i),e.edgeMate.setMask(i),e=e.faceSuccessor,s.pushXYZ(e.x,e.y,e.z),!e.isMaskSet(i)&&Qs.isChainInteriorVertex(e););s.length>0&&t.push(s)}}exciseAndMarkSlingEdges(t){let e=0;for(const i of this._graph.allHalfEdges)if(i.distanceXYZ(i.edgeMate)<this._options.tolerance&&!i.isMaskSet(t)){const s=i.edgeMate;us.pinch(i,i.vertexPredecessor),us.pinch(s,s.vertexPredecessor),i.setMask(t),s.setMask(t),e++}return e}collectMaximalChains(){const t=[],e=b.VISITED;this.exciseAndMarkSlingEdges(e),this._graph.clearMask(e);for(const i of this._graph.allHalfEdges)Qs.isChainInteriorVertex(i)||this.collectMaximalLineString3dFromStartNode(t,i,e);for(const i of this._graph.allHalfEdges)this.collectMaximalLineString3dFromStartNode(t,i,e);return t}collectMaximalGrowableXYZArrays(){const t=[],e=b.VISITED;this.exciseAndMarkSlingEdges(e),this._graph.clearMask(e);for(const i of this._graph.allHalfEdges)Qs.isChainInteriorVertex(i)||this.collectMaximalGrowableXYXArrayFromStartNode(t,i,e);for(const i of this._graph.allHalfEdges)this.collectMaximalGrowableXYXArrayFromStartNode(t,i,e);return t}}class Ks{constructor(){this._unmatchedEdges=new Map,this._graph=new fs,this._halfEdgesAroundCurrentLoop=[]}get graph(){return this._graph}indexPairToString(t,e){return`${t.toString()},${e.toString()}`}insertLoop(t,e){if(t.length>2){let i=t[t.length-1];this._halfEdgesAroundCurrentLoop.length=0;for(const s of t){const t=this.indexPairToString(i,s),n=this._unmatchedEdges.get(t);if(void 0===n){const t=this.indexPairToString(s,i),n=this._graph.createEdgeIdId(i,s);void 0!==e&&e(n),this._unmatchedEdges.set(t,n.edgeMate),this._halfEdgesAroundCurrentLoop.push(n),n.edgeMate.setMask(b.EXTERIOR)}else this._halfEdgesAroundCurrentLoop.push(n),n.clearMask(b.EXTERIOR);i=s}let s=this._halfEdgesAroundCurrentLoop[this._halfEdgesAroundCurrentLoop.length-1];for(const t of this._halfEdgesAroundCurrentLoop){const e=s.faceSuccessor;us.pinch(t,e),s=t}return this._halfEdgesAroundCurrentLoop[0]}}}class js{constructor(t){this.positiveSum=this.negativeSum=0,this.numPositive=this.numNegative=this.numZero=0,this.largestPositiveValue=this.largestNegativeValue=0,t&&(this.negativeItemArray=[],this.positiveItemArray=[],this.zeroItemArray=[])}announceItem(t,e){e<0?(this.numNegative++,this.negativeSum+=e,this.negativeItemArray&&this.negativeItemArray.push(t),e<this.largestNegativeValue&&(this.largestNegativeValue=e,this.largestNegativeItem=t)):e>0?(this.numPositive++,this.positiveSum+=e,this.positiveItemArray&&this.positiveItemArray.push(t),e>this.largestPositiveValue&&(this.largestPositiveValue=e,this.largestPositiveItem=t)):(this.numZero++,this.zeroItemArray&&this.zeroItemArray.push(t))}}class $s{constructor(t,e=!0){this._targetMask=t,this._targetValue=e}testEdge(t){return t.isMaskSet(this._targetMask)===this._targetValue}}class tn{static signedFaceArea(t){return t.signedFaceArea()}static collectFaceAreaSummary(t,e=!1,i=t=>tn.signedFaceArea(t)){const s=new js(e);let n;n=t instanceof fs?t.collectFaceLoops():t;for(const t of n){const e=i(t);s.announceItem(t,e)}return s}static findMinimumAreaFace(t,e){return tn.collectFaceAreaSummary(t,!1,e).largestNegativeItem}static isTriangulatedCCW(t,e=!0,i=0){let s;s=t instanceof fs?t.collectFaceLoops():t;let n=0,r=0;for(const t of s){const s=t.countEdgesAroundFace();if(s>=3)if(t.signedFaceArea()>0){if(s>3&&(r++,r>i))return!1}else if(n++,n>1&&!e)return!1}return!0}static pushAndMaskAllNodesInFace(t,e,i,s){s.push(t),t.collectAroundFace((t=>{t.setMask(e),i.push(t)}))}static parityFloodFromSeed(t,e,i,s){const n=[];if(t.isMaskSet(e))return n;const r=s|e,o=[];for(tn.pushAndMaskAllNodesInFace(t,r,o,n);o.length>0;){const t=o.pop(),a=t.edgeMate;if(a&&!a.isMaskSet(e)){let c=t.isMaskSet(s);i&&!i.testEdge(t)||(c=!c),tn.pushAndMaskAllNodesInFace(a,c?r:e,o,n)}}return n}static correctParityInSingleComponent(t,e){const i=tn.findMinimumAreaFace(e);if(i)if(i.isMaskSet(t));else for(const i of e)i.isMaskSet(t)?i.clearMaskAroundFace(t):i.setMaskAroundFace(t)}static correctParityInComponentArrays(t,e){if(t!==b.NULL_MASK)for(const i of e)tn.correctParityInSingleComponent(t,i)}static collectConnectedComponentsWithExteriorParityMasks(t,e,i=b.NULL_MASK){const s=[],n=b.VISITED,r=i|n;t.clearMask(r);for(const r of t.allHalfEdges)if(!r.isMaskSet(n)){const t=tn.parityFloodFromSeed(r,n,e,i);s.push(t)}return tn.correctParityInComponentArrays(i,s),s}static exploreComponent(t,e,i,s=b.EXTERIOR,n=1/0){n<=0&&(n=1/0);const r=i|s;let o=0;const a=[];for(a.push(e);0!==a.length&&o<n;){const e=a.shift();if(e.isMaskSet(r))continue;t.push(e),++o;const s=t=>{t.setMask(i);const e=t.vertexSuccessor;e.isMaskSet(r)||a.push(e)};e.collectAroundFace(s)}if(0!==a.length){const t=a[0];for(;0!==a.length;){const t=a.shift();if(t.vertexSuccessor.isMaskSet(s))return t;if(t.edgeMate.isMaskSet(s))return t}return t}}static collectConnectedComponents(t,e=1/0,i=b.EXTERIOR){const s=[];0===t.countMask(i)&&(i=b.NULL_MASK);const n=b.VISITED,r=n|i,o=e=>{for(let i=e;i<t.countNodes();++i)if(!t.allHalfEdges[i].isMaskSet(r)&&t.allHalfEdges[i].edgeMate.isMaskSet(r)){e=i;break}return e};for(let a=0;a<t.countNodes();++a){if(t.allHalfEdges[a].isMaskSet(r))continue;const c=o(a);let l=t.allHalfEdges[c];do{const t=[];l=tn.exploreComponent(t,l,n,i,e),0!==t.length&&s.push(t)}while(void 0!==l);t.allHalfEdges[a].isMaskSet(n)||--a}return s}static pointInOrOnFaceXY(t,e,i){const s=new zt(e,i);let n=t,r=t.faceSuccessor;for(;!s.tryStartEdge(n.x,n.y,r.x,r.y);n=r){if(r===t)return ft.createXX(r.x,r.faceSuccessor.x).containsX(e)?0:-1;r=n.faceSuccessor}let o=r.faceSuccessor;for(;;){if(!s.advance(o.x,o.y))return s.classifyCounts();if(o===r)break;o=o.faceSuccessor}return s.classifyCounts()}static collectExtendedBoundaryLoopFromSeed(t,e,i,s){let n=0;for(;!t.getMask(e)&&i(t);){s(t,n++),t.setMask(e);const r=t.faceSuccessor;let o=r;for(;;){if(o.getMask(e))return;if(i(o)){t=o;break}if(o=o.vertexPredecessor,o===r)break}}}static collectExtendedBoundaryLoopsInGraph(t,e){const i=[],s=t.grabMask(!0),n=t=>0===t.getMask(e)&&0!==t.edgeMate.getMask(e),r=(t,e)=>{0===e&&i.push([]),i[i.length-1].push(t)};for(const e of t.allHalfEdges)this.collectExtendedBoundaryLoopFromSeed(e,s,n,r);return t.dropMask(s),i}}class en{static spaceTriangleAspectRatio(t,e,i){const s=.5*t.crossProductToPoints(e,i).magnitude(),n=t.distanceSquared(e)+e.distanceSquared(i)+i.distanceSquared(t);return Q.safeDivideFraction(s,n,0)}static spaceQuadDiagonalAspectRatio(t,e,i,s){const n=this.spaceTriangleAspectRatio(t,e,i),r=this.spaceTriangleAspectRatio(t,i,s);return Math.max(n,r)}static triangulateGreedyEarCut(t,e){const i=Ur.areaNormal(t),s=[],n=t.slice();for(Mi.removeClosurePoint(n);n.length>2;){let t,e=-1,r=0,o=n.length-2,a=n.length-1;for(t=0;t<n.length;o=a,a=t,t++){const s=this.spaceTriangleAspectRatio(n[o],n[a],n[t]);n[o].crossProductToPoints(n[a],n[t]).dotProduct(i)>0&&s>e&&(e=s,r=o)}if(e<=0)return!1;o=r,a=(o+1)%n.length,t=(a+1)%n.length;const c=[];c.push(n[o],n[a],n[t]),n.splice(a,1),s.push(c)}return e(t,s),!0}static triangulateSimplestSpaceLoopGo(t,e,i){const s=ue.countNonDuplicates(t);if(void 0!==i&&ue.sumEdgeLengths(t,!0,s)>i)return!1;if(s<3)return!1;if(3===s)return 0!==this.spaceTriangleAspectRatio(t[0],t[1],t[2])&&(e(t,[t.slice()]),!0);if(4===s){const i=this.spaceQuadDiagonalAspectRatio(t[0],t[1],t[2],t[3]),s=this.spaceQuadDiagonalAspectRatio(t[1],t[2],t[3],t[0]);return!(0===i&&0===s||(i>s?(e(t,[[t[0],t[1],t[2]],[t[2],t[3],t[0]]]),0):(e(t,[[t[0],t[1],t[3]],[t[3],t[1],t[2]]]),0)))}return this.triangulateGreedyEarCut(t,e)}static triangulateSimplestSpaceLoop(t,e,i){return t instanceof Me?this.triangulateSimplestSpaceLoopGo(t.points,e,i):this.triangulateSimplestSpaceLoopGo(t,e,i)}}class sn{constructor(t=-1,e){this._facetIndex=t,this._detail=e||cs.create()}invalidate(t=!0){this._facetIndex=-1,t&&this._detail.invalidate(),this._normal=void 0,this._param=void 0,this._color=void 0}static create(t=-1,e,i){return i?i.invalidate(!1):i=new sn,i._facetIndex=t,void 0!==e&&i._detail!==e&&i._detail.copyContentsFrom(e),i}static createCapture(t,e){return new sn(t,e)}get facetIndex(){return this._facetIndex}get edgeCount(){return 3}get point(){return this._detail.world}get a(){return this._detail.a}get closestEdge(){return{startVertexIndex:this._detail.closestEdgeIndex,edgeParam:this._detail.closestEdgeParam}}get _isValid(){return this._facetIndex>=0}get isValid(){return this._isValid&&this._detail.isValid}get isConvex(){return!0}get isInsideOrOn(){return this._isValid&&this._detail.isInsideOrOn}get classify(){return this._detail.classify}clone(){const t=new sn;return t.copyContentsFrom(this),t}copyContentsFrom(t){this._facetIndex=t._facetIndex,this._detail.copyContentsFrom(t._detail),this._normal=t._normal?.clone(),this._param=t._param?.clone(),this._color=t._color}getNormal(t){if(this._detail.isValid&&void 0===this._normal&&void 0!==t){this._normal=$.create();const e=[this._detail.local.x,this._detail.local.y,this._detail.local.z];t.linearCombination(e,this._normal)}return this._normal}getParam(t){if(this._detail.isValid&&void 0===this._param&&void 0!==t){this._param=H.create();const e=[this._detail.local.x,this._detail.local.y,this._detail.local.z];t.linearCombination(e,this._param)}return this._param}getColor(t){if(this._detail.isValid&&void 0===this._color&&void 0!==t){const e=[this._detail.local.x,this._detail.local.y,this._detail.local.z];this._color=he.linearCombinationOfColors(t,e)}return this._color}getBarycentricCoordinates(){return[this._detail.local.x,this._detail.local.y,this._detail.local.z]}}class nn{constructor(t=-1,e=0,i){this._facetIndex=t,this._edgeCount=e,this._detail=i||Yr.create()}invalidate(t=!0){this._facetIndex=-1,this._edgeCount=0,t&&this._detail.invalidate()}static create(t=-1,e=0,i,s){return s?s.invalidate(!1):s=new nn,s._facetIndex=t,s._edgeCount=e,void 0!==i&&s._detail!==i&&s._detail.copyContentsFrom(i),s}static createCapture(t,e,i){return new nn(t,e,i)}get facetIndex(){return this._facetIndex}get edgeCount(){return this._edgeCount}get point(){return this._detail.point}get a(){return this._detail.a}get closestEdge(){return{startVertexIndex:this._detail.closestEdgeIndex,edgeParam:this._detail.closestEdgeParam}}get _isValid(){return this._facetIndex>=0&&this._edgeCount>=3}get isValid(){return this._isValid&&this._detail.isValid}get isConvex(){return!1}get isInsideOrOn(){return this._isValid&&this._detail.isInsideOrOn}get classify(){return this._detail.code}clone(){const t=new nn;return t.copyContentsFrom(this),t}copyContentsFrom(t){this._facetIndex=t._facetIndex,this._edgeCount=t._edgeCount,this._detail.copyContentsFrom(t._detail)}getNormal(){}getParam(){}getColor(){}getBarycentricCoordinates(){}}class rn extends nn{constructor(t=-1,e=0,i){super(t,e,i)}invalidate(t=!0){super.invalidate(t),this._normal=void 0,this._param=void 0,this._color=void 0,this._barycentricCoordinates=void 0}static create(t=-1,e=0,i,s){return s?s.invalidate(!1):s=new rn,super.create(t,e,i,s)}static createCapture(t,e,i){return new rn(t,e,i)}get isConvex(){return!0}clone(){const t=new rn;return t.copyContentsFrom(this),t}copyContentsFrom(t){super.copyContentsFrom(t),this._normal=t._normal?.clone(),this._param=t._param?.clone(),this._color=t._color,this._barycentricCoordinates=t._barycentricCoordinates?.slice()}getNormal(t,e,i=Q.smallMetricDistance){if(this._detail.isValid&&void 0===this._normal&&void 0!==t){const s=this.getBarycentricCoordinates(e,i);void 0!==s&&(this._normal=$.create(),t.linearCombination(s,this._normal))}return this._normal}getParam(t,e,i=Q.smallMetricDistance){if(this._detail.isValid&&void 0===this._param&&void 0!==t){const s=this.getBarycentricCoordinates(e,i);void 0!==s&&(this._param=H.create(),t.linearCombination(s,this._param))}return this._param}getColor(t,e,i=Q.smallMetricDistance){if(this._detail.isValid&&void 0===this._color&&void 0!==t){const s=this.getBarycentricCoordinates(e,i);void 0!==s&&(this._color=he.linearCombinationOfColors(t,s))}return this._color}getBarycentricCoordinates(t,e=Q.smallMetricDistance){return this._detail.isValid&&void 0===this._barycentricCoordinates&&void 0!==t&&(this._barycentricCoordinates=Ur.convexBarycentricCoordinates(t,this._detail.point,e)),this._barycentricCoordinates}}class on extends Float64Array{get vertexIndexA(){return this[0]}get vertexIndexB(){return this[1]}get facetIndex(){return this[2]}get isLowHigh(){return this[0]<this[1]}get lowVertexIndex(){return this[0]<this[1]?this[0]:this[1]}get highVertexIndex(){return this[0]>this[1]?this[0]:this[1]}static areDirectedPartners(t,e){return t[0]===e[1]&&t[1]===e[0]}static areUndirectedPartners(t,e){return t[0]===e[0]&&t[1]===e[1]||t[0]===e[1]&&t[1]===e[0]}static relativeOrientation(t,e){return t[0]===e[0]&&t[1]===e[1]?1:t[0]===e[1]&&t[1]===e[0]?-1:0}get isNullEdge(){return this[0]===this[1]}static lessThan(t,e){const i=t.lowVertexIndex,s=e.lowVertexIndex;if(i<s)return-1;if(s<i)return 1;const n=t.highVertexIndex,r=e.highVertexIndex;return n<r?-1:r<n?1:t.vertexIndexA-e.vertexIndexA}constructor(t,e,i){super(3),this[0]=t,this[1]=e,this[2]=i}toJSON(){return[this[0],this[1],this[2]]}static clusterToJSON(t){if(t instanceof on)return t.toJSON();const e=[];for(const i of t)e.push(i.toJSON())}static clusterArrayToJSON(t){const e=[];for(const i of t)e.push(on.clusterToJSON(i));return e}}class an{constructor(){this.edges=[]}addEdge(t,e,i){const s=new on(t,e,i);return this.edges.push(s),s}addPath(t,e,i=!0){if(0===t.length)return;const s=t.length-1;for(let i=0;i<s;i++)this.addEdge(t[i],t[i+1],e);i&&this.addEdge(t[s],t[0],e)}sort(){this.edges.sort(((t,e)=>on.lessThan(t,e)))}collectSortableEdgeCluster(t,e,i){if(void 0!==i&&e>t)if(e===t+1)i.push(this.edges[t]);else{const s=[];for(let i=t;i<e;i++)s.push(this.edges[i]);i.push(s)}}sortAndCollectClusters(t,e,i,s){this.sort(),t&&(t.length=0),e&&(e.length=0),i&&(i.length=0),s&&(s.length=0);const n=this.edges.length;let r;for(let o=0;o<n;o+=r){const a=this.edges[o];r=1;for(let t=o+1;t<n&&on.areUndirectedPartners(a,this.edges[t]);t++)r++;this.edges[o].isNullEdge?this.collectSortableEdgeCluster(o,o+r,i):2===r&&on.areDirectedPartners(a,this.edges[o+1])?this.collectSortableEdgeCluster(o,o+r,t):1===r?this.collectSortableEdgeCluster(o,o+1,e):this.collectSortableEdgeCluster(o,o+r,s)}}}class cn{constructor(t){this.numPositive=this.numNegative=0,this.firstEdgeIndex=t}recordOrientation(t){t>0?this.numPositive++:t<0&&this.numNegative++}}class ln{constructor(t){this._workArray=[],this._visitor=t.createVisitor(1),this._edges=Fn.createIndexedEdges(this._visitor),this._edgeToPartnerEdge=[],this._edgeToEdgeInComponent=[],this._facetToFirstEdgeInComponent=[],this._facetOrientation=[],this._components=[],this._mesh=t}edgeIdToFacetOrientation(t){const e=this._edges.edges[t].facetIndex;return this._facetOrientation[e]}setupUnoriented(){this._edges.sort();const t=this._edges.edges;let e=-1;const i=this._edges.edges.length;for(let t=0;t<i;t++){const i=this._edges.edges[t].facetIndex;i>e&&(e=i),this._edgeToEdgeInComponent.push(t),this._edgeToPartnerEdge.push(t)}for(let t=0;t<=e;t++)this._facetToFirstEdgeInComponent.push(-1),this._facetOrientation.push(0);for(let t=0;t<i;t++){const e=this._edges.edges[t].facetIndex,i=this._facetToFirstEdgeInComponent[e];-1===i?this._facetToFirstEdgeInComponent[e]=t:ln.swapEntries(this._edgeToEdgeInComponent,t,i)}for(let e=0;e<i;e++){let s=e+1;for(;s<i&&on.areUndirectedPartners(t[e],t[s]);)ln.swapEntries(this._edgeToPartnerEdge,e,s),s++;if(s>e+2)return!1}return!0}recordFacetInComponent(t,e){const i=this._components[this._components.length-1];this._facetOrientation[t]=e,i.recordOrientation(e)}initializeComponent(t){const e=this._edges.edges[t].facetIndex;this._components.push(new cn(t)),this.recordFacetInComponent(e,1)}pushFacetEdgesOnStack(t,e){ln.extractCyclicIndices(this._edgeToEdgeInComponent,t,this._workArray);for(const t of this._workArray)e.push(t)}doFlood(){const t=[],e=this._edges.edges,i=e.length,s=[];for(let n=0;n<i;n++)if(0===this.edgeIdToFacetOrientation(n)){let i;for(t.length=0,this.initializeComponent(n),this.pushFacetEdgesOnStack(n,t);void 0!==(i=t.pop());){const n=e[i].facetIndex,r=this._facetOrientation[n];ln.extractCyclicIndices(this._edgeToPartnerEdge,i,s);for(const n of s)if(n!==i){const s=e[n].facetIndex,o=this._facetOrientation[s];if(0===o){const o=on.areDirectedPartners(e[i],e[n])?r:-r;this.recordFacetInComponent(s,o),this.pushFacetEdgesOnStack(n,t),ln.swapEntries(this._edgeToEdgeInComponent,i,n)}else if(on.relativeOrientation(e[i],e[n])*r*o>0)return!1}}}return!0}doFacetReversals(){let t=0;for(this._visitor.reset();this._visitor.moveToNextFacet();){const e=this._visitor.currentReadIndex();this._facetOrientation[e]<0&&(t++,this._mesh.reverseSingleFacet(e))}return t}static doFixup(t){const e=new ln(t);if(!e.setupUnoriented())return!1;const i=e.doFlood();return i&&e.doFacetReversals(),i}static swapEntries(t,e,i){const s=t[e];t[e]=t[i],t[i]=s}static extractCyclicIndices(t,e,i){i.length=0;let s=e;do{i.push(s),s=t[s]}while(s!==e)}}class hn{constructor(t,e,i){this.index=t,this.area=e,this.normal=i}addWeightedNormal(t,e){this.area+=t,this.normal.addScaledInPlace(e,t)}divideNormalByArea(){this.normal.scaleInPlace(1/this.area)}}class dn{constructor(t,e,i){this.facetData=t,this.sectorClusterData=void 0,this.sectorIndex=e,this.vertexIndex=i}static cbSectorSort(t,e){return t.sectorIndex-e.sectorIndex}static cbVertexSort(t,e){return t.vertexIndex-e.vertexIndex}static pushToArray(t,e,i,s){t.push(new dn(e,i,s))}}class un{static buildFastAverageNormals(t,e){const i=t.createVisitor(0),s=$.create(0,0,1),n=Q.smallMetricDistanceSquared,r=[];let o=0,a=0;for(;i.moveToNextFacet();){let t=Ur.areaNormalGo(i.point),e=0;t?(e=t.magnitude(),e<n?(t.setFromVector3d(s),e=0):t.scaleInPlace(1/e)):(t=s.clone(),e=0);const c=new hn(o++,e,t);for(let t=0;t<i.pointCount;t++)dn.pushToArray(r,c,a++,i.clientPointIndex(t))}r.sort(((t,e)=>dn.cbVertexSort(t,e)));const c=[];let l=e.radians;l<1e-4&&(l=1e-4);let h=0;for(let t=0;t<r.length;t++){const e=r[t],i=e.vertexIndex,s=e.facetData;if(void 0===e.sectorClusterData){const n=new hn(h++,0,$.createZero());c.push(n),n.addWeightedNormal(1,e.facetData.normal);for(let e=t;e<r.length;e++){const t=r[e];if(t.vertexIndex!==i)break;t.facetData.normal.angleTo(s.normal).radians>l||void 0===t.sectorClusterData&&(n.addWeightedNormal(1,t.facetData.normal),t.sectorClusterData=n)}}}r.sort(((t,e)=>dn.cbSectorSort(t,e))),t.data.normalIndex=[],t.data.normal=new nt(r.length);for(const e of c)e.divideNormalByArea(),e.index=t.data.normal.length,t.data.normal.push(e.normal);for(const e of r)t.data.normalIndex.push(e.sectorClusterData.index)}static buildPerFaceNormals(t){const e=t.createVisitor(0),i=$.create(0,0,1),s=$.create(0,0,1),n=new nt(t.faceCount),r=[];for(;e.moveToNextFacet();){const t=n.length;Ur.unitNormal(e.point,i)?n.push(i):n.push(s);for(let i=0;i<e.pointCount;i++)r.push(t)}t.data.normalIndex=r,t.data.normal=n}}function fn(t){return void 0!==t&&t}class gn{constructor(){this.numActiveSectors=0,this.numInactiveSectors=0,this.averageNormal=$.create(),this.radiansSum=0,this.maxDeviationRadiansFromAverage=0}clear(){this.numActiveSectors=0,this.numInactiveSectors=0,this.averageNormal.setZero(),this.radiansSum=0,this.maxDeviationRadiansFromAverage=0}accumulateNormal(t,e,i){if(t.isMaskSet(i))this.numInactiveSectors++;else{const i=us.sectorSweepRadiansXYZ(t,e);this.averageNormal.addScaledInPlace(e,i),this.radiansSum+=i,this.numActiveSectors++}}finishNormalAveraging(){return!!(this.numActiveSectors>0&&this.averageNormal.normalizeInPlace())}recordDeviation(t,e){if(e){const e=this.averageNormal.radiansTo(t);this.maxDeviationRadiansFromAverage=Math.max(Math.abs(this.maxDeviationRadiansFromAverage),e)}}get maxDeviationRadians(){return this.maxDeviationRadiansFromAverage}}function pn(t){void 0!==_n.stringDebugFunction&&(_n.stringDebugFunction(`    Sector xyz    ${t.xyz.x},${t.xyz.y},${t.xyz.z} `),_n.stringDebugFunction(`           normal ${t.normal.x},${t.normal.y},${t.normal.z} `))}class mn{constructor(t,e){this.facetIndex=t,this.facetNormal=e}}class xn{constructor(t,e){this.xyz=e,this.normal=t,this.count=0}static edgeHasLargeExteriorAngleBetweenNormals(t,e,i,s,n=.5*Math.PI){const r=t.edgeTag,o=t.edgeMate.edgeTag;if(void 0!==r&&void 0!==o){t.vectorToFaceSuccessor(e);const a=r.normal.signedRadiansTo(o.normal,e);if(Q.split3WaySign(s,-1,1,1)*a>=n&&($.createAdd2Scaled(r.normal,1,o.normal,1,i),i.normalizeInPlace()))return!0}return!1}static almostEqualNormals(t,e,i=Q.smallAngleRadians){return t.normal.radiansTo(e.normal)<=i}static radiansBetweenNormals(t,e){return t.normal.radiansTo(e.normal)}setOffsetPointAtDistanceAtHalfEdge(t,e){t.getPoint3d(this.xyz),this.xyz.addScaledInPlace(this.normal,e)}static setXYZAtHalfEdge(t,e){const i=t.edgeTag;void 0!==i&&void 0!==e&&i.xyz.set(e.x,e.y,e.z)}setXYAndZ(t){this.xyz.set(t.x,t.y,t.z)}static setNormalAtHalfEdge(t,e,i){const s=t.edgeTag;void 0!==s&&(s.normal.set(e.x,e.y,e.z),void 0!==i&&s.setOffsetPointAtDistanceAtHalfEdge(t,i))}static sweepRadiansAroundNormal(t,e){const i=t.edgeTag,s=t.vertexSuccessor.edgeTag;if(void 0!==i&&void 0!==s)return i.normal.planarRadiansTo(s.normal,e)}static getSectorPointAtHalfEdge(t,e,i){const s=t.edgeTag;return void 0!==s&&(void 0!==e&&e.setFromPoint3d(s.xyz),void 0!==i&&i.push(s.xyz),!0)}static pushXYZ(t,e){const i=e.edgeTag;return void 0!==i&&t.push(i.xyz),i}static accumulateScaledNormalAtHalfEdge(t,e,i){const s=t.edgeTag;void 0!==s&&i.addScaledInPlace(s.normal,e)}}class _n{constructor(t,e,i){this._basePolyface=t,this._baseGraph=e,this._breakMaskA=e.grabMask(),this._breakMaskB=e.grabMask(),this._insideOfChamferFace=e.grabMask(),this._outsideOfChamferFace=e.grabMask(),this._insideChamferSling=e.grabMask(),this._outsideEndOfChamferFace=e.grabMask(),this._exteriorMask=b.EXTERIOR,this._offsetCoordinatesReassigned=e.grabMask(),this._smoothRadiansBetweenNormals=i.smoothSingleAngleBetweenNormals.radians,this._chamferTurnRadians=i.chamferAngleBetweenNormals.radians,this._smoothAccumulatedRadiansBetweenNormals=i.smoothAccumulatedAngleBetweenNormals.radians}get exteriorMask(){return this._exteriorMask}get breakMaskA(){return this._breakMaskA}get breakMaskB(){return this._breakMaskB}get insideOfChamferFace(){return this._insideOfChamferFace}get outsideOfChamferFace(){return this._outsideOfChamferFace}get insideChamferSling(){return this._insideChamferSling}get outsideEndOfChamferFace(){return this._outsideEndOfChamferFace}applyFaceNormalOffsetsToSectorData(t){this._baseGraph.announceNodes(((e,i)=>{const s=i.edgeTag;return void 0!==s&&s.setOffsetPointAtDistanceAtHalfEdge(i,t),!0}))}static buildOffsetMeshWithEdgeChamfers(t,e,i,s){const n=this.buildBaseGraph(t);if(void 0!==n){const r=new _n(t,n,s);r.applyFaceNormalOffsetsToSectorData(i),void 0!==_n.graphDebugFunction&&_n.graphDebugFunction("BaseGraph",n,r._breakMaskA,r._breakMaskB);const o=s.outputSelector?s.outputSelector:{outputOffsetsFromFaces:!0,outputOffsetsFromEdges:!0,outputOffsetsFromVertices:!0};fn(o.outputOffsetsFromFacesBeforeChamfers)&&r.announceFacetsWithSectorCoordinatesAroundFaces(e),r.addChamferTopologyToAllEdges(s,i),r.computeOffsetFacetIntersections(i),void 0!==_n.graphDebugFunction&&_n.graphDebugFunction("after computeEdgeChamfers",n,r._breakMaskA,r._breakMaskB),fn(o.outputOffsetsFromFaces)&&r.announceFacetsWithSectorCoordinatesAroundFaces(e),fn(o.outputOffsetsFromEdges)&&r.announceFacetsWithSectorCoordinatesAroundEdges(e),fn(o.outputOffsetsFromVertices)&&r.announceFacetsWithSectorCoordinatesAroundVertices(e)}}announceSimpleOffsetFromFaces(t,e){const i=new nt,s=j.create(),n=$.create(),r=t=>(t.getPoint3d(s),s.addInPlace(n),i.push(s),0);this._baseGraph.announceFaceLoops(((s,o)=>{if(!o.isMaskSet(b.EXTERIOR)){const s=o.faceTag;n.setFromVector3d(s.facetNormal.direction),n.scaleInPlace(e),i.length=0,o.sumAroundFace(r),t.addPolygonGrowableXYZArray(i)}return!0}))}announceFacetsWithSectorCoordinatesAroundFaces(t){const e=new nt,i=t=>{const i=t.edgeTag;return void 0!==i&&e.push(i.xyz),0};this._baseGraph.announceFaceLoops(((s,n)=>(n.isMaskSet(b.EXTERIOR)||(e.length=0,n.sumAroundFace(i),e.length>2&&t.addPolygonGrowableXYZArray(e)),!0)))}countBits(t){let e=0,i=t;for(;0!==i;)1&i&&e++,i>>=1;return e}announceFacetsWithSectorCoordinatesAroundEdges(t){const e=new nt,i=Q.smallMetricDistance,s=this._exteriorMask|this._outsideEndOfChamferFace|this._outsideOfChamferFace|this._insideOfChamferFace|this._insideChamferSling;this._baseGraph.announceEdges(((n,r)=>{if(void 0!==r.findMaskAroundEdge(this._exteriorMask))return!0;if(r.isMaskSet(s))return!0;{const n=r.faceSuccessor,o=r.edgeMate;if(!o.isMaskSet(s)){const s=o.faceSuccessor;e.clear(),xn.getSectorPointAtHalfEdge(r,void 0,e),xn.getSectorPointAtHalfEdge(n,void 0,e),xn.getSectorPointAtHalfEdge(o,void 0,e),xn.getSectorPointAtHalfEdge(s,void 0,e),ki.compressInPlaceByShortEdgeLength(e,i),e.length>2&&t.addPolygonGrowableXYZArray(e)}}return!0}))}getCoordinateString(t,e=!0,i=!1){return e?i?`${us.nodeToIdXYZString(t)} ==> ${us.nodeToIdXYZString(t.faceSuccessor)}`:`${us.nodeToIdXYZString(t)}`:i?`==> ${us.nodeToIdXYZString(t.faceSuccessor)}`:""}inspectMasks(t,e=!0,i=!1){return"[".concat(t.id.toString(),t.isMaskSet(this._exteriorMask)?"X":"",t.isMaskSet(this.breakMaskA)?"A":"",t.isMaskSet(this.breakMaskB)?"B":"",t.isMaskSet(this.insideChamferSling)?"(sling)":"",t.isMaskSet(this.insideOfChamferFace)?"(in chamfer)":"",t.isMaskSet(this.outsideEndOfChamferFace)?"(@sling)":"",t.isMaskSet(this.outsideOfChamferFace)?"(@chamfer)":"",this.getCoordinateString(t,e,i),"]")}announceFacetsWithSectorCoordinatesAroundVertices(t){const e=new nt,i=Q.smallMetricDistance;this._baseGraph.announceVertexLoops(((s,n)=>(n.findMaskAroundVertex(this._exteriorMask)||(e.length=0,n.sumAroundVertex((t=>(t.isMaskSet(this._insideChamferSling)||xn.getSectorPointAtHalfEdge(t,void 0,e),0))),ki.compressInPlaceByShortEdgeLength(e,i),e.length>2&&t.addPolygonGrowableXYZArray(e)),!0)))}static buildBaseGraph(t){const e=new Ks,i=t.createVisitor(),s=j.create(),n=j.create();for(i.reset();i.moveToNextFacet();){const r=Ur.centroidAreaNormal(i.point);if(void 0!==r){const o=e.insertLoop(i.pointIndex,(e=>{const i=e.edgeMate;t.data.getPoint(e.i,s),e.setXYZ(s),t.data.getPoint(i.i,n),i.setXYZ(n)})),a=new mn(i.currentReadIndex(),r);void 0!==o&&o.sumAroundFace((t=>(t.faceTag=a,t.edgeTag=new xn(r.direction.clone(),t.getPoint3d()),0)))}}return e.graph}setOffsetAtDistanceAroundVertex(t,e,i=!1){t.sumAroundVertex((s=>{const n=s.edgeTag;return void 0!==n&&(i&&this.isInsideChamferOrSling(t)||n.setOffsetPointAtDistanceAtHalfEdge(s,e)),0}))}setOffsetXYAndZAroundVertex(t,e){t.sumAroundVertex((t=>{const i=t.edgeTag;return void 0!==i&&(i.setXYAndZ(e),t.setMask(this._offsetCoordinatesReassigned)),0}))}announceNodeAndSectorPropertiesInSmoothSector(t,e){let i=0;for(let s=t;;s=s.vertexSuccessor){const n=s.edgeTag;if(void 0!==n&&(e(s,n),i++),s.isMaskSet(this._breakMaskB))return i;if(s.isMaskSet(this._exteriorMask))return i;if(s===t&&0===i)return i}}computeAverageNormalAndMaxDeviationAroundVertex(t,e){e.clear();const i=this._exteriorMask|this._insideChamferSling;if(t.sumAroundVertex((t=>{const s=t.edgeTag;return s&&e.accumulateNormal(t,s.normal,i),0})),e.finishNormalAveraging())return t.sumAroundVertex((t=>{const s=t.edgeTag;return s&&e.recordDeviation(s.normal,!t.isMaskSet(i)),0})),e.maxDeviationRadians}assignOffsetByAverageNormalAroundVertex(t,e,i,s){const n=this.computeAverageNormalAndMaxDeviationAroundVertex(t,i);return _n.stringDebugFunction&&(_n.stringDebugFunction(`XYZ ${us.nodeToIdXYZString(t)} Average Normal ${JSON.stringify(i.averageNormal.toJSON())}`),_n.stringDebugFunction(`           angle ratio ${i.radiansSum/(2*Math.PI)}   maxDeviation ${i.maxDeviationRadiansFromAverage}`)),void 0!==n&&n<=e&&(t.sumAroundVertex((t=>(xn.setNormalAtHalfEdge(t,i.averageNormal,s),0))),!0)}markBreakEdgesAndSaveAverageNormalsAroundVertex(t){t.clearMaskAroundVertex(this._breakMaskA),t.clearMaskAroundVertex(this._breakMaskB);const e=this._smoothRadiansBetweenNormals,i=this._smoothAccumulatedRadiansBetweenNormals;let s=0,n=t,r=0;do{const t=n.edgeMate,i=t.faceSuccessor;n.isMaskSet(this._exteriorMask)?t.isMaskSet(this._exteriorMask)||(i.setMask(this._breakMaskB),s++):n.isMaskSet(this._outsideOfChamferFace)?n.setMask(this._breakMaskA):n.isMaskSet(this._outsideEndOfChamferFace)?(n.setMask(this._breakMaskA),n.setMask(this._breakMaskB)):n.isMaskSet(this._insideChamferSling)||(n.isMaskSet(this._insideOfChamferFace)?(n.setMask(this._breakMaskA),n.setMask(this._breakMaskB),i.setMask(this._breakMaskB)):t.isMaskSet(this._exteriorMask)?(s++,n.setMask(this._breakMaskA)):xn.almostEqualNormals(n.edgeTag,i.edgeTag,e)?r++:(n.setMask(this._breakMaskA),s++,i.setMask(this._breakMaskB))),n=n.vertexSuccessor}while(n!==t);void 0!==_n.stringDebugFunction&&_n.stringDebugFunction(`   numSkip   ${r} `),0===s&&(t.setMask(this._breakMaskA),t.vertexPredecessor.setMask(this._breakMaskB),s=1);const o=n.findMaskAroundVertex(this._breakMaskA);if(void 0!==o){n=o;do{if(n.isMaskSet(this._breakMaskA)&&!n.isMaskSet(this._breakMaskB)){let t=0;do{const e=n.vertexSuccessor;t+=xn.radiansBetweenNormals(n.edgeTag,e.edgeTag),t>i&&(n.setMask(this._breakMaskB),e.setMask(this._breakMaskA),s++,t=0),n=e}while(!n.isMaskSet(this._breakMaskB))}else n=n.vertexSuccessor}while(n!==o)}if(s>0&&void 0!==o){n=o;const t=$.create(),e=$.create(),i=$.create();t.setZero();do{if(n.isMaskSet(this._breakMaskA)&&!n.isMaskSet(this._breakMaskB)){let s=n;for(t.setZero();;){s.vectorToFaceSuccessor(e),s.vectorToFacePredecessor(i);let n=e.signedRadiansTo(i,s.faceTag.facetNormal.direction);if(n<0&&(n+=2*Math.PI),xn.accumulateScaledNormalAtHalfEdge(s,n,t),s.isMaskSet(this._breakMaskB))break;s=s.vertexSuccessor}if(t.normalizeInPlace())for(s=n;xn.setNormalAtHalfEdge(s,t),!s.isMaskSet(this._breakMaskB);)s=s.vertexSuccessor}n=n.vertexSuccessor}while(n!==o)}}compute3SectorIntersection(t,e,i,s){const n=t.edgeTag,r=e.edgeTag,o=i.edgeTag;return Mt.intersect3Planes(n.xyz,n.normal,r.xyz,r.normal,o.xyz,o.normal,s)}compute3SectorIntersectionDebug(t,e,i,s){const n=t.edgeTag,r=e.edgeTag,o=i.edgeTag;if(void 0!==_n.stringDebugFunction){_n.stringDebugFunction(`compute3${this.inspectMasks(t)}${this.inspectMasks(e)}${this.inspectMasks(i)} `);for(const t of[n,r,o])pn(t)}const a=Mt.intersect3Planes(n.xyz,n.normal,r.xyz,r.normal,o.xyz,o.normal,s);return void 0!==_n.stringDebugFunction&&(void 0===a?_n.stringDebugFunction(" NO INTERSECTION"):_n.stringDebugFunction(` ComputedVector ${a.x},${a.y},${a.z} `)),a}compute2SectorIntersection(t,e,i){const s=t.edgeTag,n=e.edgeTag,r=s.normal.crossProduct(n.normal);return Mt.intersect3Planes(s.xyz,s.normal,n.xyz,n.normal,n.xyz,r,i)}addChamferTopologyToAllEdges(t,e){const i=[],s=t.chamferAngleBetweenNormals.radians,n=j.create(),r=$.create(),o=$.create(),a=$.create();this._baseGraph.announceEdges(((t,n)=>!xn.edgeHasLargeExteriorAngleBetweenNormals(n,r,a,e,s)||(i.push(n),!0)));for(const t of i)if(xn.edgeHasLargeExteriorAngleBetweenNormals(t,r,a,s)){const i=this._baseGraph.splitEdgeCreateSliverFace(t),s=i.facePredecessor,c=i.getPoint3d();c.addScaledInPlace(a,e);const l=bt.createCapture(c,a.clone()),h=new mn(-1,l);let d=-1;for(const t of[i,s]){r.scale(d,o),t.getPoint3d(n),t.setMask(this._insideOfChamferFace),t.edgeMate.setMask(this._outsideOfChamferFace),t.faceTag=h;const e=this._baseGraph.splitEdge(void 0,n.x,n.y,n.z,t.i),i=e.edgeMate;e.setMask(this._outsideEndOfChamferFace),e.faceTag=h,i.setMask(this._insideChamferSling),us.pinch(t,e);const s=bt.create(n,o),l=new mn(-1,s);i.faceTag=l,t.edgeTag=new xn(a.clone(),c.clone()),e.edgeTag=new xn(a.clone(),c.clone()),i.edgeTag=new xn(o.clone(),n.clone());const u=this.compute3SectorIntersection(t,t.edgeMate,i),f=this.compute3SectorIntersection(e,e.vertexSuccessor,i);xn.setXYZAtHalfEdge(t,u),xn.setXYZAtHalfEdge(e,f),d*=-1}}}computeOffsetFacetIntersections(t){void 0!==_n.stringDebugFunction&&_n.stringDebugFunction("*****                                 recompute intersections");const e=[],i=j.create(),s=j.create(),n=2*t,r=new gn,o=W.degreesToRadians(25);this._baseGraph.announceVertexLoops(((a,c)=>{let l=c.findMaskAroundVertex(this._outsideEndOfChamferFace);if(void 0===l&&(l=c.findMaskAroundVertex(this._breakMaskA)),void 0===l&&(l=c),void 0!==_n.stringDebugFunction&&(_n.stringDebugFunction(""),_n.stringDebugFunction(` VERTEX LOOP   ${JSON.stringify(l.getPoint3d().toJSON())} `),l.sumAroundVertex((t=>(_n.stringDebugFunction(this.inspectMasks(t,!1,!0)),0)))),this.assignOffsetByAverageNormalAroundVertex(l,o,r,t))return!0;if(this.markBreakEdgesAndSaveAverageNormalsAroundVertex(l),this.setOffsetAtDistanceAroundVertex(l,t,!0),l.collectMaskedEdgesAroundVertex(this._breakMaskA,!0,e),void 0!==_n.stringDebugFunction){_n.stringDebugFunction(` BREAK EDGES from ${this.inspectMasks(l,!0,!1)}`);for(const t of e)_n.stringDebugFunction(this.inspectMasks(t,!1,!0))}if(e.length<=1);else if(2===e.length){const t=this.compute2SectorIntersection(e[0],e[1]);void 0!==t&&this.setOffsetXYAndZAroundVertex(l,t)}else if(3===e.length){void 0!==_n.stringDebugFunction&&_n.stringDebugFunction(` Vertex Update just ${e.length} `);const t=this.compute3SectorIntersection(e[0],e[1],e[2]);void 0!==t&&this.setOffsetXYAndZAroundVertex(l,t)}else{void 0!==_n.stringDebugFunction&&_n.stringDebugFunction(` Vertex Update breakEdges ${e.length} `),l.getPoint3d(i);for(let t=0;t<e.length;t++){const i=t,s=(i+1)%e.length,n=(s+1)%e.length;if(e[i].isMaskSet(this._outsideEndOfChamferFace)&&e[s].isMaskSet(this._outsideOfChamferFace)&&e[n].isMaskSet(this._insideOfChamferFace)){void 0!==_n.stringDebugFunction&&_n.stringDebugFunction(`    ChamferChamfer Fixup ${this.inspectMasks(e[i])} ${this.inspectMasks(e[s])} ${this.inspectMasks(e[n])} `);const r=this.compute3SectorIntersection(e[i],e[s],e[n]);if(void 0!==r){for(const t of[i,s,n])this.announceNodeAndSectorPropertiesInSmoothSector(e[t],((t,e)=>{e.setXYAndZ(r),t.setMask(this._offsetCoordinatesReassigned)}));t+=2}}}for(let t=0;t<e.length;t++){const i=t,n=(i+1)%e.length;this.isInsideSling(e[i],e[n])||(!this.isOffsetAssigned(e[i])&&e[n].isMaskSet(this.insideOfChamferFace)?this.transferXYZFromNodeToSmoothSector(e[n],e[i],"push left from chamfer",s):!this.isOffsetAssigned(e[n])&&e[i].isMaskSet(this.outsideEndOfChamferFace)&&this.transferXYZFromNodeToSmoothSector(e[i],e[n],"push right from chamfer",s))}for(let t=0;t<e.length;t++){const s=t,r=(s+1)%e.length,o=(r+1)%e.length;if(this.isInsideSling(e[s],e[r],e[o]))continue;if(this.isOffsetAssigned(e[r]))continue;void 0!==_n.stringDebugFunction&&_n.stringDebugFunction(`    Intersection Fixup ${this.inspectMasks(e[s])} ${this.inspectMasks(e[r])} ${this.inspectMasks(e[o])} `);const a=this.compute3SectorIntersection(e[s],e[r],e[o]);void 0!==a&&i.distance(a)<n&&this.announceNodeAndSectorPropertiesInSmoothSector(e[r],((t,e)=>{e.setXYAndZ(a),t.setMask(this._offsetCoordinatesReassigned)}))}}if(void 0!==_n.stringDebugFunction){const t=l.countMaskAroundVertex(this._offsetCoordinatesReassigned,!1),e=`   **** Vertex offset mask counts(TRUE ${l.countMaskAroundVertex(this._offsetCoordinatesReassigned,!0)})(FALSE ${t})`;_n.stringDebugFunction(e)}return!0}))}isInsideSling(t,e,i){return t.isMaskSet(this._insideChamferSling)||void 0!==e&&e.isMaskSet(this._insideChamferSling)||void 0!==i&&i.isMaskSet(this._insideChamferSling)}isInsideChamferOrSling(t){return t.isMaskSet(this._insideChamferSling)||t.isMaskSet(this._insideOfChamferFace)||t.isMaskSet(this._outsideEndOfChamferFace)}isOffsetAssigned(t,e,i){return t.isMaskSet(this._offsetCoordinatesReassigned)||void 0!==e&&e.isMaskSet(this._offsetCoordinatesReassigned)||void 0!==i&&i.isMaskSet(this._offsetCoordinatesReassigned)}transferXYZFromNodeToSmoothSector(t,e,i,s){void 0!==_n.stringDebugFunction&&_n.stringDebugFunction(`    ${i} ${this.inspectMasks(t)} to ${this.inspectMasks(e)}} `),xn.getSectorPointAtHalfEdge(t,s,void 0),this.announceNodeAndSectorPropertiesInSmoothSector(e,((t,e)=>{e.setXYAndZ(s),t.setMask(this._offsetCoordinatesReassigned)}))}}class yn{constructor(t){this._segmentPoint0=j.create(),this._segmentPoint1=j.create(),this._localSegmentPoint0=j.create(),this._localSegmentPoint1=j.create(),this._clipFractions=Re.create(0,1),this._localFrame=pt.createIdentity(),this._polygonRange=ut.create(),this._spacePoints=t,this._spacePointsRange=new ut,t.setRange(this._spacePointsRange),this._numSpacePoints=this._spacePoints.length}static create(t){if(t.length>1)return new yn(t.clone())}projectToPolygon(t,e,i,s){t.setRange(this._polygonRange);let n=0;if(!this._polygonRange.intersectsRangeXY(this._spacePointsRange))return n;for(let r=1;r+1<t.length;r++){n++;const o=t.fillLocalXYTriangleFrame(0,r,r+1,this._localFrame);if(o)for(let t=1;t<this._numSpacePoints;t++)if(n++,this._spacePoints.getPoint3dAtCheckedPointIndex(t-1,this._segmentPoint0),this._spacePoints.getPoint3dAtCheckedPointIndex(t,this._segmentPoint1),o.multiplyInversePoint3d(this._segmentPoint0,this._localSegmentPoint0),o.multiplyInversePoint3d(this._segmentPoint1,this._localSegmentPoint1),this._clipFractions.set(0,1),this._clipFractions.clipBy01FunctionValuesPositive(this._localSegmentPoint0.x,this._localSegmentPoint1.x)&&this._clipFractions.clipBy01FunctionValuesPositive(this._localSegmentPoint0.y,this._localSegmentPoint1.y)&&this._clipFractions.clipBy01FunctionValuesPositive(1-this._localSegmentPoint0.x-this._localSegmentPoint0.y,1-this._localSegmentPoint1.x-this._localSegmentPoint1.y)){n++;const r=this._localSegmentPoint0.interpolate(this._clipFractions.x0,this._localSegmentPoint1),o=this._localSegmentPoint0.interpolate(this._clipFractions.x1,this._localSegmentPoint1),a=this._localFrame.multiplyPoint3d(r),c=this._localFrame.multiplyPoint3d(o),l=this._localFrame.multiplyXYZ(r.x,r.y,0),h=this._localFrame.multiplyXYZ(o.x,o.y,0),d=Q.inverseInterpolate01(this._localSegmentPoint0.z,this._localSegmentPoint1.z);if(void 0!==d&&d>this._clipFractions.x0&&d<this._clipFractions.x1){n++;const r=this._segmentPoint0.interpolate(d,this._segmentPoint1),o=r.clone();e(this._spacePoints,t-1,i,s,[a,r,l],2,1),e(this._spacePoints,t-1,i,s,[c,o,h],1,2)}else this._localSegmentPoint0.z>0?e(this._spacePoints,t-1,i,s,[a,c,h,l],3,2):e(this._spacePoints,t-1,i,s,[c,a,l,h],2,3)}}return n}}class vn{constructor(t,e){this.edgePlane=t,this.clip=e,this._crossingPoints=[]}static createPointPointSweep(t,e,i){const s=$.createStartEnd(t,e),n=s.fractionOfProjectionToVector(i),r=s.plusScaled(i,-n),o=Wr.createNormalAndPoint(r,t),a=Wr.createNormalAndPoint(r,e),c=Wr.createOriginAndVectors(t,s,i);if(void 0!==o&&void 0!==a&&void 0!==c){a.negateInPlace();const t=kn.createPlanes([o,a]);return new vn(c,t)}}processPolygon(t,e){this._crossingPoints.length=0,Array.isArray(t)?qr.polygonPlaneCrossings(this.edgePlane,t,this._crossingPoints):Zr.polygonPlaneCrossings(this.edgePlane,t,this._crossingPoints),2===this._crossingPoints.length&&this.clip.announceClippedSegmentIntervals(0,1,this._crossingPoints[0],this._crossingPoints[1],((t,i)=>{e(this._crossingPoints[0].interpolate(t,this._crossingPoints[1]),this._crossingPoints[0].interpolate(i,this._crossingPoints[1]))}))}}class Pn{constructor(t,e){this._edgeClippers=t,void 0!==e&&(this._localToWorld=e.localToWorld,this._worldToLocal=e.worldToLocal,this._localRange=e.localRange)}static create(t,e){if(void 0===e&&(e=$.create(0,0,1)),t.length>1){const i=j.createZero(),s=j.createZero(),n=[];t.getPoint3dAtUncheckedPointIndex(0,i);let r=xt.createRigidHeadsUp(e);void 0===r&&(r=xt.createIdentity());const o=pt.createOriginAndMatrix(i,r),a=o.inverse(),c=t.getRange(a);for(let r=1;r<t.length;r++){t.getPoint3dAtUncheckedPointIndex(r,s);const o=vn.createPointPointSweep(i,s,e);void 0!==o&&(i.setFrom(s),n.push(o))}return new Pn(n,{localToWorld:o,worldToLocal:a,localRange:c})}}processPolygon(t,e){if(void 0===this._worldToLocal||void 0===this._localRange||ut.createTransformedArray(this._worldToLocal,t).intersectsRangeXY(this._localRange))for(const i of this._edgeClippers)i.processPolygon(t,e)}}class An{constructor(t,e,i){this._range=t,this._numXEdge=Math.max(e,1),this._numYEdge=Math.max(i,1),this._data=[];for(let t=0;t<i;t++){const t=[];for(let i=0;i<e;i++)t.push(void 0);this._data.push(t)}}get numXEdge(){return this._numXEdge}get numYEdge(){return this._numYEdge}xIndex(t){const e=(t-this._range.low.x)/(this._range.high.x-this._range.low.x),i=Math.floor(e*this._numXEdge);return i<0?0:i>this._numXEdge-1?this._numXEdge-1:i}yIndex(t){const e=(t-this._range.low.y)/(this._range.high.y-this._range.low.y),i=Math.floor(e*this._numYEdge);return i<0?0:i>this._numYEdge-1?this._numYEdge-1:i}static createWithEstimatedCounts(t,e,i){if(t.low.x>=t.high.x||t.low.y>=t.high.y)return;const s=gt.createXYXY(t.low.x,t.low.y,t.high.x,t.high.y),n=s.xLength(),r=s.yLength();let o,a;return r>n?(a=Math.ceil(Math.sqrt(r*e/(i*n))),o=Math.ceil(e/a)):(o=Math.ceil(Math.sqrt(n*e/(i*r))),a=Math.ceil(e/(o*i))),new An(s,o,a)}addDataAtXY(t,e,i){const s=this.xIndex(t),n=this.yIndex(e);let r=this._data[n][s];r||(r=[],this._data[n][s]=r),r.push(i)}getDataAtXY(t,e){const i=this.xIndex(t),s=this.yIndex(e);return this._data[s][i]}getDataAtIndex(t,e){if(!(t<0||t>=this._numXEdge||e<0||e>=this._numYEdge))return this._data[e][t]}isValidIndex(t,e){return!(t<0||t>=this._numXEdge||e<0||e>=this._numYEdge)}}class In{get indexGrid(){return this._buckets}constructor(t,e){this._points=t,this._buckets=e}static create(t,e){const i=t.length;if(t.length<1)return;const s=t.getRange();s.expandInPlace(1e3*Q.smallMetricDistance);const n=An.createWithEstimatedCounts(s,t.length,e);if(void 0===n)return;const r=new In(t,n),o=j.create();for(let e=0;e<i;e++)t.getPoint3dAtUncheckedPointIndex(e,o),n.addDataAtXY(o.x,o.y,e);return r}announcePointsInRange(t,e){const i=this._buckets.xIndex(t.low.x),s=this._buckets.xIndex(t.high.x),n=this._buckets.yIndex(t.low.y),r=this._buckets.yIndex(t.high.y),o=this._points.length;for(let a=i;a<=s;a++)for(let i=n;i<=r;i++){const s=this._buckets.getDataAtIndex(a,i);if(void 0!==s)for(const i of s)if(i<o){const s=this._points.getXAtUncheckedPointIndex(i),n=this._points.getYAtUncheckedPointIndex(i),r=this._points.getZAtUncheckedPointIndex(i);if(t.containsXY(s,n)&&!e(i,s,n,r))return}}}}class Sn{constructor(t=0){this._minMax=ft.createNull(),this._count=this._sumX=this._sumXX=0,this._origin=t}get count(){return this._count}get mean(){return this._count>0?this._sumX/this._count:0}get meanSquare(){return this._count>0?this._sumXX/this._count:0}get minMax(){return this._minMax.clone()}get standardDeviation(){if(this._count<1)return 0;const t=this.mean,e=this._sumXX,i=this._sumX;return Math.sqrt((e-2*t*i+this._count*t*t)/this._count)}clearSums(){this._count=this._sumX=this._sumXX=0,this._minMax.setNull()}get origin(){return this._origin}setOrigin(t){this._origin=t}shiftOriginAndSums(t){const e=t-this._origin;this._origin=t,this._sumXX=this._sumXX-2*e*this._sumX+this._count*e*e,this._sumX=this._sumX-this._count*e,this._minMax.cloneTranslated(-e,this._minMax)}accumulate(t){t-=this._origin,this._count+=1,this._sumX+=t,this._sumXX+=t*t,this._minMax.extendX(t)}accumulateArray(t){for(const e of t)this.accumulate(e)}clone(t){return t||(t=new Sn),this._minMax.clone(t._minMax),t._count=this._count,t._origin=this._origin,t._sumX=this._sumX,t._sumXX=this._sumXX,t}isAlmostEqual(t){return Q.isAlmostEqualNumber(this._sumX,t._sumX)&&Q.isAlmostEqualNumber(this._sumXX,t._sumXX)&&Q.isAlmostEqualNumber(this._origin,t._origin)&&this._count===t._count&&this._minMax.isAlmostEqual(t._minMax)}}class wn{constructor(){this.range=ut.createNull(),this.xSums=new Sn,this.ySums=new Sn,this.zSums=new Sn,this._workRange=ut.createNull()}accumulateGrowableXYZArrayRange(t){t.setRange(this._workRange),this.range.extendRange(this._workRange),this.xSums.accumulate(this._workRange.xLength()),this.ySums.accumulate(this._workRange.yLength()),this.zSums.accumulate(this._workRange.zLength())}}class Cn{constructor(t,e,i,s,n,r){this.vectorToEye=t,this.sideAngle=e,this.assembleChains=i,this.collectOnForwardFacets=s,this.collectOnSideFacets=n,this.collectOnRearFacets=r}static create(t,e,i,s,n,r){return new Cn(void 0===t?$.unitZ():t.clone(),void 0===e?W.createRadians(Q.smallAngleRadians):e.clone(),Q.resolveValue(i,!0),Q.resolveValue(s,!0),Q.resolveValue(n,!0),Q.resolveValue(r,!0))}get collectAll(){return!0===this.collectOnForwardFacets&&!0===this.collectOnSideFacets&&!0===this.collectOnRearFacets}collectFromThisFacetNormal(t){return void 0!==t&&(t.angleFromPerpendicular(this.vectorToEye).isMagnitudeLessThanOrEqual(this.sideAngle)?this.collectOnSideFacets:t.dotProduct(this.vectorToEye)>0?this.collectOnForwardFacets:this.collectOnRearFacets)}}class Tn{constructor(t=W.createDegrees(25),e=W.createDegrees(60),i=W.createDegrees(90)){this.smoothSingleAngleBetweenNormals=t.clone(),this.smoothAccumulatedAngleBetweenNormals=e.clone(),this.chamferAngleBetweenNormals=i.clone()}static create(t=W.createDegrees(25),e=W.createDegrees(60),i=W.createDegrees(120)){const s=t.clone(),n=e.clone(),r=i.clone();return s.degrees<1&&n.setDegrees(1),n.degrees<1&&n.setDegrees(1),n.degrees<15&&n.setDegrees(15),new Tn(s,n,r)}}!function(t){t[t.SelectNone=0]="SelectNone",t[t.SelectAny=1]="SelectAny",t[t.SelectAll=2]="SelectAll",t[t.SelectOneByParity=3]="SelectOneByParity"}(B||(B={}));class Fn{static visitorToLoop(t){const e=Me.createPoints(t.point.getPoint3dArray());return hi.create(e)}static indexedPolyfaceToLoops(t){const e=ri.create(),i=t.createVisitor(1);for(;i.moveToNextFacet();){const t=Fn.visitorToLoop(i);e.tryAddChild(t)}return e}static sumFacetAreas(t,e){let i=0;if(void 0!==t){if(t instanceof Ki)return Fn.sumFacetAreas(t.createVisitor(1),e);let s;for(void 0!==e&&(s=e.normalize()),t.reset();t.moveToNextFacet();){const e=Ur.areaNormal(t.point.getPoint3dArray());i+=s?e.dotProduct(s):e.magnitude()}}return i}static sumTetrahedralVolumes(t,e){let i=0;if(t instanceof Ki)return Fn.sumTetrahedralVolumes(t.createVisitor(0),e);let s=e;const n=j.create(),r=j.create(),o=j.create();for(t.reset();t.moveToNextFacet();){void 0===s&&(s=t.point.getPoint3dAtUncheckedPointIndex(0)),t.point.getPoint3dAtUncheckedPointIndex(0,n);for(let e=1;e+1<t.point.length;e++)t.point.getPoint3dAtUncheckedPointIndex(e,r),t.point.getPoint3dAtUncheckedPointIndex(e+1,o),i+=s.tripleProductToPoints(n,r,o)}return i/6}static sumVolumeBetweenFacetsAndPlane(t,e){if(t instanceof Ki)return Fn.sumVolumeBetweenFacetsAndPlane(t.createVisitor(0),e);const i=j.create(),s=j.create(),n=j.create(),r=$.create(),o=e.getNormalRef();let a,c,l,h,d,u=0;const f=Ei.create(void 0,!0),g=Ei.create(void 0,!0),p=Xt.createZero(),m=e.getProjectionToPlane();for(t.reset();t.moveToNextFacet();){t.point.getPoint3dAtUncheckedPointIndex(0,i),a=e.altitude(i),d=0;for(let f=1;f+1<t.point.length;f++)t.point.getPoint3dAtUncheckedPointIndex(f,s),t.point.getPoint3dAtUncheckedPointIndex(f+1,n),i.crossProductToPoints(s,n,r),c=e.altitude(s),l=e.altitude(n),h=o.dotProduct(r),d+=h,u+=h*(a+c+l);p.setZero(),t.point.multiplyTransformInPlace(m),Ur.addSecondMomentAreaProducts(t.point,i,p),d>0?f.accumulateProductsFromOrigin(i,p,1):g.accumulateProductsFromOrigin(i,p,1)}return f.shiftOriginAndSumsToCentroidOfSums(),g.shiftOriginAndSumsToCentroidOfSums(),{volume:u/6,positiveProjectedFacetAreaMoments:Ei.inertiaProductsToPrincipalAxes(f.origin,f.sums),negativeProjectedFacetAreaMoments:Ei.inertiaProductsToPrincipalAxes(g.origin,g.sums)}}static sumFacetSecondAreaMomentProducts(t,e){if(t instanceof Ki)return Fn.sumFacetSecondAreaMomentProducts(t.createVisitor(0),e);const i=Xt.createZero();for(t.reset();t.moveToNextFacet();)Ur.addSecondMomentAreaProducts(t.point,e,i);return i}static sumFacetSecondVolumeMomentProducts(t,e){if(t instanceof Ki)return Fn.sumFacetSecondVolumeMomentProducts(t.createVisitor(0),e);const i=Xt.createZero();for(t.reset();t.moveToNextFacet();)Ur.addSecondMomentVolumeProducts(t.point,e,i);return i}static computePrincipalAreaMoments(t){const e=t.data.getPoint(0);if(!e)return;const i=Fn.sumFacetSecondAreaMomentProducts(t,e);return Ei.inertiaProductsToPrincipalAxes(e,i)}static computePrincipalVolumeMoments(t){const e=t.data.getPoint(0);if(!e)return;const i=Fn.sumFacetSecondVolumeMomentProducts(t,e);return Ei.inertiaProductsToPrincipalAxes(e,i)}static areFacetsConvex(t){if(t instanceof Ki)return this.areFacetsConvex(t.createVisitor(0));for(t.setNumWrap(0),t.reset();t.moveToNextFacet();)if(t.pointCount>3&&!Ur.isConvex(t.point))return!1;return!0}static dihedralAngleSummary(t,e=!1){const i=new an,s=t.createVisitor(1);s.reset();const n=[];let r=0;for(;s.moveToNextFacet();){const t=s.pointCount-1,e=Ur.centroidAreaNormal(s.point);if(void 0===e)return-2;n.push(e);for(let e=0;e<t;e++)i.addEdge(s.clientPointIndex(e),s.clientPointIndex(e+1),r);r++}const o=[],a=[];if(i.sortAndCollectClusters(a,e?void 0:o,void 0,o),o.length>0)return-2;let c=0,l=0,h=0;const d=$.create();for(const e of a){const i=e[0],s=e[1];if(i instanceof on&&s instanceof on&&t.data.point.vectorIndexIndex(i.vertexIndexA,i.vertexIndexB,d)){const t=n[i.facetIndex].direction.signedAngleTo(n[s.facetIndex].direction,d);t.isAlmostZero?l++:t.radians>0?c++:h++}}return c>0&&0===h?1:h>0&&0===c?-1:l>0&&0===c&&0===h?0:-2}static isConvexByDihedralAngleCount(t,e=!1){return this.dihedralAngleSummary(t,e)>0}static isPolyfaceManifold(t,e=!1){const i=new an,s=t.createVisitor(1);for(s.reset();s.moveToNextFacet();){const t=s.pointCount-1;for(let e=0;e<t;e++)i.addEdge(s.clientPointIndex(e),s.clientPointIndex(e+1),s.currentReadIndex())}const n=[];return i.sortAndCollectClusters(void 0,e?void 0:n,void 0,n),0===n.length}static isPolyfaceClosedByEdgePairing(t){return this.isPolyfaceManifold(t,!1)}static announceBoundaryEdges(t,e,i=!0,s=!0,n=!0){if(void 0===t||!i&&!s&&!n)return;const r=new an,o=t instanceof Ki?t.createVisitor(1):t;for(o.setNumWrap(1),o.reset();o.moveToNextFacet();){const t=o.pointCount-1;for(let e=0;e<t;e++)r.addEdge(o.clientPointIndex(e),o.clientPointIndex(e+1),o.currentReadIndex())}const a=[];if(r.sortAndCollectClusters(void 0,i?a:void 0,n?a:void 0,s?a:void 0),0===a.length)return;const c=o.clientPolyface(),l=j.create(),h=j.create();for(const t of a){const i=t instanceof on?t:t[0],s=i.vertexIndexA,n=i.vertexIndexB;c.data.getPoint(s,l)&&c.data.getPoint(n,h)&&e(l,h,s,n,i.facetIndex)}}static boundaryEdges(t,e=!0,i=!0,s=!0){const n=new ri;if(Fn.announceBoundaryEdges(t,((t,e,i,s,r)=>{n.tryAddChild(Ce.create(t,e))}),e,i,s),0!==n.children.length)return n}static collectBoundaryEdges(t,e=!0,i=!0,s=!0){const n=new ss(Q.smallMetricDistance,Q.smallMetricDistance);return Fn.announceBoundaryEdges(t,((t,e)=>n.captureCurve(Ce.create(t,e))),e,i,s),n.grabResult(!0)}static createIndexedEdges(t){if(t instanceof Ki)return this.createIndexedEdges(t.createVisitor(1));const e=new an;for(t.reset();t.moveToNextFacet();){const i=t.pointCount-1;for(let s=0;s<i;s++)e.addEdge(t.clientPointIndex(s),t.clientPointIndex(s+1),t.currentReadIndex())}return e}static announceSilhouetteEdges(t,e,i,s=W.createSmallAngle()){if(t instanceof Ki)return this.announceSilhouetteEdges(t.createVisitor(1),e,i,s);const n=t.clientPolyface();if(void 0===n)return;t.setNumWrap(1);const r=[];this.createIndexedEdges(t).sortAndCollectClusters(r);const o=s.radians<0?-s.radians:s.radians,a=j.create(),c=j.create(),l=$.create(),h=e=>{if(!Fn.computeFacetUnitNormal(t,e,l))return{isSideFace:!1,perpAngle:0};const s=l.radiansFromPerpendicular(i);return{isSideFace:Math.abs(s)<=o,perpAngle:s}};for(const t of r){if(!Array.isArray(t)||2!==t.length)continue;const i=t[0].vertexIndexA,s=t[0].vertexIndexB;if(!n.data.getPoint(i,a)||!n.data.getPoint(s,c))continue;const r=h(t[0].facetIndex);if(r.isSideFace){e(a,c,i,s,t[0].facetIndex);continue}const o=h(t[1].facetIndex);o.isSideFace?e(c,a,s,i,t[1].facetIndex):r.perpAngle*o.perpAngle<0&&e(a,c,i,s,t[0].facetIndex)}}static collectSilhouetteEdges(t,e,i=W.createSmallAngle()){const s=new ss(Q.smallMetricDistance,Q.smallMetricDistance);return Fn.announceSilhouetteEdges(t,((t,e)=>s.captureCurve(Ce.create(t,e))),e,i),s.grabResult(!0)}static announceSweepLinestringToConvexPolyfaceXY(t,e,i){const s=yn.create(t);if(s){const t=e.createVisitor(0);for(t.reset();t.moveToNextFacet();)s.projectToPolygon(t.point,i,e,t.currentReadIndex())}}static setAsyncWorkLimit(t){const e=this._asyncWorkLimit;return this._asyncWorkLimit=t,e}static get asyncWorkLimit(){return this._asyncWorkLimit}static async continueAnnounceSweepLinestringToConvexPolyfaceXY(t,e,i){let s=0;for(;s<this.asyncWorkLimit&&e.moveToNextFacet();)s+=t.projectToPolygon(e.point,i,e.clientPolyface(),e.currentReadIndex());return s}static async asyncAnnounceSweepLinestringToConvexPolyfaceXY(t,e,i){const s=yn.create(t);this.awaitBlockCount=0;let n=0;if(s){const t=e.createVisitor(0);let r;for(;0<(r=await Promise.resolve(Fn.continueAnnounceSweepLinestringToConvexPolyfaceXY(s,t,i)));)n+=r,this.awaitBlockCount++}return n}static partitionFacetIndicesByVertexConnectedComponent(t){if(t instanceof Ki)return this.partitionFacetIndicesByVertexConnectedComponent(t.createVisitor(0));const e=new hs(this.visitorClientPointCount(t));for(t.reset();t.moveToNextFacet();){const i=t.pointIndex[0];for(const s of t.pointIndex)e.mergeSubsets(i,s)}const i=e.collectRootIndices(),s=[],n=i.length;for(let t=0;t<n;t++)s.push([]);for(t.reset();t.moveToNextFacet();){const r=t.pointIndex[0],o=e.findRoot(r);for(let e=0;e<n;e++)if(i[e]===o){s[e].push(t.currentReadIndex());break}}return s}static partitionFacetIndicesByVisibilityVector(t,e,i){if(t instanceof Ki)return this.partitionFacetIndicesByVisibilityVector(t.createVisitor(0),e,i);const s=[];for(let t=0;t<3;t++)s.push([]);const n=s[0],r=s[1],o=s[2],a=Math.max(i.radians,1e-8);for(t.reset();t.moveToNextFacet();){const i=Ur.areaNormalGo(t.point),s=t.currentReadIndex();if(i){const t=i.angleFromPerpendicular(e);Math.abs(t.radians)<a?o.push(s):i.dotProduct(e)<0?r.push(s):n.push(s)}}return s}static boundaryOfVisibleSubset(t,e,i,s=W.createDegrees(.001)){const n=this.partitionFacetIndicesByVisibilityVector(t,i,s);if(0===n[e].length)return;const r=Ji.createSubsetVisitor(t,n[e],1);return this.boundaryEdges(r,!0,!1,!1)}static announceBoundaryChainsAsLineString3d(t,e){const i=new ss(Q.smallMetricDistance);Fn.announceBoundaryEdges(t,((t,e,s,n)=>i.captureCurve(Ce.create(t,e))),!0,!1,!1),i.announceChainsAsLineString3d(e)}static cloneWithMaximalPlanarFacets(t,i){if(t instanceof Ki)return this.cloneWithMaximalPlanarFacets(t.createVisitor(0),i);const s=Fn.visitorClientFacetCount(t),n=Fn.collectEdgesByDihedralAngle(t,i),r=Fn.partitionFacetIndicesBySortableEdgeClusters(n,s),o=ar.create(),a=t,c=[],l=[],h=$.createZero();for(const t of r)if(1===t.length)a.moveToReadIndex(t[0])&&o.addFacetFromVisitor(a);else if(t.length>1){const e=$.createZero(),i=j.createZero();a.moveToReadIndex(t[0])&&a.point.getPoint3dAtCheckedPointIndex(0,i);for(const i of t)a.moveToReadIndex(i)&&Ur.areaNormalGo(a.point,h)&&e.addInPlace(h);l.push(bt.createCapture(i,e)),c.push(t)}const d=Fn.clonePartitions(t,c);e(c.length===l.length),e(c.length===d.length);const u=pt.createIdentity(),f=pt.createIdentity();for(let t=0;t<d.length;++t){const e=d[t],i=[],s=[];Fn.announceBoundaryEdges(e,((t,e,n,r)=>{i.push(Ce.create(t,e)),s.push([t.clone(),e.clone()])}),!0,!1,!1);const n=as.collectChains(i,1e-4,1e-4);if(n&&(l[t].toRigidZFrame(u),u.inverse(f))){f.multiplyPoint3dArrayArrayInPlace(s);const t=!(n instanceof hi),e=Hs.formGraphFromChains(s,t,b.BOUNDARY_EDGE);if(e){tn.collectConnectedComponentsWithExteriorParityMasks(e,new $s(b.BOUNDARY_EDGE),b.EXTERIOR);const t=ar.graphToPolyface(e);o.addIndexedPolyface(t,!1,u)}}}return o.claimPolyface(!0)}static fillSimpleHoles(t,e,i){if(t instanceof Ki)return this.fillSimpleHoles(t.createVisitor(0),e,i);const s=ar.create(),n=[];Fn.announceBoundaryChainsAsLineString3d(t,(t=>{t.reverseInPlace(),n.push(t)}));for(const t of n){const n=t.points;let r=!1;t.isPhysicallyClosed?(void 0!==e.maxEdgesAroundHole&&n.length>e.maxEdgesAroundHole||void 0!==e.maxPerimeter&&ue.sumEdgeLengths(n,!1)>e.maxPerimeter||void 0!==e.upVector&&Ur.sumTriangleAreasPerpendicularToUpVector(n,e.upVector)<=0)&&(r=!0):r=!0,!r&&en.triangulateSimplestSpaceLoop(n,((t,e)=>{for(const t of e)s.addPolygon(t)}))||(r=!0),r&&void 0!==i&&i.push(t)}if(void 0!==e.includeOriginalMesh&&e.includeOriginalMesh)for(t.reset();t.moveToNextFacet();)s.addFacetFromVisitor(t);return s.claimPolyface(!0)}static clonePartitions(t,e){if(t instanceof Ki)return this.clonePartitions(t.createVisitor(0),e);t.setNumWrap(0);const i=[],s=Ie.createForFacets();s.needNormals=void 0!==t.normal,s.needParams=void 0!==t.param,s.needColors=void 0!==t.color,s.needTwoSided=t.twoSided;for(const n of e){const e=ar.create(s);t.reset();for(const i of n)t.moveToReadIndex(i),e.addFacetFromVisitor(t);i.push(e.claimPolyface(!0))}return i}static cloneFiltered(t,e){if(t instanceof Ki)return this.cloneFiltered(t.createVisitor(0),e);t.setNumWrap(0);const i=Ie.createForFacets();i.needNormals=void 0!==t.normal,i.needParams=void 0!==t.param,i.needColors=void 0!==t.color,i.needTwoSided=t.twoSided;const s=ar.create(i);for(t.reset();t.moveToNextFacet();)e(t)&&s.addFacetFromVisitor(t);return s.claimPolyface(!0)}static cloneWithDanglingEdgesRemoved(t){if(t instanceof Ki)return this.cloneWithDanglingEdgesRemoved(t.createVisitor(0));const e=Ie.createForFacets();e.needNormals=void 0!==t.normal,e.needParams=void 0!==t.param,e.needColors=void 0!==t.color,e.needTwoSided=t.twoSided;const i=ar.create(e),s=(t,e)=>{const i=t.length;for(let s=0;s<i;++s){let n=1,r=s,o=s;for(;n+2<=i;){const s=0===r?i-1:r-1,a=o===i-1?0:o+1;if(e[t[s]]!==e[t[a]])break;r=s,o=a,n+=2}if(n>1)return r<o?t.splice(r,n-1):r>o&&(t.splice(r),t.splice(0,o)),!0}return!1};for(t.setNumWrap(0),t.reset();t.moveToNextFacet();){const e=[...Array(t.pointIndex.length).keys()];for(;s(e,t.pointIndex););i.addFacetFromIndexedVisitor(t,e)}return i.claimPolyface(!0)}static visitorClientPointCount(t){if(t instanceof Ki)return t.data.point.length;const e=t.clientPolyface();if(void 0!==e)return e.data.point.length;const i=t.currentReadIndex();t.reset();let s=-1;for(;t.moveToNextFacet();)for(const e of t.pointIndex)e>s&&(s=e);return t.moveToReadIndex(i),s+1}static visitorClientFacetCount(t){if(t instanceof Ki){if(void 0!==t.facetCount)return t.facetCount;t=t.createVisitor(0)}if(t.getVisitableFacetCount)return t.getVisitableFacetCount();const e=t.clientPolyface();if(void 0!==e&&void 0!==e.facetCount)return e.facetCount;const i=t.currentReadIndex();let s=0;for(t.reset();t.moveToNextFacet();)++s;return t.moveToReadIndex(i),s}static partitionFacetIndicesBySortableEdgeClusters(t,e){const i=new hs(e);for(const e of t)if(e instanceof on);else{const t=e[0];for(let s=1;s<e.length;s++)i.mergeSubsets(t.facetIndex,e[s].facetIndex)}const s=i.collectRootIndices(),n=[],r=s.length;for(let t=0;t<r;t++)n.push([]);for(let t=0;t<e;t++){const e=i.findRoot(t);for(let i=0;i<r;i++)if(s[i]===e){n[i].push(t);break}}return n}static partitionFacetIndicesByEdgeConnectedComponent(t,e=!1){if(t instanceof Ki)return this.partitionFacetIndicesByEdgeConnectedComponent(t.createVisitor(0),e);t.setNumWrap(1);const i=new an;t.reset();let s=0;for(;t.moveToNextFacet();){const n=t.pointCount-1;s++;for(let s=0;s<n;s++)e&&t.edgeVisible[s]||i.addEdge(t.clientPointIndex(s),t.clientPointIndex(s+1),t.currentReadIndex())}const n=[];return i.sortAndCollectClusters(n,n,n,n),this.partitionFacetIndicesBySortableEdgeClusters(n,s)}static sweepLineStringToFacetsXYReturnSweptFacets(t,e){const i=ar.create();return this.announceSweepLinestringToConvexPolyfaceXY(t,e,((t,e,s,n,r)=>{4===r.length?i.addQuadFacet(r):3===r.length&&i.addTriangleFacet(r)})),i.claimPolyface(!0)}static sweepLinestringToFacetsXYreturnSweptFacets(t,e){return this.sweepLineStringToFacetsXYReturnSweptFacets(t,e)}static sweepLineStringToFacets(t,e,i){let s,n=[];void 0===i&&(i=Cn.create($.unitZ(),W.createRadians(Q.smallAngleRadians),!0,!0,!0,!0)),i.assembleChains&&(s=Qs.create());const r=Pn.create(t,i.vectorToEye);if(r){let t;t=e instanceof Ki?e.createVisitor(0):e;const o=$.createZero();for(t.reset();t.moveToNextFacet();)i.collectFromThisFacetNormal(Ur.areaNormalGo(t.point,o))&&r.processPolygon(t.point.getArray(),((t,e)=>{void 0!==s?s.addSegment(t,e):n.push(Ce.create(t,e))}));void 0!==s&&(s.clusterAndMergeVerticesXYZ(),n=s.collectMaximalChains())}return n}static sweepLineStringToFacetsXY(t,e,i){const s=Qs.create(),n=$.create(0,0,1),r=ut.create();let o,a;o=e instanceof Ki?e.createVisitor(0):e,a=Array.isArray(t)?new ce(t):t;for(let t=1;t<a.length;t++){const e=a.getPoint3dAtUncheckedPointIndex(t-1),c=a.getPoint3dAtUncheckedPointIndex(t),l=vn.createPointPointSweep(e,c,n);void 0!==l&&(ut.createNull(r),r.extendPoint(e),r.extendPoint(c),i.searchRange2d(r,((t,e)=>(o.moveToReadIndex(e)&&l.processPolygon(o.point,((t,e)=>s.addSegment(t,e))),!0))))}return s.clusterAndMergeVerticesXYZ(),s.collectMaximalChains()}static sweepLinestringToFacetsXYReturnLines(t,e){const i=Cn.create($.unitZ(),W.createSmallAngle(),!1,!0,!0,!0);return Fn.sweepLineStringToFacets(t,e,i)}static sweepLinestringToFacetsXYReturnChains(t,e){const i=Cn.create($.unitZ(),W.createSmallAngle(),!0,!0,!0,!0);return Fn.sweepLineStringToFacets(t,e,i)}static async asyncSweepLinestringToFacetsXYReturnChains(t,e){const i=Qs.create();return await Promise.resolve(this.asyncAnnounceSweepLinestringToConvexPolyfaceXY(t,e,((t,e,s,n,r,o,a)=>{i.addSegment(r[o],r[a])}))),i.clusterAndMergeVerticesXYZ(),i.collectMaximalChains()}static collectRangeLengthData(t){if(t instanceof Ki)return this.collectRangeLengthData(t.createVisitor(0));const e=new wn;for(t.reset();t.moveToNextFacet();)e.accumulateGrowableXYZArrayRange(t.point);return e}static cloneWithTVertexFixup(t){const e=t.createVisitor(1),i=t.createVisitor(0),s=In.create(t.data.point,30),n=ar.create(),r=ut.createNull(),o=j.create(),a=j.create(),c=j.create(),l=Ce.create(o,a);for(e.reset();e.moveToNextFacet();){i.clearArrays();for(let n=0;n+1<e.point.length;n++){let h;if(e.point.getPoint3dAtUncheckedPointIndex(n,o),e.point.getPoint3dAtUncheckedPointIndex(n+1,a),i.pushDataFrom(e,n),r.setNull(),Ce.create(o,a,l),r.extend(o),r.extend(a),r.ensureMinLengths(Q.smallMetricDistance),s.announcePointsInRange(r,((e,i,s,n)=>{t.data.point.getPoint3dAtUncheckedPointIndex(e,c);const r=l.closestPoint(c,!1);return void 0!==r&&r.fraction>0&&r.fraction<1&&!r.point.isAlmostEqual(o)&&!r.point.isAlmostEqual(a)&&c.isAlmostEqual(r.point)&&(void 0===h&&(h=[]),r.a=e,h.push(r)),!0})),void 0!==h){h.sort(((t,e)=>t.fraction-e.fraction));for(const t of h)i.pushInterpolatedDataFrom(e,n,t.fraction,n+1)}}n.addFacetFromGrowableArrays(i.point,i.normal,i.param,i.color,i.edgeVisible)}return n.claimPolyface()}static compareFacetIndexAndVertexIndices(t,e){if(t.length!==e.length)return t.length-e.length;for(let i=1;i<t.length;i++)if(t[i]!==e[i])return t[i]-e[i];return 0}static announceDuplicateFacetIndices(t,e){const i=t.createVisitor(0),s=[];for(i.reset();i.moveToNextFacet();){const t=[i.currentReadIndex()],e=i.pointIndex,n=e.length;let r=0;for(let t=1;t<i.pointIndex.length;t++)e[t]<e[r]&&(r=t);if(e[(r+1)%n]<e[(r+n-1)%n])for(let i=0;i<n;i++)t.push(e[(r+i)%n]);else for(let i=0;i<n;i++)t.push(e[(r+n-i)%n]);s.push(t)}let n,r;s.sort(((t,e)=>this.compareFacetIndexAndVertexIndices(t,e)));const o=s.length,a=[];for(n=0;n<o;n=r){for(r=n+1,a.length=0,a.push(s[n][0]);r<o&&0===this.compareFacetIndexAndVertexIndices(s[n],s[r]);)a.push(s[r][0]),r++;e(a)}}static collectDuplicateFacetIndices(t,e=!1){const i=[];return this.announceDuplicateFacetIndices(t,(t=>{(e||t.length>1)&&i.push(t.slice())})),i}static cloneByFacetDuplication(t,e,i){const s=ar.create(),n=t.createVisitor(0);return this.announceDuplicateFacetIndices(t,(t=>{let r=0;1===t.length?e&&(r=1):t.length>1&&(i===B.SelectAny?r=1:i===B.SelectAll?r=t.length:i===B.SelectOneByParity&&(r=1&~t.length?0:1));for(let e=0;e<r;e++)n.moveToReadIndex(t[e]),s.addFacetFromVisitor(n)})),s.claimPolyface()}static cloneWithColinearEdgeFixup(t){const e=t.createVisitor(2),i=t.createVisitor(0),s=ar.create(),n=$.create(),r=$.create(),o=t.data.point.length,a=new Int32Array(o);for(e.reset();e.moveToNextFacet();)for(let t=0;t+2<e.point.length;t++){e.point.vectorIndexIndex(t,t+1,n),e.point.vectorIndexIndex(t+1,t+2,r);const i=e.clientPointIndex(t+1);a[i]>=0&&(n.angleTo(r).isAlmostZero?a[i]++:a[i]=-1)}for(e.reset();e.moveToNextFacet();){i.clearArrays();for(let t=0;t+2<e.point.length;t++)a[e.clientPointIndex(t)]<0&&i.pushDataFrom(e,t);i.point.length>2&&s.addFacetFromGrowableArrays(i.point,i.normal,i.param,i.color,i.edgeVisible)}return s.claimPolyface()}static setEdgeVisibility(t,e,i){for(const s of e)if(s instanceof on)this.setSingleEdgeVisibility(t,s.facetIndex,s.vertexIndexA,i);else if(Array.isArray(s))for(const e of s)this.setSingleEdgeVisibility(t,e.facetIndex,e.vertexIndexA,i)}static setSingleEdgeVisibility(t,e,i,s){const n=t.data,r=t.facetIndex0(e),o=t.facetIndex1(e);for(let t=r;t<o;t++)n.pointIndex[t]===i&&(n.edgeVisible[t]=s)}static getSingleEdgeVisibility(t,e,i){const s=t.data,n=t.facetIndex0(e),r=t.facetIndex1(e);for(let t=n;t<r;t++)if(s.pointIndex[t]===i)return s.edgeVisible[t]}static collectEdgesByDihedralAngle(t,e,i=!1){if(t instanceof Ki)return this.collectEdgesByDihedralAngle(t.createVisitor(1),e,i);t.setNumWrap(1);const s=[];this.createIndexedEdges(t).sortAndCollectClusters(s),(void 0===e||e.radians<0)&&(e=W.createRadians(Q.smallAngleRadians));const n=[],r=$.create(),o=$.create();for(const a of s)if(Array.isArray(a)&&2===a.length){const s=a[0],c=a[1];if(void 0!==Fn.computeFacetUnitNormal(t,s.facetIndex,r)&&void 0!==Fn.computeFacetUnitNormal(t,c.facetIndex,o)){const t=r.smallerUnorientedAngleTo(o);i?t.radians>e.radians&&n.push(a):t.radians<=e.radians&&n.push(a)}}return n}static markPairedEdgesInvisible(t,e){const i=t.createVisitor(1),s=[],n=[];if(this.createIndexedEdges(i).sortAndCollectClusters(s,n,n,n),this.markAllEdgeVisibility(t,!1),this.setEdgeVisibility(t,n,!0),void 0!==e){const n=$.create(),r=$.create();for(const o of s)if(Array.isArray(o)&&2===o.length){const s=o[0],a=o[1];void 0!==Fn.computeFacetUnitNormal(i,s.facetIndex,n)&&void 0!==Fn.computeFacetUnitNormal(i,a.facetIndex,r)&&n.smallerUnorientedAngleTo(r).radians>e.radians&&(this.setSingleEdgeVisibility(t,s.facetIndex,s.vertexIndexA,!0),this.setSingleEdgeVisibility(t,a.facetIndex,a.vertexIndexA,!0))}}}static computeFacetUnitNormal(t,e,i){if(i||(i=$.create()),t.moveToReadIndex(e)&&Ur.unitNormal(t.point,i))return i}static markAllEdgeVisibility(t,e){const i=t.data;for(let t=0;t<i.edgeVisible.length;t++)i.edgeVisible[t]=e}static convertToHalfEdgeGraph(t){const e=new Ks,i=t.createVisitor(0);for(i.reset();i.moveToNextFacet();)e.insertLoop(i.pointIndex);const s=e.graph,n=j.create();return s.announceNodes(((e,i)=>{const s=i.i;return t.data.getPoint(s,n),i.setXYZ(n),!0})),s}static reorientVertexOrderAroundFacetsForConsistentOrientation(t){return ln.doFixup(t)}static buildPerFaceNormals(t){un.buildPerFaceNormals(t)}static buildAverageNormals(t,e=W.createDegrees(31)){un.buildFastAverageNormals(t,e)}static cloneOffset(t,e,i=Tn.create()){const s=Ie.createForFacets(),n=ar.create(s);return _n.buildOffsetMeshWithEdgeChamfers(t,n,e,i),n.claimPolyface()}static intersectRay3d(t,e,i){if(t instanceof Ki)return Fn.intersectRay3d(t.createVisitor(0),e,i);let s;for(t.setNumWrap(0);t.moveToNextFacet();){const n=t.pointCount,r=t.point;if(3===n){const n=this._workTriangle=ls.create(r.getPoint3dAtUncheckedPointIndex(0),r.getPoint3dAtUncheckedPointIndex(1),r.getPoint3dAtUncheckedPointIndex(2),this._workTriangle),o=this._workTriDetail=n.intersectRay3d(e,this._workTriDetail);n.snapLocationToEdge(o,i?.distanceTolerance,i?.parameterTolerance),s=this._workFacetDetail3=sn.create(t.currentReadIndex(),o,this._workFacetDetail3)}else{const o=this._workPolyDetail=Ur.intersectRay3d(r,e,i?.distanceTolerance,this._workPolyDetail);s=Ur.isConvex(r)?this._workFacetDetailC=rn.create(t.currentReadIndex(),n,o,this._workFacetDetailC):this._workFacetDetailNC=nn.create(t.currentReadIndex(),n,o,this._workFacetDetailNC)}if(s.isInsideOrOn){if(i?.needNormal&&t.normal&&s.getNormal(t.normal,r,i?.distanceTolerance),i?.needParam&&t.param&&s.getParam(t.param,r,i?.distanceTolerance),i?.needColor&&t.color&&s.getColor(t.color,r,i?.distanceTolerance),i?.needBarycentricCoordinates&&s.getBarycentricCoordinates(r,i?.distanceTolerance),i?.acceptIntersection&&!i.acceptIntersection(s,t))continue;return s}}}}Fn._asyncWorkLimit=1e6,Fn.awaitBlockCount=0;class kn{constructor(t){this._planes=t||[]}toJSON(){const t=[];for(const e of this._planes)t.push(e.toJSON());return t}static fromJSON(t,e){if((e=e||new kn)._planes.length=0,!Array.isArray(t))return e;for(const i of t){const t=Wr.fromJSON(i);t&&e._planes.push(t)}return e}isAlmostEqual(t){if(this._planes.length!==t._planes.length)return!1;for(let e=0;e<this._planes.length;e++)if(!this._planes[e].isAlmostEqual(t._planes[e]))return!1;return!0}static createPlanes(t,e){e=e||new kn;for(const i of t)if(i instanceof Wr)e._planes.push(i);else if(i instanceof _t){const t=Wr.createPlane(i);e._planes.push(t)}return e}static createRange3dPlanes(t,e=!0,i=!0,s=!0,n=!0,r=!0,o=!0){const a=kn.createEmpty();return e&&a.planes.push(Wr.createNormalAndPointXYZXYZ(1,0,0,t.low.x,0,0)),i&&a.planes.push(Wr.createNormalAndPointXYZXYZ(-1,0,0,t.high.x,0,0)),s&&a.planes.push(Wr.createNormalAndPointXYZXYZ(0,1,0,0,t.low.y,0)),n&&a.planes.push(Wr.createNormalAndPointXYZXYZ(0,-1,0,0,t.high.y,0)),r&&a.planes.push(Wr.createNormalAndPointXYZXYZ(0,0,1,0,0,t.low.z)),o&&a.planes.push(Wr.createNormalAndPointXYZXYZ(0,0,-1,0,0,t.high.z)),a}static createEmpty(t){return t?(t._planes.length=0,t):new kn}negateAllPlanes(){for(const t of this._planes)t.negateInPlace()}static createXYBox(t,e,i,s,n){(n=n||new kn)._planes.length=0;const r=Wr.createNormalAndDistance($.create(-1,0,0),-i,!1,!0),o=Wr.createNormalAndDistance($.create(1,0,0),t,!1,!0),a=Wr.createNormalAndDistance($.create(0,-1,0),-s,!1,!0),c=Wr.createNormalAndDistance($.create(0,1,0),e,!1,!0);return r&&o&&a&&c&&n._planes.push(r,o,a,c),n}static createXYPolyLine(t,e,i,s){(s=s||new kn)._planes.length=0;for(let n=0;n+1<t.length;n++){const r=$.createStartEnd(t[n],t[n+1]).unitPerpendicularXY();if(r.z=0,i||r.scaleInPlace(-1),r.normalize()){const i=void 0!==e&&e[n],o=Wr.createNormalAndPoint(r,t[n],i,i);o&&s._planes.push(o)}}return s}static createXYPolyLineInsideLeft(t,e){(e=e||new kn)._planes.length=0;for(let i=0;i+1<t.length;i++){const s=$.createStartEnd(t[i],t[i+1]).unitPerpendicularXY();if(s.z=0,s.normalize()){const n=Wr.createNormalAndPoint(s,t[i],!1,!1);n&&e._planes.push(n)}}return e}static setPlaneAndXYLoopCCW(t,e,i){const s=t.length-1,n=t.length;let r,o,a,c,l=t.getXAtUncheckedPointIndex(s),h=t.getYAtUncheckedPointIndex(s);i._planes.length=0;const d=t.getZAtUncheckedPointIndex(s),u=t.crossProductIndexIndexIndex(0,2,1);if(Wr.createNormalAndPointXYZXYZ(u.x,u.y,u.z,l,h,d,!1,!1,e),u.normalizeInPlace())for(let e=0;e<n;e++,l=r,h=o){r=t.getXAtUncheckedPointIndex(e),o=t.getYAtUncheckedPointIndex(e),a=-(o-h),c=r-l;const s=Wr.createNormalAndPointXYZXYZ(a,c,0,r,o,d);s&&i._planes.push(s)}}clone(t){(t=t||new kn)._planes.length=0;for(const e of this._planes)t._planes.push(e.clone());return t}get planes(){return this._planes}hasIntersectionWithRay(t,e,i=Q.smallMetricDistance){let s=-Q.largeCoordinateResult,n=Q.largeCoordinateResult;e&&e.setNull();for(const e of this._planes){const r=e.velocity(t.direction),o=e.altitude(t.origin);if(Math.abs(r)<=1e-13){if(o<-i)return!1}else{const t=-o/r;r<0?t<n&&(n=t):t>s&&(s=t)}}return!(n<s||(e&&(e.extendX(s),e.extendX(n)),0))}multiplyPlanesByMatrix4d(t,e=!0,i=!0){if(e){const e=t.createInverse();return!!e&&this.multiplyPlanesByMatrix4d(e,!1,i)}for(const e of this._planes)e.multiplyPlaneByMatrix4d(t,!1,i);return!0}isPointInside(t){for(const e of this._planes)if(!e.isPointInside(t))return!1;return!0}isPointOnOrInside(t,e=Q.smallMetricDistance){const i=Math.abs(e);for(const s of this._planes)if(!s.isPointOnOrInside(t,s.interior?i:e))return!1;return!0}isSphereInside(t,e){const i=Math.abs(e)+Q.smallMetricDistance;for(const e of this._planes)if(!e.isPointOnOrInside(t,i))return!1;return!0}announceClippedSegmentIntervals(t,e,i,s,n){let r;if(e<t)return!1;for(const n of this._planes){const o=-n.altitude(i),a=-n.altitude(s);if(r=Q.conditionalDivideFraction(-o,a-o),void 0===r){if(o>0)return!1}else if(a>o){if(r<t)return!1;r<e&&(e=r)}else if(o>a){if(r>e)return!1;r>t&&(t=r)}else if(o>0)return!1}return e>=t&&(n&&n(t,e),!0)}announceClippedArcIntervals(t,e){const i=kn._clipArcFractionArray;i.clear();for(const e of this.planes)e.appendIntersectionRadians(t,i);return t.sweep.radiansArrayToPositivePeriodicFractions(i),Rs.selectIntervals01(t,i,this,e)}clipUnboundedSegment(t,e,i){return this.announceClippedSegmentIntervals(-Number.MAX_VALUE,Number.MAX_VALUE,t,e,i)}transformInPlace(t){for(const e of this._planes)e.transformInPlace(t)}clipConvexPolygonInPlace(t,e,i=Q.smallMetricDistance){for(const s of this._planes)if(s.clipConvexPolygonInPlace(t,e,!0,i),t.length<3)return}clipInsidePushOutside(t,e,i){const s=ft.createNull();let n=i.grabFromCache(),r=i.grabFromCache(),o=i.grabFromCache();o.pushFrom(t);for(const t of this._planes)if(Zr.splitConvexPolygonInsideOutsidePlane(t,o,n,r,s),r.length>0){if(e&&Rs.captureOrDrop(r,3,e,i),r=i.grabFromCache(),0===n.length){o.length=0;break}i.dropToCache(o),o=n,n=i.grabFromCache()}if(i.dropToCache(n),i.dropToCache(r),o.length>0)return o;i.dropToCache(o)}classifyPointContainment(t,e){let i=!0;const s=e?1e-8:-1e-8;for(const e of this._planes){let n=0;for(const r of t)e.altitude(r)<(e.interior?1e-8:s)&&(n++,i=!1);if(n===t.length)return D.StronglyOutside}return i?D.StronglyInside:D.Ambiguous}static createSweptPolyline(t,e,i){const s=kn.createEmpty();let n=!1;t.length>3&&t[0].isAlmostEqual(t[t.length-1])&&Ur.areaNormal(t).dotProduct(e)>0&&(n=!0);for(let r=0;r+1<t.length;r++)if(n){const n=Wr.createEdgeAndUpVector(t[r+1],t[r],e,i);if(!n)return;s.addPlaneToConvexSet(n)}else{const n=Wr.createEdgeAndUpVector(t[r],t[r+1],e,i);if(!n)return;s.addPlaneToConvexSet(n)}return s}addPlaneToConvexSet(t){t instanceof Wr?this._planes.push(t):t instanceof _t&&this._planes.push(Wr.createPlane(t))}clipPointsOnOrInside(t,e,i){e.length=0,i.length=0;for(const s of t)this.isPointOnOrInside(s,0)?e.push(s):i.push(s)}polygonClip(t,e,i,s){t instanceof nt?t.clone(e):nt.create(t,e);for(const t of this._planes)if(s!==t){if(0===e.length)break;t.clipConvexPolygonInPlace(e,i)}}reloadSweptPolygon(t,e,i){this._planes.length=0;const s=t.length;if(s<=2)return 0;const n=Ur.areaNormal(t),r=e.dotProduct(n)>0,o=r?1:s-1;for(let i=0;i<s;i++){const n=(i+o)%s,r=t[i],a=t[n];if(r.isAlmostEqual(a))continue;const c=$.createStartEnd(r,a),l=$.createCrossProduct(e.x,e.y,e.z,c.x,c.y,c.z).normalize();let h;if(l){h=l.dotProduct(r);const t=Wr.createNormalAndDistance(l,h,!1,!1);t&&this._planes.push(t)}}if(0!==i){let s=n.normalize();if(s){e.dotProduct(s)*i<0&&(s=s.negate());const n=t[0],r=s.dotProduct(n),o=Wr.createNormalAndDistance(s,r,!1,!1);o&&this._planes.push(o)}}return r?1:-1}computePlanePlanePlaneIntersections(t,e,i,s=!0){const n=xt.createIdentity(),r=this._planes,o=r.length;let a=0;for(let c=0;c<o;c++)for(let l=c+1;l<o;l++)for(let h=l+1;h<o;h++)if(xt.createRowValues(r[c].inwardNormalRef.x,r[c].inwardNormalRef.y,r[c].inwardNormalRef.z,r[l].inwardNormalRef.x,r[l].inwardNormalRef.y,r[l].inwardNormalRef.z,r[h].inwardNormalRef.x,r[h].inwardNormalRef.y,r[h].inwardNormalRef.z,n),n.computeCachedInverse(!1)){const o=n.multiplyInverseXYZAsPoint3d(r[c].distance,r[l].distance,r[h].distance);s&&!this.isPointOnOrInside(o,Q.smallMetricDistance)||(a++,i&&i.multiplyPoint3d(o,o),t&&t.push(o),e&&e.extendPoint(o))}return a}setInvisible(t){for(const e of this._planes)e.setInvisible(t)}addZClipPlanes(t,e,i){void 0!==e&&this._planes.push(Wr.createNormalAndDistance($.create(0,0,1),e,t)),void 0!==i&&this._planes.push(Wr.createNormalAndDistance($.create(0,0,-1),-i,t))}appendPolygonClip(t,e,i,s){const n=this.clipInsidePushOutside(t,i,s);n&&e.push(n)}static createConvexPolyface(t,e){e=this.createEmpty(e);let i,s,n=0;if(t instanceof Ki?(i=t,s=t.createVisitor(0)):(i=t.clientPolyface(),s=t),i&&s){Fn.isPolyfaceClosedByEdgePairing(i)&&(n=Fn.sumTetrahedralVolumes(s));const t=n>0?-1:1,r=$.create(),o=_t.createXYPlane();for(s.reset();s.moveToNextFacet();)void 0!==Ur.areaNormalGo(s.point,r)&&(r.scaleInPlace(t),void 0!==_t.create(s.point.front(),r,o)&&e.addPlaneToConvexSet(o))}return{clipper:e,volume:n}}}kn.hugeVal=1e37,kn._clipArcFractionArray=new It;class Mn{constructor(t,e,i){if(t instanceof ae){const e=t;(t=t.startPoint().isAlmostEqual(t.endPoint())?new hi:new oi).tryAddChild(e)}this.curves=t,this.localToWorld=e,this.axis=i}static createForLinearSweep(t,e){const i=Fi.createRightHandedFrame(e,t);if(i)return new Mn(t,i,void 0)}static createForPolygon(t,e){const i=Fi.createRightHandedFrame(e,t);if(i){const e=Me.createArrayOfLineString3d(t),s=[];for(const t of e)t.addClosurePoint(),s.push(hi.create(t));if(1===s.length)return new Mn(s[0],i,void 0);if(s.length>1)return new Mn(bi.createLoops(s),i,void 0)}}static createForRotation(t,e){const i=Fi.createRightHandedFrame(void 0,t,e);if(i)return new Mn(t,i,e.clone())}getCurves(){return this.curves}tryTransformInPlace(t){if(this.curves.tryTransformInPlace(t)){this.axis&&this.axis.transformInPlace(t);const e=void 0!==this.axis?Fi.createRightHandedFrame(void 0,this.curves,this.axis):Fi.createRightHandedFrame(void 0,this.curves);if(e)return this.localToWorld.setFrom(e),this._xyStrokes=void 0,!0}return!1}clone(){return new Mn(this.curves.clone(),this.localToWorld.clone(),this.axis)}cloneTransformed(t){const e=this.clone();if(e.tryTransformInPlace(t))return e}isAlmostEqual(t){if(!(t instanceof Mn))return!1;if(!this.curves.isAlmostEqual(t.curves))return!1;if(!this.localToWorld.isAlmostEqual(t.localToWorld))return!1;if(this.axis&&t.axis){if(!this.axis.isAlmostEqual(t.axis))return!1}else if(this.axis||t.axis)return!1;return!0}computeXYStrokes(t){this._xyStrokes=void 0;const e=this.localToWorld.inverse();if(e){const i=this.curves.cloneStroked(t);i.tryTransformInPlace(e)&&(this._xyStrokes=i)}}get xyStrokes(){return this._xyStrokes}buildFacets(t){if(this._facets)return;if(!this.curves.isAnyRegion())return;const e=this.localToWorld.inverse();if(!e)return;const i=this.curves.cloneTransformed(e);i&&(this._facets=Er.facetRegionXY(i,t))&&this._facets.tryTransformInPlace(this.localToWorld)}purgeFacets(){this._facets=void 0}emitFacets(t,e,i){this.buildFacets(t.options),this._facets&&t.addIndexedPolyface(this._facets,e,i)}announceFacets(t,e){this.buildFacets(e),this._facets&&t(this._facets)}sweepToUnionOfConvexClipPlaneSets(t,e=!1,i=!1,s){s||(s=Ie.createForFacets()),t||(e=i=!1,t=this.localToWorld.matrix.columnZ()),s.maximizeConvexFacets=!0,this.buildFacets(s);const n=this._facets;if(n){const s=j.create(),r=j.create(),o=vs.createEmpty(),a=n.createVisitor(1);for(a.reset();a.moveToNextFacet();){const e=a.point.length-1,i=kn.createEmpty();for(let n=0;n<e;n++){a.point.getPoint3dAtUncheckedPointIndex(n,s),a.point.getPoint3dAtUncheckedPointIndex(n+1,r);const e=Wr.createEdgeAndUpVector(r,s,t),o=a.edgeVisible[n];e?.setFlags(!o,!o),i.addPlaneToConvexSet(e)}o.addConvexSet(i)}if(e||i){const s=this.localToWorld.matrix.columnZ(),n=this.localToWorld.getOrigin(),r=n.plus(t),a=s.clone(),c=s.negate(),l=kn.createEmpty();e&&l.addPlaneToConvexSet(Wr.createNormalAndPoint(a,n)),i&&l.addPlaneToConvexSet(Wr.createNormalAndPoint(c,r)),o.addConvexSet(l)}return o}}}class bn extends Di{constructor(t,e){super(e),this.solidPrimitiveType="ruledSweep",this._contours=t}static create(t,e){const i=[];for(const e of t){const t=Mn.createForLinearSweep(e);if(void 0===t)return;i.push(t)}return new bn(i,e)}sweepContoursRef(){return this._contours}cloneSweepContours(){const t=[];for(const e of this._contours)t.push(e.clone());return t}cloneContours(){const t=[];for(const e of this._contours)t.push(e.curves.clone());return t}clone(){return new bn(this.cloneSweepContours(),this.capped)}tryTransformInPlace(t){if(t.matrix.isSingular())return!1;for(const e of this._contours)e.tryTransformInPlace(t);return!0}cloneTransformed(t){const e=this.clone();return e.tryTransformInPlace(t),e}getConstructiveFrame(){if(0!==this._contours.length)return this._contours[0].localToWorld.cloneRigid()}isSameGeometryClass(t){return t instanceof bn}isAlmostEqual(t){if(t instanceof bn){if(this.capped!==t.capped)return!1;if(this._contours.length!==t._contours.length)return!1;for(let e=0;e<this._contours.length;e++)if(!this._contours[e].isAlmostEqual(t._contours[e]))return!1;return!0}return!1}dispatchToGeometryHandler(t){return t.handleRuledSweep(this)}constantVSection(t){const e=this._contours.length;if(e<2)return;const i=t*e;let s=0;s=t>=1?e-1:Math.floor(i),s+1>=e&&(s=e-2);const n=s+1,r=Q.clampToStartEnd(i-s,0,1);return bn.mutatePartners(this._contours[s].curves,this._contours[n].curves,((t,e)=>{const i=Ri.interpolateBetween(t,r,e);if(i instanceof ae)return i}))}extendRange(t,e){for(const i of this._contours)i.curves.extendRange(t,e)}static mutatePartners(t,e,i){if(t.isSameGeometryClass(e)){if(t instanceof ni&&e instanceof ni){const s=t,n=e,r=s.cloneEmptyPeer(),o=s.children,a=n.children;if(o.length!==a.length)return;for(let t=0;t<o.length;t++){const e=i(o[t],a[t]);if(!e)return;r.children.push(e)}return r}if(t instanceof si&&e instanceof si){const s=t.cloneEmptyPeer(),n=t.children,r=e.children,o=s.children;if(void 0===n||void 0===r||void 0===o||n.length!==r.length)return;for(let t=0;t<n.length;t++){const e=n[t],s=r[t];if(e instanceof ae&&s instanceof ae){const t=i(e,s);if(!t)return;o.push(t)}else if(e instanceof si&&s instanceof si){const t=this.mutatePartners(e,s,i);if(!t)return;t instanceof si&&o.push(t)}}return s}}}get isClosedVolume(){const t=this._contours.length;return t>1&&(this.capped||this._contours[0].isAlmostEqual(this._contours[t-1]))}}class En extends Di{constructor(t,e,i,s,n){super(n),this.solidPrimitiveType="torusPipe",this._localToWorld=t,this._radiusA=e,this._radiusB=i,this._sweep=s,this._isReversed=!1}clone(){const t=new En(this._localToWorld.clone(),this._radiusA,this._radiusB,this._sweep.clone(),this.capped);return t._isReversed=this._isReversed,t}tryTransformInPlace(t){return!t.matrix.isSingular()&&(t.multiplyTransformTransform(this._localToWorld,this._localToWorld),!0)}cloneTransformed(t){const e=this.clone();if(e.tryTransformInPlace(t))return e}static createInFrame(t,e,i,s,n){if((e=Math.abs(Q.correctSmallMetricDistance(e)))<(i=Math.abs(Q.correctSmallMetricDistance(i))))return;if(0===e)return;if(0===i)return;if(s.isAlmostZero)return;let r=1,o=1,a=!1;t.matrix.determinant()<0&&(o*=-1);const c=s.clone();s.radians<0&&(c.setRadians(-s.radians),o*=-1,r*=-1,a=!0);const l=t.clone();l.matrix.scaleColumnsInPlace(1,r,o);const h=new En(l,e,i,c,n);return h._isReversed=a,h}static createDgnTorusPipe(t,e,i,s,n,r,o){const a=e.unitCrossProductWithDefault(i,0,0,1),c=pt.createOriginAndMatrixColumns(t,e,i,a);return En.createInFrame(c,s,n,r,o)}static createAlongArc(t,e,i){if(W.isAlmostEqualRadiansAllowPeriodShift(0,t.sweep.startRadians)||(t=t.cloneInRotatedBasis(t.sweep.startAngle)),!t.isCircular){const e=t.perpendicularVector.sizedCrossProduct(t.vector0,t.matrixRef.columnXMagnitude());if(!e)return;t=Ti.create(t.center,t.vector0,e,t.sweep)}const s=t.toScaledMatrix3d(),n=pt.createOriginAndMatrix(t.center,s.axes);return En.createInFrame(n,s.r0,e,W.createRadians(t.sweep.sweepRadians),i)}getConstructiveFrame(){return this._localToWorld.cloneRigid()}cloneCenter(){return this._localToWorld.getOrigin()}cloneVectorX(){const t=this._localToWorld.matrix.columnX();return t.normalizeWithDefault(1,0,0,t)}cloneVectorY(){const t=this._localToWorld.matrix.columnY();return t.normalizeWithDefault(0,1,0,t)}cloneVectorZ(){const t=this._localToWorld.matrix.columnZ();return t.normalizeWithDefault(0,0,1,t)}getMajorRadius(){return this._radiusA*this._localToWorld.matrix.columnXMagnitude()}getMinorRadius(){return this._radiusB*this._localToWorld.matrix.columnZMagnitude()}getSweepAngle(){return this._sweep.clone()}getIsReversed(){return this._isReversed}getThetaFraction(){return this._sweep.radians/(2*Math.PI)}cloneLocalToWorld(){return this._localToWorld.clone()}isSameGeometryClass(t){return t instanceof En}isAlmostEqual(t){return!!(t instanceof En&&(this._sweep.isFullCircle||this.capped===t.capped)&&this.cloneCenter().isAlmostEqual(t.cloneCenter())&&this.cloneVectorX().isAlmostEqual(t.cloneVectorX())&&this.cloneVectorY().isAlmostEqual(t.cloneVectorY())&&this.cloneVectorZ().isAlmostEqual(t.cloneVectorZ())&&Q.isSameCoordinate(this.getMinorRadius(),t.getMinorRadius())&&Q.isSameCoordinate(this.getMajorRadius(),t.getMajorRadius())&&this.getSweepAngle().isAlmostEqualNoPeriodShift(t.getSweepAngle()))}vFractionToRadians(t){return this._sweep.radians*t}dispatchToGeometryHandler(t){return t.handleTorusPipe(this)}constantVSection(t){const e=this.vFractionToRadians(t),i=Math.cos(e),s=Math.sin(e),n=this._radiusA,r=this._radiusB,o=this._localToWorld.multiplyXYZ(n*i,n*s,0),a=this._localToWorld.multiplyVectorXYZ(r*i,r*s,0),c=this._localToWorld.multiplyVectorXYZ(0,0,r);return hi.create(Ti.create(o,a,c))}constantUSection(t){const e=this._sweep.radians,i=2*t*Math.PI,s=this._radiusA,n=this._radiusB,r=this._localToWorld.matrix,o=this._localToWorld.multiplyXYZ(0,0,n*Math.sin(i)),a=s+n*Math.cos(i),c=r.multiplyXYZ(a,0,0),l=r.multiplyXYZ(0,a,0);return oi.create(Ti.create(o,c,l,At.createStartEndRadians(0,e)))}extendRange(t,e){const i=this._sweep.radians,s=this._radiusA,n=this._radiusB,r=this._localToWorld,o=Math.ceil(i/(Math.PI/16));let a=0,c=0,l=0,h=0,d=0,u=0,f=0,g=0,p=0;const m=i/o;for(let i=0;i<=o;i++)if(h=i*m,d=Math.cos(h),u=Math.sin(h),0===i||i===o?(a=-Math.PI,c=2*Math.PI/16,l=16):(a=-.5*Math.PI,c=Math.PI/16,l=31),e)for(p=0;p<=l;p++)g=a+p*c,f=s+n*Math.cos(g),t.extendTransformTransformedXYZ(e,r,d*f,u*f,Math.sin(g)*n);else for(p=0;p<=l;p++)g=a+p*c,f=s+n*Math.cos(g),t.extendTransformedXYZ(r,d*f,u*f,Math.sin(g)*n)}uvFractionToPoint(t,e,i){const s=e*this._sweep.radians,n=t*Math.PI*2,r=Math.cos(s),o=Math.sin(s),a=this._radiusA,c=this._radiusB,l=a+Math.cos(n)*c;return this._localToWorld.multiplyXYZ(l*r,l*o,c*Math.sin(n),i)}uvFractionToPointAndTangents(t,e,i){const s=e*this._sweep.radians,n=t*Math.PI*2,r=this._sweep.radians,o=2*Math.PI,a=Math.cos(s),c=Math.sin(s),l=Math.sin(n),h=Math.cos(n),d=this._radiusA,u=this._radiusB,f=d+Math.cos(n)*u,g=u*l,p=u*h;return Et.createOriginAndVectors(this._localToWorld.multiplyXYZ(a*f,c*f,g),this._localToWorld.multiplyVectorXYZ(-a*g*o,-c*g*o,p*o),this._localToWorld.multiplyVectorXYZ(-f*c*r,f*a*r,0),i)}maxIsoParametricDistance(){const t=Math.abs(this.getMajorRadius()),e=Math.abs(this.getMinorRadius());return J.create(e*Math.PI*2,(t+e)*this._sweep.radians)}get isClosedVolume(){return this.capped||this._sweep.isFullCircle}}class Rn extends ae{get activeFractionInterval(){return this._activeFractionInterval}get localToWorld(){return this._localToWorld}constructor(t,e,i,s){super(),this._spiralType=t||"unknownSpiralType",this._designProperties=s,this._localToWorld=e,this._activeFractionInterval=i||Re.create(0,1)}get spiralType(){return this._spiralType}static radiusToCurvature(t){return 0===t?0:1/t}static curvatureToRadius(t){return Math.abs(t)<Q.smallAngleRadians?0:1/t}clonePartialCurve(t,e){const i=this.clone(),s=this._activeFractionInterval.fractionToPoint(t),n=this._activeFractionInterval.fractionToPoint(e);return i._activeFractionInterval.set(s,n),i.refreshComputedProperties(),i}cloneTransformed(t){const e=this.clone();return e.tryTransformInPlace(t),e}static averageCurvature(t){return.5*(Rn.radiusToCurvature(t.x0)+Rn.radiusToCurvature(t.x1))}static averageCurvatureR0R1(t,e){return.5*(Rn.radiusToCurvature(t)+Rn.radiusToCurvature(e))}static interpolateCurvatureR0R1(t,e,i){return Q.interpolate(Rn.radiusToCurvature(t),e,Rn.radiusToCurvature(i))}static radiusRadiusSweepRadiansToArcLength(t,e,i){return Math.abs(i/Rn.averageCurvatureR0R1(t,e))}static radiusRadiusLengthToSweepRadians(t,e,i){return Rn.averageCurvatureR0R1(t,e)*i}static radius0LengthSweepRadiansToRadius1(t,e,i){return Rn.curvatureToRadius(2*i/e-Rn.radiusToCurvature(t))}static radius1LengthSweepRadiansToRadius0(t,e,i){return Rn.curvatureToRadius(2*i/e-Rn.radiusToCurvature(t))}get designProperties(){return this._designProperties}applyRigidPartOfTransform(t){const e=t.matrix.factorRigidWithSignedScale();if(void 0!==e){const i=t.multiplyTransformTransform(this.localToWorld),s=e.rigidAxes.multiplyMatrixMatrix(this.localToWorld.matrix);return this._localToWorld=pt.createOriginAndMatrix(i.origin,s),this.designProperties&&this.designProperties.applyScaleFactor(e.scale),e}}constructOffsetXY(t){const e=we.create(t),i=new ye(this,e.leftOffsetDistance);return this.emitStrokableParts(i,e.strokeOptions),i.claimResult()}extendRange(t,e){const i=this.rangeBetweenFractions(0,1,e);t.extendRange(i)}rangeBetweenFractions(t,e,i){const s=this.activeStrokes;if(void 0===s)return ut.createNull();let n=Math.ceil(s.numPoints()*Math.abs(e-t));return n=Q.clamp(5,n,30),this.rangeBetweenFractionsByCount(t,e,n,i,.5)}projectedParameterRange(t,e){return Ee.findExtremeFractionsAlongDirection(this,t,e)}}class Dn{constructor(){}static findEvaluator(t){return"clothoid"===t?this._clothoidEvaluator?this._clothoidEvaluator:this._clothoidEvaluator=new Xn:"bloss"===t?this._blossEvaluator?this._blossEvaluator:this._blossEvaluator=new zn:"biquadratic"===t?this._biquadraticEvaluator?this._biquadraticEvaluator:this._biquadraticEvaluator=new Nn:"sine"===t?this._sineEvaluator?this._sineEvaluator:this._sineEvaluator=new On:"cosine"===t?this._cosineEvaluator?this._cosineEvaluator:this._cosineEvaluator=new Yn:void 0}}class Xn extends Dn{constructor(){super()}fractionToCurvatureFraction(t){return t}fractionToCurvatureFractionDerivative(t){return 1}fractionToArea(t){return t*t*.5}}class zn extends Dn{constructor(){super()}fractionToCurvatureFraction(t){return t*t*(3-2*t)}fractionToCurvatureFractionDerivative(t){return 6*t*(1-t)}fractionToArea(t){return t*t*t*(1-.5*t)}}class Nn extends Dn{constructor(){super()}integratedBasis(t){return t*t*t*(2/3)}basis(t){return 2*t*t}basisDerivative(t){return 4*t}fractionToCurvatureFraction(t){return t<=.5?this.basis(t):1-this.basis(1-t)}fractionToCurvatureFractionDerivative(t){return t<.5?this.basisDerivative(t):this.basisDerivative(1-t)}fractionToArea(t){if(t<=.5)return this.integratedBasis(t);const e=1-t;return.5-e+this.integratedBasis(e)}}class On extends Dn{constructor(){super()}fractionToCurvatureFraction(t){const e=2*Math.PI;return t-Math.sin(t*e)/e}fractionToCurvatureFractionDerivative(t){const e=2*Math.PI;return 1-Math.cos(t*e)}fractionToArea(t){const e=2*Math.PI;return.5*t*t+(Math.cos(t*e)-1)/(e*e)}}class Yn extends Dn{constructor(){super()}fractionToCurvatureFraction(t){const e=Math.PI;return.5*(1-Math.cos(t*e))}fractionToCurvatureFractionDerivative(t){const e=Math.PI;return.5*e*Math.sin(t*e)}fractionToArea(t){const e=Math.PI;return.5*t-.5*Math.sin(t*e)/e}}class Bn{constructor(t,e,i,s,n){this.radius0=t,this.radius1=e,this.bearing0=i,this.bearing1=s,this.curveLength=n}numDefinedProperties(){return Q.defined01(this.radius0)+Q.defined01(this.radius1)+Q.defined01(this.bearing0)+Q.defined01(this.bearing1)+Q.defined01(this.curveLength)}clone(){return new Bn(this.radius0,this.radius1,void 0===this.bearing0?void 0:this.bearing0.clone(),void 0===this.bearing1?void 0:this.bearing1.clone(),this.curveLength)}getIsValidCompleteSet(){if(void 0!==this.curveLength&&void 0!==this.bearing0&&void 0!==this.bearing1&&void 0!==this.radius0&&void 0!==this.radius1){const t=Rn.radiusRadiusSweepRadiansToArcLength(this.radius0,this.radius1,this.bearing1.radians-this.bearing0.radians);return Q.isSameCoordinate(this.curveLength,t)}return!1}tryResolveAnySingleUnknown(){if(this.getIsValidCompleteSet())return!0;if(this.bearing0&&this.bearing1){const t=this.bearing1.radians-this.bearing0.radians;return void 0===this.curveLength&&void 0!==this.radius0&&void 0!==this.radius1?(this.curveLength=Rn.radiusRadiusSweepRadiansToArcLength(this.radius0,this.radius1,t),!0):void 0!==this.curveLength&&void 0===this.radius0&&void 0!==this.radius1?(this.radius0=Rn.radius1LengthSweepRadiansToRadius0(this.radius1,this.curveLength,t),!0):void 0!==this.curveLength&&void 0!==this.radius0&&void 0===this.radius1&&(this.radius1=Rn.radius0LengthSweepRadiansToRadius1(this.radius0,this.curveLength,t),!0)}return void 0!==this.curveLength&&void 0!==this.radius0&&void 0!==this.radius1&&(this.bearing0?(this.bearing1=W.createRadians(this.bearing0.radians+Rn.radiusRadiusLengthToSweepRadians(this.radius0,this.radius1,this.curveLength)),!0):!!this.bearing1&&(this.bearing0=W.createRadians(this.bearing1.radians-Rn.radiusRadiusLengthToSweepRadians(this.radius0,this.radius1,this.curveLength)),!0))}almostEqualCoordinate(t,e){return void 0===t&&void 0===e||void 0!==t&&void 0!==e&&Q.isSameCoordinate(t,e)}almostEqualBearing(t,e){return void 0===t&&void 0===e||void 0!==t&&void 0!==e&&t.isAlmostEqualNoPeriodShift(e)}isAlmostEqual(t){return!!(t&&this.almostEqualCoordinate(this.radius0,t.radius0)&&this.almostEqualCoordinate(this.radius1,t.radius1)&&this.almostEqualBearing(this.bearing0,t.bearing0)&&this.almostEqualBearing(this.bearing1,t.bearing1)&&this.almostEqualCoordinate(this.curveLength,t.curveLength))}applyScaleFactor(t){void 0!==this.radius0&&(this.radius0*=t),void 0!==this.radius1&&(this.radius1*=t),void 0!==this.curveLength&&(this.curveLength*=t)}static areAlmostEqual(t,e){return void 0===t?void 0===e:t.isAlmostEqual(e)}}class Vn extends Rn{get activeStrokes(){return void 0!==this._activeStrokes?this._activeStrokes:this._globalStrokes}constructor(t,e,i,s,n,r,o,a){super(t,r,n,a),this.curvePrimitiveType="transitionSpiral",this._evaluator=e,this.radius01=i,this.bearing01=s,this._arcLength01=o,this._globalStrokes=Me.create(),this._curvature01=Re.create(0,1),this.refreshComputedProperties()}globalFractionToBearingRadians(t){const e=this._evaluator.fractionToArea(t),i=this._arcLength01;return this.bearing01.startRadians+e*i*this._curvature01.signedDelta()+t*this._curvature01.x0*i}globalFractionToCurvature(t){const e=this._evaluator.fractionToCurvatureFraction(t);return this._curvature01.fractionToPoint(e)}fractionToBearingRadians(t){const e=this.activeFractionInterval.fractionToPoint(t);return this.bearing01.startRadians+e*this._arcLength01*(this._curvature01.x0+.5*e*(this._curvature01.x1-this._curvature01.x0))}fractionToCurvature(t){return this._curvature01.fractionToPoint(this.activeFractionInterval.fractionToPoint(t))}static initWorkSpace(){Vn._gaussFraction=new Float64Array(5),Vn._gaussWeight=new Float64Array(5),Vn._gaussMapper=(t,e,i,s)=>ne.setupGauss5(t,e,i,s)}fullSpiralIncrementalIntegral(t,e,i,s){const n=Vn._gaussFraction,r=Vn._gaussWeight,o=Vn._gaussMapper(e,i,n,r),a=this._arcLength01;let c=0,l=0,h=0;for(let t=0;t<o;t++){const e=this.globalFractionToBearingRadians(n[t]);c=r[t]*a,l+=c*Math.cos(e),h+=c*Math.sin(e)}s?xt.xyzPlusMatrixTimesXYZ(t,this.localToWorld.matrix,{x:l,y:h,z:0},t):t.addXYZInPlace(l,h,0)}refreshComputedProperties(){this._curvature01=Re.create(Rn.radiusToCurvature(this.radius01.x0),Rn.radiusToCurvature(this.radius01.x1)),this._globalStrokes.clear();const t=j.create();this._globalStrokes.appendStrokePoint(t);const e=1/16;for(let i=1;i<=16;i++){const s=(i-1)*e,n=i*e;this.fullSpiralIncrementalIntegral(t,s,n,!1),this._globalStrokes.appendStrokePoint(t)}if(this._globalStrokes.tryTransformInPlace(this.localToWorld),!this.activeFractionInterval.isExact01){void 0===this._activeStrokes&&(this._activeStrokes=Me.create()),this._activeStrokes.clear();for(let t=0;t<=16;t++){const i=t*e;this._activeStrokes.addPoint(this.fractionToPoint(i))}}}static createRadiusRadiusBearingBearing(t,e,i,s,n){const r=Rn.radiusRadiusSweepRadiansToArcLength(t.x0,t.x1,e.sweepRadians);void 0===n&&(n="clothoid");const o=Dn.findEvaluator(n);if(o)return new Vn(n,o,t.clone(),e.clone(),i.clone(),s.clone(),r,new Bn(t.x0,t.x1,e.startAngle.clone(),e.endAngle.clone(),void 0))}static createFrom4OutOf5(t,e,i,s,n,r,o,a){void 0===t&&(t="clothoid");const c=Dn.findEvaluator(t);if(!c)return;const l=new Bn(e,i,s,n,r),h=l.clone();return l.tryResolveAnySingleUnknown()?(void 0===o&&(o=Re.create(0,1)),new Vn(t,c,Re.create(l.radius0,l.radius1),At.createStartEnd(l.bearing0,l.bearing1),o?o.clone():Re.create(0,1),a,l.curveLength,h)):void 0}setFrom(t){return this.localToWorld.setFrom(t.localToWorld),this.radius01.setFrom(t.radius01),this._curvature01.setFrom(t._curvature01),this.bearing01.setFrom(t.bearing01),this.localToWorld.setFrom(t.localToWorld),this.activeFractionInterval.setFrom(t.activeFractionInterval),this._arcLength01=t._arcLength01,this}clone(){return new Vn(this._spiralType,this._evaluator,this.radius01.clone(),this.bearing01.clone(),this.activeFractionInterval.clone(),this.localToWorld.clone(),this._arcLength01,this._designProperties?.clone())}tryTransformInPlace(t){const e=this.applyRigidPartOfTransform(t);return void 0!==e&&(this._curvature01.x0/=e.scale,this._curvature01.x1/=e.scale,this.radius01.x0*=e.scale,this.radius01.x1*=e.scale,this._arcLength01*=e.scale),this.refreshComputedProperties(),!0}startPoint(){return this.activeStrokes.startPoint()}endPoint(){return this.activeStrokes.endPoint()}isInPlane(t){return t.isPointInPlane(this.localToWorld.origin)&&Q.isSameCoordinate(0,this.localToWorld.matrix.dotColumnX(t.getNormalRef()))&&Q.isSameCoordinate(0,this.localToWorld.matrix.dotColumnY(t.getNormalRef()))}quickLength(){return this.curveLength()}curveLength(){return this._arcLength01*this._activeFractionInterval.absoluteDelta()}curveLengthBetweenFractions(t,e){return this._arcLength01*(this._activeFractionInterval.absoluteDelta()*Math.abs(e-t))}isSameGeometryClass(t){return t instanceof Rn}emitStrokes(t,e){this.activeStrokes.emitStrokes(t,e)}emitStrokableParts(t,e){const i=this.computeStrokeCountForOptions(e);t.startParentCurvePrimitive(this);const s=this.activeStrokes;(void 0===t.needPrimaryGeometryForStrokes||!t.needPrimaryGeometryForStrokes())&&i<=s.numPoints()?this.activeStrokes.emitStrokableParts(t,e):t.announceIntervalForUniformStepStrokes(this,i,0,1),t.endParentCurvePrimitive(this)}computeStrokeCountForOptions(t){let e;if(t){const i=Math.min(Math.abs(this.radius01.x0),Math.abs(this.radius01.x1));e=t.applyTolerancesToArc(i,this.bearing01.sweepRadians),e=t.applyMaxEdgeLength(e,this.curveLength()),e=t.applyMinStrokesPerPrimitive(e)}else e=Ie.applyAngleTol(void 0,4,this.bearing01.sweepRadians);return e}reverseInPlace(){this.activeFractionInterval.reverseInPlace(),void 0===this._activeStrokes&&(this._activeStrokes=this._globalStrokes.clone()),this._activeStrokes.reverseInPlace()}fractionToPoint(t,e){const i=this.activeFractionInterval.fractionToPoint(t),s=this._globalStrokes.packedPoints.length-1;if(t>1){e=this._globalStrokes.packedPoints.back(e);const t=1/s;let n=1,r=n+t;for(;r<i;)this.fullSpiralIncrementalIntegral(e,n,r,!0),n=r,r+=t;this.fullSpiralIncrementalIntegral(e,n,i,!0)}else if(t<0){e=this._globalStrokes.packedPoints.front(e);const t=1/s;let n=0,r=n-t;for(;r>i;)this.fullSpiralIncrementalIntegral(e,n,r,!0),n=r,r-=t;this.fullSpiralIncrementalIntegral(e,n,i,!0)}else{const t=Q.clampToStartEnd(i,0,1),n=Math.trunc(t*s),r=n/s;e=this._globalStrokes.packedPoints.getPoint3dAtUncheckedPointIndex(n,e),this.fullSpiralIncrementalIntegral(e,r,i,!0)}return e}fractionToPointAndDerivative(t,e){const i=this.activeFractionInterval.fractionToPoint(t);e=e||bt.createZero(),this.fractionToPoint(t,e.origin);const s=this.globalFractionToBearingRadians(i),n=this._arcLength01*this.activeFractionInterval.signedDelta();return this.localToWorld.matrix.multiplyXY(n*Math.cos(s),n*Math.sin(s),e.direction),e}fractionToFrenetFrame(t,e){const i=this.activeFractionInterval.fractionToPoint(t);(e=e||pt.createIdentity()).origin.setFrom(this.fractionToPoint(t)),xt.createRigidFromMatrix3d(this.localToWorld.matrix,g.XYZ,e.matrix);const s=this.globalFractionToBearingRadians(i),n=Math.cos(s),r=Math.sin(s);return e.matrix.applyGivensColumnOp(0,1,n,r),e}fractionToPointAnd2Derivatives(t,e){const i=this.activeFractionInterval.fractionToPoint(t),s=this.fractionToPoint(t),n=this.globalFractionToBearingRadians(i),r=Math.cos(n),o=Math.sin(n),a=this.activeFractionInterval.signedDelta(),c=a,l=c*a,h=this.localToWorld.matrix.multiplyXY(c*r,c*o),d=this.localToWorld.matrix.multiplyXY(-l*o,l*r);return d.scaleInPlace(this.globalFractionToCurvature(i)),Et.createCapture(s,h,d,e)}dispatchToGeometryHandler(t){return t.handleTransitionSpiral(this)}isAlmostEqual(t){return t instanceof Vn&&this.radius01.isAlmostEqual(t.radius01)&&this.bearing01.isAlmostEqualAllowPeriodShift(t.bearing01)&&this.localToWorld.isAlmostEqual(t.localToWorld)&&Q.isSameCoordinate(this._arcLength01,t._arcLength01)&&this.activeFractionInterval.isAlmostEqual(t.activeFractionInterval)&&this._curvature01.isAlmostEqual(t._curvature01)}}Vn.defaultSpiralType="clothoid",Vn.initWorkSpace(),function(t){t[t.Sections=0]="Sections",t[t.AlsoRuledSweep=1]="AlsoRuledSweep",t[t.AlsoMesh=2]="AlsoMesh"}(V||(V={}));class Ln{static addPartialSegment(t,e,i,s,n,r){(e||r>n)&&(void 0===i||void 0===s||Q.isAlmostEqualNumber(n,r)||t.tryAddChild(Ce.create(i.interpolate(n,s),i.interpolate(r,s))))}static createArcPointTangentPoint(t,e,i){const s=Ti.createCircularStartTangentEnd(t,e,i);return s instanceof Ti?s:void 0}static createFilletsInLineString(t,e,i=!0){if(Array.isArray(t))return this.createFilletsInLineString(new ce(t),e,i);if(t instanceof Me)return this.createFilletsInLineString(t.packedPoints,e,i);const s=t.length;if(s<=1)return;const n=t.getPoint3dAtCheckedPointIndex(0),r=t.getPoint3dAtCheckedPointIndex(1),o=[];o.push({fraction10:0,fraction12:0,point:n.clone()});for(let i=1;i+1<s;i++){const s=t.getPoint3dAtCheckedPointIndex(i+1);let a=0;Array.isArray(e)?i<e.length&&(a=e[i]):Number.isFinite(e)&&(a=e),0!==a?o.push(Ti.createFilletArc(n,r,s,a)):o.push({fraction10:0,fraction12:0,point:r.clone()}),n.setFromPoint3d(r),r.setFromPoint3d(s)}if(o.push({fraction10:0,fraction12:0,point:r.clone()}),!i)for(let t=1;t+1<s;t++){const e=o[t];(e.fraction10>1||e.fraction12>1||1-e.fraction10<o[t-1].fraction12||e.fraction12>1-o[t+1].fraction10)&&(e.fraction10=0,e.fraction12=0,o[t].arc=void 0)}const a=oi.create();this.addPartialSegment(a,i,o[0].point,o[1].point,o[0].fraction12,1-o[1].fraction10);for(let e=1;e+1<t.length;e++){const t=o[e],s=o[e+1];a.tryAddChild(t.arc),this.addPartialSegment(a,i,t.point,s.point,t.fraction12,1-s.fraction10)}return a}static createRectangleXY(t,e,i,s,n=0,r){let o=Q.correctSmallMetricDistance(r);const a=Math.min(t,i),c=Math.max(t,i),l=Math.min(e,s),h=Math.max(e,s);if(o=Math.min(Math.abs(o),.5*(c-a),.5*(h-l)),0===o)return hi.createPolygon([j.create(a,l,n),j.create(c,l,n),j.create(c,h,n),j.create(a,h,n),j.create(a,l,n)]);{const t=$.create(o,0,0),e=$.create(0,o,0),i=a+o,s=l+o,r=c-o,d=h-o,u=[j.create(r,d,n),j.create(i,d,n),j.create(i,s,n),j.create(r,s,n)],f=hi.create();for(let i=0;i<4;i++){const s=u[i],n=u[(i+1)%4],r=$.createStartEnd(s,n),o=Ti.create(s,t,e,At.createStartEndDegrees(0,90));f.tryAddChild(o);const a=o.endPoint();r.isAlmostZero||f.tryAddChild(Ce.create(a,a.plus(r))),t.rotate90CCWXY(t),e.rotate90CCWXY(e)}return f}}static appendToArcInPlace(t,e,i=!1){if(t.center.isAlmostEqual(e.center)){const s=Q.split3WaySign(t.sweep.sweepRadians*e.sweep.sweepRadians,-1,0,1),n=t.angleToPointAndDerivative(t.sweep.fractionToAngle(1));t.sweep.sweepRadians<0&&n.direction.scaleInPlace(-1);const r=e.angleToPointAndDerivative(e.sweep.fractionToAngle(0));if(e.sweep.sweepRadians<0&&r.direction.scaleInPlace(-1),n.isAlmostEqual(r))return t.sweep.setStartEndRadians(t.sweep.startRadians,t.sweep.startRadians+t.sweep.sweepRadians+s*e.sweep.sweepRadians),!0;if(i&&(r.direction.scaleInPlace(-1),n.isAlmostEqual(r)))return t.sweep.setStartEndRadians(t.sweep.startRadians,t.sweep.startRadians+t.sweep.sweepRadians-s*e.sweep.sweepRadians),!0}return!1}static assembleArcChainOnEllipsoid(t,e,i=.5){const s=oi.create();for(let n=0;n+1<e.length;n++){const r=t.sectionArcWithIntermediateNormal(e[n].toAngles(),i,e[n+1].toAngles());s.tryAddChild(r)}return s}static appendGeometryQueryArray(t,e){if(t instanceof Ot)e.push(t);else if(Array.isArray(t))for(const i of t)this.appendGeometryQueryArray(i,e)}static createPipeSegments(t,e){if(t instanceof Ce)return Xi.createAxisPoints(t.startPoint(),t.endPoint(),e,e,!1);if(t instanceof Ti)return En.createAlongArc(t,e,!1);if(t instanceof ae){const i=ar.create();return i.addMiteredPipes(t,e),i.claimPolyface()}if(t instanceof ni){const i=[];for(const s of t.children){const t=this.createPipeSegments(s,e);this.appendGeometryQueryArray(t,i)}return i}}static createMiteredPipeSections(t,e){const i=[];if(t.length<2)return[];const s=$.create(),n=$.create(),r=$.create(),o=j.create();let a;if(t.vectorIndexIndex(0,1,r),t.getPoint3dAtUncheckedPointIndex(0,o),e instanceof Ti)a=e.clone(),a.center.setFrom(o),s.setFrom(e.vector0),n.setFrom(e.vector90);else{if("number"!=typeof e&&!j.isXAndY(e))return[];{const t="number"==typeof e?e:e.x,i="number"==typeof e?e:e.y,c=xt.createRigidHeadsUp(r,g.ZXY);c.columnX(s).scaleInPlace(t),c.columnY(n).scaleInPlace(i),a=Ti.create(o,s,n,At.create360())}}i.push(a);const c=$.create(),l=$.create();for(let e=1;e<t.length;e++)c.setFromVector3d(r),t.getPoint3dAtUncheckedPointIndex(e,o),e+1<t.length?t.vectorIndexIndex(e,e+1,r):r.setFromVector3d(c),c.normalizeInPlace()&&r.normalizeInPlace()&&(c.interpolate(.5,r,l),Un(s,c,l,s),Un(n,c,l,n),i.push(Ti.create(o,s,n,At.create360())));return i}static createMiteredSweepSections(t,e,i){const s={sections:[],planes:[]},n=Mi.createBisectorPlanesForDistinctPoints(t,i.wrapIfPhysicallyClosed);if(void 0!==n&&n.length>1){const t=function(t,e,i,n){const r=$.createStartEnd(t.getOriginRef(),e.getOriginRef()),o=pt.createFlattenAlongVectorToPlane(r,i.getOriginRef(),i.getNormalRef());if(void 0===o)return n;const a=n.cloneTransformed(o);return void 0===a?n:(s.planes.push(i),s.sections.push(a),a)};let r=t(n[0],n[1],n[0],e);for(let e=1;e<n.length;e++)r=t(n[e-1],n[e],n[e],r);if(i.outputSelect){const t=bn.create(s.sections,i.capped??!1);if(t&&(s.ruledSweep=t,V.AlsoMesh===i.outputSelect)){const e=ar.create(i.strokeOptions);e.addRuledSweep(t),s.mesh=e.claimPolyface()}}return s}}static createArcPointTangentRadius(t,e,i,s,n){return Ti.createCircularStartTangentRadius(t,e,i,s,n)}static createLineSpiralSpiralLine(t,e,i,s){const n=$.createStartEnd(e,i),r=$.createStartEnd(i,s),o=n.magnitude(),a=Math.atan2(n.y,n.x),c=n.angleToXY(r),l=.5*c.radians,h=a+c.radians,d=xt.createRotationAroundAxisIndex(p.Z,W.createRadians(a)),u=pt.createRefs(e.clone(),d),f=Vn.createFrom4OutOf5(t,0,void 0,W.createRadians(0),W.createRadians(l),o,void 0,u);if(f){const r=a+l,c=$.createPolar(1,W.createRadians(r)),d=c.dotProductStartEnd(e,i)/c.dotProductStartEnd(e,f.endPoint()),g=Vn.createFrom4OutOf5(t,0,void 0,W.createRadians(0),W.createRadians(l),o*d,void 0,u),m=n.magnitude(),x=$.createStartEnd(i,s);x.scaleToLength(m,x);const _=i.plus(x),y=xt.createRotationAroundAxisIndex(p.Z,W.createRadians(h+Math.PI)),v=pt.createRefs(_,y),P=Vn.createFrom4OutOf5(t,0,-g.radius01.x1,W.zero(),void 0,g.curveLength(),Re.create(1,0),v);return[g,P]}}static createLineSpiralSpiralLineWithSpiralLength(t,e,i,s,n){const r=$.createStartEnd(e,i),o=$.createStartEnd(i,s),a=Math.atan2(r.y,r.x),c=r.angleToXY(o),l=.5*c.radians,h=.5*(Math.PI-c.radians),d=Math.atan2(-o.y,-o.x),u=Vn.createFrom4OutOf5(t,0,void 0,W.zero(),W.createRadians(l),n,void 0,pt.createIdentity());if(u){const r=u.fractionToPoint(1),o=e.distance(i),c=s.distance(i),f=r.y/Math.tan(h),g=Q.conditionalDivideFraction(o-f-r.x,o),m=Q.conditionalDivideFraction(c-f-r.x,c);if(void 0!==g&&void 0!==m){const r=xt.createRotationAroundAxisIndex(p.Z,W.createRadians(a)),o=e.interpolate(g,i),c=pt.createRefs(o,r),h=Vn.createFrom4OutOf5(t,0,void 0,W.zero(),W.createRadians(l),n,void 0,c),u=xt.createRotationAroundAxisIndex(p.Z,W.createRadians(d)),f=s.interpolate(m,i),x=pt.createRefs(f,u);return[h,Vn.createFrom4OutOf5(t,0,void 0,W.zero(),W.createRadians(-l),n,void 0,x)]}}}static createLineSpiralArcSpiralLine(t,e,i,s,n,r,o){const a=$.createStartEnd(e,i);a.z=0;const c=$.createStartEnd(s,i);c.z=0;const l=a.normalize(),h=c.normalize();if(void 0===l||void 0===h)return;const d=l.unitPerpendicularXY(),u=h.unitPerpendicularXY(),f=a.angleToXY(c),g=Q.split3WaySign(f.radians,1,-1,-1),p=-g,m=g*Math.abs(o),x=p*Math.abs(o),_=Vn.createFrom4OutOf5(t,0,m,W.zero(),void 0,n,void 0,pt.createIdentity()),y=Vn.createFrom4OutOf5(t,0,x,W.zero(),void 0,r,void 0,pt.createIdentity()),v=_.fractionToPointAndUnitTangent(1),P=y.fractionToPointAndUnitTangent(1),A=v.origin.x-m*v.direction.y,I=v.origin.y+m*v.direction.x,S=P.origin.x-x*P.direction.y,w=P.origin.y+x*P.direction.x,C=$.createAdd2Scaled(l,A,d,I),T=$.createAdd2Scaled(h,S,u,w),F=J.create();if(Mt.linearSystem2d(l.x,-h.x,l.y,-h.y,T.x-C.x,T.y-C.y,F)){const t=i.plusScaled(l,F.x),e=i.plusScaled(h,F.y),s=pt.createOriginAndMatrixColumns(t,l,d,$.unitZ()),n=pt.createOriginAndMatrixColumns(e,h,u,$.unitZ());_.tryTransformInPlace(s),y.tryTransformInPlace(n);const r=_.fractionToPointAndUnitTangent(1),o=y.fractionToPointAndUnitTangent(1);o.direction.scaleInPlace(-1);const a=r.direction.angleToXY(o.direction);return m<0&&a.setRadians(-a.radians),[_,Ln.createArcPointTangentRadius(r.origin,r.direction,m,void 0,a),y]}}static planePlaneIntersectionRay(t,e){const i=t.altitudeXYZ(0,0,0),s=e.altitudeXYZ(0,0,0),n=t.normalX(),r=t.normalY(),o=t.normalZ(),a=e.normalX(),c=e.normalY(),l=e.normalZ(),h=Q.crossProductXYXY(r,o,c,l),d=Q.crossProductXYXY(o,n,l,a),u=Q.crossProductXYXY(n,r,a,c),f=Mt.linearSystem3d(n,r,o,a,c,l,h,d,u,-i,-s,0);if(void 0!==f)return bt.createXYZUVW(f.x,f.y,f.z,h,d,u)}}function Un(t,e,i,s){const n=t.dotProduct(i),r=e.dotProduct(i),o=Q.safeDivideFraction(n,r,0);return t.plusScaled(e,-o,s)}class Zn extends Ae{constructor(t){super(),this._localPoint=j.create(),this._worldPoint=j.create(),this._perpVector=$.createZero(),this._maxDistance=0,this._localToWorld=t.toRigidZFrame()}announcePoint(t){this._localToWorld.multiplyInversePoint3d(t,this._localPoint);const e=this._localPoint.magnitudeXY();e>=this._maxDistance&&(this._maxDistance=e,this._perpVector.setFromPoint3d(this._localPoint),this._perpVector.z=0,this._localToWorld.matrix.multiplyXY(this._localPoint.x,this._localPoint.y,this._perpVector))}handleLineSegment3d(t){this.announcePoint(t.startPoint(this._worldPoint)),this.announcePoint(t.endPoint(this._worldPoint))}handleLineString3d(t){for(let e=0;e<t.numPoints();e++)t.pointAt(e,this._worldPoint),this.announcePoint(this._worldPoint)}handleArc3d(t){const e=Ie.applyAngleTol(void 0,3,t.sweep.sweepRadians,.1),i=1/e;for(let s=0;s<=e;s++)t.fractionToPoint(s*i,this._worldPoint),this.announcePoint(this._worldPoint)}static computeMaxVectorFromRay(t,e){const i=new Zn(t);return e.dispatchToGeometryHandler(i),i._perpVector.clone()}static buildRotationalNormalsInLineStrings(t,e,i){if(t instanceof Me){const s=t.packedPoints,n=t.packedDerivatives,r=t.ensureEmptySurfaceNormals();if(n&&r){const n=$.create(),o=$.create(),a=j.create(),c=s.length;for(let l=0;l<c;l++)s.getPoint3dAtUncheckedPointIndex(l,a),e.perpendicularPartOfVectorToTarget(a,n),n.isAlmostZero?e.direction.crossProduct(i,o):e.direction.crossProduct(n,o),t.packedDerivatives.getVector3dAtCheckedVectorIndex(l,n),n.crossProduct(o,o),o.normalizeInPlace(),r.push(o)}}else if(t.children){const s=t.children;for(const t of s)this.buildRotationalNormalsInLineStrings(t,e,i)}}}class qn{startSweeps(t,e,i){return!0}endSweeps(t,e,i){return!0}}class Wn extends qn{constructor(){super(),this.myMap=Nt.createWithComponentIndex()}startPass(t){return 0===t?(this.myMap.numStroke=0,!0):1===t}visit(t,e){return 0===t?(e.numStroke>this.myMap.numStroke&&(this.myMap.numStroke=e.numStroke),!0):1===t&&(e.numStroke=this.myMap.numStroke,!0)}endPass(t){return!0}}class Gn extends qn{constructor(){super(),this.maxCurveLength=0}startPass(t){return 0===t?(this.maxCurveLength=0,!0):1===t}visit(t,e){return 0===t?(this.maxCurveLength=Q.maxXY(e.curveLength,this.maxCurveLength),!0):1===t&&(e.a0=0,e.a1=this.maxCurveLength,!0)}endPass(t){return!0}}class Hn{constructor(t,e){this.parent=t,this.maps=[],this.options=e}static createForCurveChain(t,e){const i=new Hn(t,e);i.parent=t;for(const s of t.children)s.computeAndAttachRecursiveStrokeCounts(e),s.strokeData&&i.maps.push(s.strokeData);return i}getStrokes(){const t=Me.create();this.options&&(this.options.needNormals||this.options.needParams)&&(t.ensureEmptyFractions(),t.ensureEmptyDerivatives(),t.ensureEmptyUVParams());for(const e of this.maps)e.primitive&&e.primitive.addMappedStrokesToLineString3D(e,t);return t}static applySummed01LimitsWithinArray(t,e){let i=e;for(const e of t)e.a0+=i,e.componentData?e.a1=this.applySummed01LimitsWithinArray(e.componentData,e.a0):e.a1+=i,i=e.a1;return i}applySummed01Limits(t){return Hn.applySummed01LimitsWithinArray(this.maps,t)}}class Jn{constructor(t){this.parent=t,this.chains=[]}static createForParityRegionOrChain(t,e){const i=new Jn(t);if(t instanceof bi)for(const s of t.children){const t=Hn.createForCurveChain(s,e);i.chains.push(t)}else t instanceof ni&&i.chains.push(Hn.createForCurveChain(t,e));return i}static areSectionsCompatible(t,e){if(t.length<2)return!0;const i=t[0].chains.length;for(let s=1;s<t.length;s++){if(t[s].chains.length!==i)return!1;for(let i=0;i<t[0].chains.length;i++){const n=t[0].chains[i].maps.length;if(t[s].chains[i].maps.length!==n)return!1;for(let r=0;r<n;r++)if(!t[0].chains[i].maps[r].isCompatibleComponentStructure(t[s].chains[i].maps[r],e))return!1}}return!0}static remapa0a1WithinEachChain(t){for(const e of t)for(const t of e.chains)t.applySummed01Limits(0)}static applyMultipassVisitorCallbackNoComponents(t,e,i,s,n){const r=t.length;if(!n.startSweeps(e,i,s))return!1;if(void 0===s)for(let s=0;n.startPass(s);s++){for(let o=0;o<r;o++)if(!n.visit(s,t[o].chains[e].maps[i]))return!1;if(!n.endPass(s))return!1}else for(let o=0;n.startPass(o);o++){for(let a=0;a<r;a++)if(!n.visit(o,t[a].chains[e].maps[i].componentData[s]))return!1;if(!n.endPass(o))return!1}return!!n.endSweeps(e,i,s)}static runMultiPassVisitorAtCorrespondingPrimitives(t,e){const i=t[0].chains.length;for(let s=0;s<i;s++){const i=t[0].chains[s].maps.length;for(let n=0;n<i;n++)if(t[0].chains[s].maps[n].componentData){const i=t[0].chains[s].maps[n].componentData.length;for(let r=0;r<i;r++)if(!this.applyMultipassVisitorCallbackNoComponents(t,s,n,r,e))return!1}else if(!this.applyMultipassVisitorCallbackNoComponents(t,s,n,void 0,e))return!1}return!0}static enforceStrokeCountCompatibility(t){if(t.length<2)return!0;if(!Jn.areSectionsCompatible(t,!1))return!1;const e=new Wn;return this.runMultiPassVisitorAtCorrespondingPrimitives(t,e),!0}static enforceCompatibleDistanceSums(t){if(t.length<2)return!0;if(!Jn.areSectionsCompatible(t,!1))return!1;const e=new Gn;return this.runMultiPassVisitorAtCorrespondingPrimitives(t,e),this.remapa0a1WithinEachChain(t),!0}getStrokes(){if(1===this.chains.length)return this.chains[0].getStrokes();{const t=bi.create();for(const e of this.chains){const i=e.getStrokes();i instanceof Me&&t.tryAddChild(hi.create(i))}return t}}static extendDistanceRangeBetweenStrokes(t,e,i){if(t instanceof Me){if(e instanceof Me&&t.numPoints()===e.numPoints()){const s=t.numPoints(),n=j.create(),r=j.create(),o=t.packedPoints,a=e.packedPoints;for(let t=0;t<s;t++)o.getPoint3dAtCheckedPointIndex(t,n),a.getPoint3dAtCheckedPointIndex(t,r),i.extendX(n.distance(r));return!0}}else if(t instanceof bi){if(e instanceof bi){const s=t.children,n=e.children,r=s.length;if(r===n.length){for(let t=0;t<r;t++)if(!this.extendDistanceRangeBetweenStrokes(s[t],n[t],i))return!1;return!0}}}else if(t instanceof ni&&e instanceof ni){const s=t.children,n=e.children,r=s.length;if(r===n.length){for(let t=0;t<r;t++)if(!this.extendDistanceRangeBetweenStrokes(s[t],n[t],i))return!1;return!0}}return!1}}class Qn{constructor(t,e,i){this.surface=t,this.point=i||j.createZero(),this.uv=e||H.createZero(),this.a=0}static createSurfaceUVPoint(t,e,i){const s=new Qn(t);return e&&s.uv.setFrom(e),s.point.setFromPoint3d(i),s}static createSurfaceUVNumbersPoint(t,e,i,s){const n=new Qn(t);return n.uv.x=e,n.uv.y=i,n.point.setFromPoint3d(s),n}}class Kn{constructor(t,e){this.curveDetail=t,this.surfaceDetail=e}}class jn{constructor(t,e,i,s){this.point00=t,this.point10=e,this.point01=i,this.point11=s}static create(t,e,i,s){return new jn(t.clone(),e.clone(),i.clone(),s.clone())}static createXYZ(t,e,i,s,n,r,o,a,c,l,h,d){return new jn(j.create(t,e,i),j.create(s,n,r),j.create(o,a,c),j.create(l,h,d))}clone(){return new jn(this.point00.clone(),this.point10.clone(),this.point01.clone(),this.point11.clone())}isAlmostEqual(t){return this.point00.isAlmostEqual(t.point00)&&this.point10.isAlmostEqual(t.point10)&&this.point01.isAlmostEqual(t.point01)&&this.point11.isAlmostEqual(t.point11)}tryTransformInPlace(t){return t.multiplyPoint3d(this.point00,this.point00),t.multiplyPoint3d(this.point10,this.point10),t.multiplyPoint3d(this.point01,this.point01),t.multiplyPoint3d(this.point11,this.point11),!0}cloneTransformed(t){const e=this.clone();return e.tryTransformInPlace(t),e}extendRange(t,e){e?(t.extendTransformedPoint(e,this.point00),t.extendTransformedPoint(e,this.point10),t.extendTransformedPoint(e,this.point01),t.extendTransformedPoint(e,this.point11)):(t.extendPoint(this.point00),t.extendPoint(this.point10),t.extendPoint(this.point01),t.extendPoint(this.point11))}uvFractionToPoint(t,e,i){const s=(1-t)*(1-e),n=t*(1-e),r=(1-t)*e,o=t*e;return j.create(s*this.point00.x+n*this.point10.x+r*this.point01.x+o*this.point11.x,s*this.point00.y+n*this.point10.y+r*this.point01.y+o*this.point11.y,s*this.point00.z+n*this.point10.z+r*this.point01.z+o*this.point11.z,i)}uvFractionToPointAndTangents(t,e,i){const s=1-t,n=1-e,r=s*n,o=t*n,a=s*e,c=t*e;return Et.createOriginAndVectorsXYZ(r*this.point00.x+o*this.point10.x+a*this.point01.x+c*this.point11.x,r*this.point00.y+o*this.point10.y+a*this.point01.y+c*this.point11.y,r*this.point00.z+o*this.point10.z+a*this.point01.z+c*this.point11.z,n*(this.point10.x-this.point00.x)+e*(this.point11.x-this.point01.x),n*(this.point10.y-this.point00.y)+e*(this.point11.y-this.point01.y),n*(this.point10.z-this.point00.z)+e*(this.point11.z-this.point01.z),s*(this.point01.x-this.point00.x)+t*(this.point11.x-this.point10.x),s*(this.point01.y-this.point00.y)+t*(this.point11.y-this.point10.y),s*(this.point01.z-this.point00.z)+t*(this.point11.z-this.point10.z),i)}static conditionalPivot(t,e,i,s){if(Math.abs(e[s][t])>Math.abs(e[i][t])){const t=e[i];e[i]=e[s],e[s]=t}}intersectRay(t){const e=this.point10.minus(this.point00),i=this.point01.minus(this.point00),s=this.point11.minus(this.point10);s.subtractInPlace(i);const n=[new Float64Array([-t.direction.x,this.point00.x-t.origin.x,e.x,i.x,s.x]),new Float64Array([-t.direction.y,this.point00.y-t.origin.y,e.y,i.y,s.y]),new Float64Array([-t.direction.z,this.point00.z-t.origin.z,e.z,i.z,s.z])];jn.conditionalPivot(0,n,0,1),jn.conditionalPivot(0,n,0,2),Mt.eliminateFromPivot(n[0],0,n[1],-1),Mt.eliminateFromPivot(n[0],0,n[2],-1);const r=Mt.solveBilinearPair(n[1][1],n[1][2],n[1][3],n[1][4],n[2][1],n[2][2],n[2][3],n[2][4]);if(r){const e=[];for(const i of r){const s=-(n[0][1]+n[0][2]*i.x+(n[0][3]+n[0][4]*i.x)*i.y)/n[0][0],r=t.fractionToPoint(s);e.push(new Kn(vt.createRayFractionPoint(t,s,r),Qn.createSurfaceUVPoint(this,i,r)))}return e}}maxUEdgeLength(){return Q.maxXY(this.point00.distance(this.point10),this.point01.distance(this.point11))}maxVEdgeLength(){return Q.maxXY(this.point00.distance(this.point01),this.point10.distance(this.point11))}}class $n{static sampledRangeOfOffsetPatch(t,e,i,s){const n=ut.createNull(),r=1/(i=Math.ceil(Q.clamp(i,2,500))),o=1/(s=Math.ceil(Q.clamp(s,2,500))),a=j.create(),c=Et.createXYPlane();let l,h;for(let d=0;d<=s;d++){h=d*o;for(let s=0;s<=i;s++)if(l=s*r,void 0!==e){t.uvFractionToPointAndTangents(l,h,c);const i=c.unitNormal();void 0!==i&&(c.origin.addScaledInPlace(i,e),n.extend(c.origin))}else t.uvFractionToPoint(l,h,a),n.extendXYZ(a.x,a.y,a.z)}return n}static sampledRangeOfOffsetEllipsoidPatch(t,e,i){const s=Ie.applyAngleTol(i,2,t.latitudeSweep.sweepRadians,W.degreesToRadians(5)),n=Ie.applyAngleTol(i,2,t.longitudeSweep.sweepRadians,W.degreesToRadians(5));return this.sampledRangeOfOffsetPatch(t,e,s,n)}constructor(){}static createLinestringOnUVLine(t,e,i,s,n,r,o=!1,a=!1){const c=Me.create(),l=j.create();let h,d,u;const f=r+1;for(let g=0;g<f;g++)h=g/r,d=Q.interpolate(e,h,s),u=Q.interpolate(i,h,n),t.uvFractionToPoint(d,u,l),c.addPoint(l),o&&c.addUVParamAsUV(d,u),a&&c.addFraction(h);return c}}class tr{static pointsClone(){const t=[];for(const e of this.points)t.push(e.clone());return t}}tr.points=[j.create(0,0,0),j.create(1,0,0),j.create(0,1,0),j.create(1,1,0),j.create(0,0,1),j.create(1,0,1),j.create(0,1,1),j.create(1,1,1)],tr.primaryCapId=-1,tr.cornerIndexCCW=[[1,0,2,3],[4,5,7,6],[0,1,5,4],[1,3,7,5],[3,2,6,7],[2,0,4,6]],tr.partnerFace=[[5,4,3,2],[2,3,4,5],[0,3,1,5],[0,4,1,2],[0,5,1,3],[0,2,1,4]],tr.faceId=[[tr.primaryCapId,0],[tr.primaryCapId,1],[0,0],[0,1],[0,2],[0,3]],tr.faceDirections=[[[0,1,2],[-1,1,-1]],[[0,1,2],[1,1,1]],[[0,2,1],[1,-1,1]],[[1,2,0],[1,1,1]],[[0,2,1],[-1,1,1]],[[1,2,0],[-1,1,-1]]],tr.axisEdgeVertex=[[[0,1],[2,3],[4,5],[6,7]],[[0,2],[1,3],[4,6],[5,7]],[[0,4],[1,5],[2,6],[3,7]]];class er{constructor(t,e,i){this.points=t,this.begin=e,this.end=i}static createComplete(t){return new this(t,0,t.length)}static createBeginEnd(t,e,i){return new this(t,e,i)}static createBeginLength(t,e,i){return new this(t,e,e+i)}advanceBegin(){return this.begin++,this.begin<this.end}advanceEnd(){return this.end++,this.end>this.points.length&&(this.end=this.points.length),this.begin<this.end}localIndexToParentIndex(t){if(t>=0){const e=this.begin+t;if(e<this.points.length)return e}}get isValidSubset(){return 0===this.length||void 0!==this.localIndexToParentIndex(0)&&void 0!==this.localIndexToParentIndex(this.length-1)}restrictEnd(){this.end>this.points.length&&(this.end=this.points.length)}get isNonEmpty(){return this.begin<this.end}advanceToTail(t){return this.begin=t.end-1,this.isNonEmpty}advanceToHead(t){return this.begin=t.begin,this.isNonEmpty}setFrom(t,e,i){this.points=t.points,this.begin=void 0===e?t.begin:e,this.end=void 0===i?t.end:i,this.restrictEnd()}get length(){return this.end>this.begin?this.end-this.begin:0}get isSingleton(){return this.begin+1===this.end}}class ir extends er{}class sr extends ls{constructor(t,e,i,s,n,r){super(t,e,i),this._isValid=r,this._quality=n,this.id=s}setFrom(t){return super.setFrom(t),this._isValid=t._isValid,this._quality=t._quality,this.id=t.id,this}static createFromIndexedXYZ(t,e,i,s,n,r,o,a){a||(a=new sr(j.create(),j.create(),j.create(),o,0,!1)),a.id=o;let c=0;return void 0!==t.getPoint3dAtCheckedPointIndex(e,a.points[0])&&c++,void 0!==i.getPoint3dAtCheckedPointIndex(s,a.points[1])&&c++,void 0!==n.getPoint3dAtCheckedPointIndex(r,a.points[2])&&c++,3===c?a.updateAspectRatio():a.markInvalid(),a}get isValid(){return this._isValid}markInvalid(t){this._isValid=!1,void 0!==t&&(this._quality=t)}updateAspectRatio(){this._quality=super.aspectRatio,this._isValid=this._quality>0}clone(t){return t?t.setFrom(this):new sr(this.points[0].clone(),this.points[1].clone(),this.points[2].clone(),this.id,this._quality,this._isValid)}static copyWithLowerQuality(t,e,i){if(i=t.clone(i),e.isValid){const s=t.dotProductOfCrossProductsFromOrigin(e);i._quality=Q.minXY(t.aspectRatio,e.aspectRatio),s<0&&(i._quality-=1)}return i}static updateIfOtherHasHigherQuality(t,e){e.isValid&&e._quality>t._quality&&t.setFrom(e)}}class nr{constructor(t){this._turnRadians=t,this._xyzA=j.create(),this._xyzB=j.create(),this._forwardA=$.create(),this._forwardB=$.create(),this._vector1=$.create(),this._crossA=$.create(),this._crossB=$.create()}isForwardVector(t,e,i){if(t.dotProduct(e)<=0)return!1;const s=t.angleFromPerpendicular(i);return!(Math.abs(s.radians)>this._turnRadians)}isPlanarBase(t,e,i,s,n,r,o,a,c,l){return e+1<t.length&&s+1<i.length&&(t.getPoint3dAtUncheckedPointIndex(e,n),i.getPoint3dAtUncheckedPointIndex(s,a),t.vectorXYAndZIndex(n,e+1,o),i.vectorXYAndZIndex(a,s+1,l),$.createStartEnd(n,a,this._vector1),this._vector1.crossProduct(o,r),this._vector1.crossProduct(l,c),!n.isAlmostEqual(a)&&r.angleTo(c).radians<this._turnRadians)}advanceToPlanarLimit(t,e,i,s,n,r,o,a){for(e.setFrom(t,t.begin,i);e.end<t.end&&(e.points.vectorXYAndZIndex(s,e.end,this._vector1),this.isForwardVector(this._vector1,r,n))&&this.isForwardVector(this._vector1,a,o)&&(!(e.end>0)||(e.points.vectorIndexIndex(e.end-1,e.end,this._vector1),this.isForwardVector(this._vector1,r,n)));)e.end++}addGreedy(t,e,i,s=!1){for(t.restrictEnd(),e.restrictEnd();t.length>1&&e.length>1;)if(this._triangleA1=sr.createFromIndexedXYZ(t.points,t.begin,t.points,t.begin+1,e.points,e.begin,1,this._triangleA1),this._triangleA2=sr.createFromIndexedXYZ(t.points,t.begin+1,t.points,t.begin+2,e.points,e.begin,2,this._triangleA2),this._triangleA3=sr.createFromIndexedXYZ(t.points,t.begin,t.points,t.begin+1,e.points,e.begin+1,3,this._triangleA3),this._triangleB1=sr.createFromIndexedXYZ(e.points,e.begin+1,e.points,e.begin,t.points,t.begin,-1,this._triangleB1),this._triangleB2=sr.createFromIndexedXYZ(e.points,e.begin+2,e.points,e.begin+1,t.points,t.begin,-2,this._triangleB2),this._triangleB3=sr.createFromIndexedXYZ(e.points,e.begin+1,e.points,e.begin,t.points,t.begin+1,-3,this._triangleB3),this._bestTriangle=sr.copyWithLowerQuality(this._triangleA1,this._triangleB3,this._bestTriangle),this._workTriangle=sr.copyWithLowerQuality(this._triangleB1,this._triangleA3,this._workTriangle),sr.updateIfOtherHasHigherQuality(this._bestTriangle,this._workTriangle),this._bestTriangle.id>0){if(t.advanceBegin(),i(this._bestTriangle),s)return}else if(e.advanceBegin(),i(this._bestTriangle),s)return;if(t.isSingleton)for(;e.length>=2;)this._workTriangle=sr.createFromIndexedXYZ(e.points,e.begin+1,e.points,e.begin,t.points,t.begin,0,this._workTriangle),i(this._workTriangle),e.advanceBegin();if(e.isSingleton)for(;t.length>=2;)this._workTriangle=sr.createFromIndexedXYZ(t.points,t.begin,t.points,t.begin+1,e.points,e.begin,0,this._workTriangle),i(this._workTriangle),t.advanceBegin()}emitTriangles(t,e,i){this.emitTrianglesGo(rr(t),rr(e),i)}emitTrianglesGo(t,e,i){const s=ir.createComplete(t),n=ir.createComplete(e),r=ir.createComplete(t),o=ir.createComplete(e);for(;s.length>0&&n.length>0&&(s.length>1||n.length>1);)this.isPlanarBase(t,s.begin,e,n.begin,this._xyzA,this._crossA,this._forwardA,this._xyzB,this._crossB,this._forwardB)?(this.advanceToPlanarLimit(s,r,s.begin+1,this._xyzA,this._crossA,this._forwardA,this._crossB,this._forwardB),this.advanceToPlanarLimit(n,o,n.begin+1,this._xyzB,this._crossB,this._forwardB,this._crossA,this._forwardA),this.addGreedy(r,o,i),s.advanceToTail(r),n.advanceToTail(o)):this.isPlanarBase(t,s.begin+1,e,n.begin,this._xyzA,this._crossA,this._forwardA,this._xyzB,this._crossB,this._forwardB)?(r.setFrom(s,s.begin,s.begin+2),o.setFrom(n,n.begin,n.begin+1),this.addGreedy(r,o,i),s.advanceToTail(r),n.advanceToTail(o)):this.isPlanarBase(t,s.begin,e,n.begin+1,this._xyzA,this._crossA,this._forwardA,this._xyzB,this._crossB,this._forwardB)?(r.setFrom(s,s.begin,s.begin+1),o.setFrom(n,n.begin,n.begin+2),this.addGreedy(r,o,i),s.advanceToTail(r),n.advanceToTail(o)):s.length>1&&n.length>1?(r.setFrom(s,s.begin,s.begin+2),o.setFrom(n,n.begin,n.begin+2),this.addGreedy(r,o,i,!0),s.advanceToHead(r),n.advanceToHead(o)):s.length>1?(r.setFrom(s,s.begin,s.begin+2),o.setFrom(n),this.addGreedy(r,o,i),s.advanceToTail(r),n.advanceToTail(o)):n.length>1&&(r.setFrom(s),o.setFrom(n,n.begin,n.begin+2),this.addGreedy(r,o,i),s.advanceToTail(r),n.advanceToTail(o));this.addGreedy(s,n,i)}static createContext(t=this.defaultNearColinearAngle){return new nr(t.radians)}}function rr(t,e=Q.smallMetricDistance){let i=!1;const s=t.length;for(let n=0;n+1<s;n++)if(t.distanceIndexIndex(n,n+1)<=e){i=!0;break}if(!i)return t;const n=new nt(s);n.pushXYZ(t.getXAtUncheckedPointIndex(0),t.getYAtUncheckedPointIndex(0),t.getZAtUncheckedPointIndex(0));let r=0;for(let i=1;i<s;i++)t.distanceIndexIndex(r,i)>e&&(n.pushXYZ(t.getXAtUncheckedPointIndex(i),t.getYAtUncheckedPointIndex(i),t.getZAtUncheckedPointIndex(i)),r=i);return t.distanceIndexIndex(0,s-1)<=e&&(n.pop(),n.pushFromGrowableXYZArray(n,0)),n}nr.defaultNearColinearAngle=W.createDegrees(15);class or{constructor(t=!1,e=!1,i=!1){this.xyz=j.create(),this.normalIndex=-1,this.uvIndex=-1,this.xyzIndex=-1,t&&(this.normal=$.create()),e&&(this.uv=H.create(),this.uvIndex=-1),i&&(this.sectionDerivative=$.create())}copyContentsFrom(t){this.xyz.setFromPoint3d(t.xyz),this.xyzIndex=t.xyzIndex,this.normal&&this.normal.setFromVector3d(t.normal),this.normalIndex=t.normalIndex,this.uv&&this.uv.setFrom(t.uv),this.uvIndex=t.uvIndex,this.sectionDerivative&&this.sectionDerivative.setFrom(t.sectionDerivative)}loadIndexedPointAndDerivativeCoordinatesFromPackedArrays(t,e,i,s,n){e.getPoint3dAtCheckedPointIndex(t,this.xyz),this.uv&&s&&void 0!==n&&this.uv.set(s.atUncheckedIndex(t),n),this.xyzIndex=-1,this.normalIndex=-1,this.uvIndex=-1,void 0!==this.sectionDerivative&&void 0!==i&&i.getVector3dAtCheckedVectorIndex(t,this.sectionDerivative)}static suppressSmallUnitVectorComponents(t){const e=Q.smallFloatingPoint;Math.abs(t.x)<e&&(t.x=0),Math.abs(t.y)<e&&(t.y=0),Math.abs(t.z)<e&&(t.z=0)}static computeNormalsAlongRuleLine(t,e){if(t.sectionDerivative&&e.sectionDerivative){const i=or._edgeVector;$.createStartEnd(t.xyz,e.xyz,i),t.sectionDerivative.crossProduct(i,t.normal),e.sectionDerivative.crossProduct(i,e.normal),t.normal.normalizeInPlace(),e.normal.normalizeInPlace(),or.suppressSmallUnitVectorComponents(t.normal),or.suppressSmallUnitVectorComponents(e.normal)}}}or._edgeVector=$.create();class ar extends Pe{get options(){return this._options}get reversedFlag(){return this._reversed}claimPolyface(t=!0,e=Q.smallMetricDistance){return t&&this._polyface.data.compress(e),this._polyface}toggleReversedFacetFlag(){this._reversed=!this._reversed}constructor(t){super(),this._options=t||Ie.createForFacets(),this._polyface=ji.create(this._options.needNormals,this._options.needParams,this._options.needColors,this._options.needTwoSided),this._reversed=!1}static create(t){return new ar(t)}addTransformedUnitBox(t){this.addTransformedRangeMesh(t,ut.createXYZXYZ(0,0,0,1,1,1))}addTransformedRangeMesh(t,e,i){const s=this._polyface.data.pointCount,n=e.corners();for(const e of n)this._polyface.addPoint(t.multiplyPoint3d(e));let r=0;for(const t of tr.cornerIndexCCW){if(!i||r<i.length&&i[r]){const e=t.map((t=>t+s));this._reversed&&e.reverse(),this._options.shouldTriangulate?(this.addIndexedTrianglePointIndexes(e[0],e[1],e[2],!1),this.addIndexedTrianglePointIndexes(e[0],e[2],e[3],!1)):this.addIndexedQuadPointIndexes(e[0],e[1],e[3],e[2],!1),this._polyface.terminateFacet()}r++}}addTriangleFan(t,e,i){const s=e.numPoints();if(s>2){i&&this.toggleReversedFacetFlag();const n=this.addPoint(t);let r=this.findOrAddPointInLineString(e,0),o=0;for(let t=1;t<s;t++)o=this.findOrAddPointInLineString(e,t),this.addIndexedTrianglePointIndexes(n,r,o),r=o;i&&this.toggleReversedFacetFlag()}}addTrianglesInUncheckedConvexPolygon(t,e){const i=t.numPoints();if(i>2){let s,n;e&&this.toggleReversedFacetFlag(),this._options.needNormals&&(s=t.quickUnitNormal(ar._workVectorFindOrAdd),e&&s.scaleInPlace(-1),n=this._polyface.addNormal(s));const r=this._options.needParams?t.packedUVParams:void 0;let o=-1,a=-1,c=-1;r&&(o=this.addParamInGrowableXYArray(r,0),a=this.addParamInGrowableXYArray(r,1));const l=this.findOrAddPointInLineString(t,0);let h=this.findOrAddPointInLineString(t,1),d=0,u=i;t.isPhysicallyClosed&&u--;for(let e=2;e<u;e++,h=d,a=c)d=this.findOrAddPointInLineString(t,e),this.addIndexedTrianglePointIndexes(l,h,d,!1),void 0!==n&&this.addIndexedTriangleNormalIndexes(n,n,n),r&&(c=this.addParamInGrowableXYArray(r,e),this.addIndexedTriangleParamIndexes(o,a,c)),this._polyface.terminateFacet();e&&this.toggleReversedFacetFlag()}}addPoint(t){return this._polyface.addPoint(t)}findOrAddPoint(t){return this.addPoint(t)}addParamXY(t,e){return this._polyface.addParamUV(t,e)}findOrAddParamXY(t,e){return this.addParamXY(t,e)}findOrAddPointInLineString(t,e,i,s){const n=t.pointAt(e,ar._workPointFindOrAddA);if(n)return i&&i.multiplyPoint3d(n,n),this._polyface.addPoint(n,s)}findOrAddPointInGrowableXYZArray(t,e,i,s){const n=t.getPoint3dAtCheckedPointIndex(e,ar._workPointFindOrAddA);if(n)return i&&i.multiplyPoint3d(n,n),this._polyface.addPoint(n,s)}findOrAddNormalInGrowableXYZArray(t,e,i,s){const n=t.getVector3dAtCheckedVectorIndex(e,ar._workVectorFindOrAdd);if(n)return i&&i.multiplyVector(n,n),this._polyface.addNormal(n,s)}addParamInGrowableXYArray(t,e){if(!t)return;const i=t.getPoint2dAtCheckedPointIndex(e,ar._workUVFindOrAdd);return i?this._polyface.addParam(i):void 0}findOrAddParamInGrowableXYArray(t,e){return this.addParamInGrowableXYArray(t,e)}findOrAddParamInLineString(t,e,i,s,n){const r=t.fractions&&e<t.fractions.length?t.fractions.atUncheckedIndex(e):e/t.points.length;return this._polyface.addParamUV(r,i,s,n)}findOrAddNormalInLineString(t,e,i,s,n){const r=t.packedSurfaceNormals;if(r){const t=r.getVector3dAtCheckedVectorIndex(e,ar._workVectorFindOrAdd);if(t)return i&&i.multiplyVector(t,t),this._polyface.addNormal(t,s,n)}}addPointXYZ(t,e,i){return this._polyface.addPointXYZ(t,e,i)}findOrAddPointXYZ(t,e,i){return this.addPointXYZ(t,e,i)}getUVTransformForTriangleFacet(t,e,i){const s=t.vectorTo(e),n=t.vectorTo(i),r=xt.createRigidFromColumns(s,n,g.XYZ);return pt.createOriginAndMatrix(t,r).inverse()}getNormalForTriangularFacet(t,e,i){const s=t.vectorTo(e),n=t.vectorTo(i);let r=s.crossProduct(n).normalize();return r=r||$.create(),r}addQuadFacet(t,e,i,s){if(t instanceof nt&&(t=t.getPoint3dArray()),t.length<4)return;const n=this.options.needParams,r=this.options.needNormals,o=this.options.needColors;let a,c,l,h,d,u,f,g,p,m,x,_,y,v,P,A;if(n)if(void 0!==e&&e.length>3)a=e[0],c=e[1],l=e[2],h=e[3];else{const e=this.getUVTransformForTriangleFacet(t[0],t[1],t[2]);void 0===e?a=c=l=h=H.createZero():(a=H.createFrom(e.multiplyPoint3d(t[0])),c=H.createFrom(e.multiplyPoint3d(t[1])),l=H.createFrom(e.multiplyPoint3d(t[2])),h=H.createFrom(e.multiplyPoint3d(t[3])))}if(r&&(void 0!==i&&i.length>3?(d=i[0],u=i[1],f=i[2],g=i[3]):(d=this.getNormalForTriangularFacet(t[0],t[1],t[2]),u=this.getNormalForTriangularFacet(t[0],t[1],t[2]),f=this.getNormalForTriangularFacet(t[0],t[1],t[2]),g=this.getNormalForTriangularFacet(t[0],t[1],t[2]))),o&&void 0!==s&&s.length>3&&(p=s[0],m=s[1],x=s[2],_=s[3]),this._options.shouldTriangulate){const e=t[0].vectorTo(t[2]),i=t[1].vectorTo(t[3]);e.magnitude()>=i.magnitude()?(this.addTriangleFacet([t[0],t[1],t[2]],n?[a,c,l]:void 0,r?[d,u,f]:void 0,o?[p,m,x]:void 0),this.addTriangleFacet([t[0],t[2],t[3]],n?[a,l,h]:void 0,r?[d,f,g]:void 0,o?[p,x,_]:void 0)):(this.addTriangleFacet([t[0],t[1],t[3]],n?[a,c,h]:void 0,r?[d,u,g]:void 0,o?[p,m,_]:void 0),this.addTriangleFacet([t[1],t[2],t[3]],n?[c,l,h]:void 0,r?[u,f,g]:void 0,o?[m,x,_]:void 0))}else n&&(y=this._polyface.addParam(a),v=this._polyface.addParam(c),P=this._polyface.addParam(l),A=this._polyface.addParam(h),this.addIndexedQuadParamIndexes(y,v,A,P)),r&&(y=this._polyface.addNormal(d),v=this._polyface.addNormal(u),P=this._polyface.addNormal(f),A=this._polyface.addNormal(g),this.addIndexedQuadNormalIndexes(y,v,A,P)),o&&(y=this._polyface.addColor(p),v=this._polyface.addColor(m),P=this._polyface.addColor(x),A=this._polyface.addColor(_),this.addIndexedQuadColorIndexes(y,v,A,P)),y=this.addPoint(t[0]),v=this.addPoint(t[1]),P=this.addPoint(t[2]),A=this.addPoint(t[3]),this.addIndexedQuadPointIndexes(y,v,A,P)}addIndexedQuadPointIndexes(t,e,i,s,n=!0){this._reversed?(this._polyface.addPointIndex(t),this._polyface.addPointIndex(i),this._polyface.addPointIndex(s),this._polyface.addPointIndex(e)):(this._polyface.addPointIndex(t),this._polyface.addPointIndex(e),this._polyface.addPointIndex(s),this._polyface.addPointIndex(i)),n&&this._polyface.terminateFacet()}addIndexedQuadParamIndexes(t,e,i,s){this._reversed?(this._polyface.addParamIndex(t),this._polyface.addParamIndex(i),this._polyface.addParamIndex(s),this._polyface.addParamIndex(e)):(this._polyface.addParamIndex(t),this._polyface.addParamIndex(e),this._polyface.addParamIndex(s),this._polyface.addParamIndex(i))}addIndexedQuadNormalIndexes(t,e,i,s){this._reversed?(this._polyface.addNormalIndex(t),this._polyface.addNormalIndex(i),this._polyface.addNormalIndex(s),this._polyface.addNormalIndex(e)):(this._polyface.addNormalIndex(t),this._polyface.addNormalIndex(e),this._polyface.addNormalIndex(s),this._polyface.addNormalIndex(i))}addIndexedQuadColorIndexes(t,e,i,s){this._reversed?(this._polyface.addColorIndex(t),this._polyface.addColorIndex(i),this._polyface.addColorIndex(s),this._polyface.addColorIndex(e)):(this._polyface.addColorIndex(t),this._polyface.addColorIndex(e),this._polyface.addColorIndex(s),this._polyface.addColorIndex(i))}addTriangleFacet(t,e,i,s){if(t.length<3)return;let n,r,o,a,c,l;if(t instanceof nt?(a=t.getPoint3dAtCheckedPointIndex(0),c=t.getPoint3dAtCheckedPointIndex(1),l=t.getPoint3dAtCheckedPointIndex(2)):(a=t[0],c=t[1],l=t[2]),this._options.needParams){if(e&&e.length>=3)n=this._polyface.addParam(e[0]),r=this._polyface.addParam(e[1]),o=this._polyface.addParam(e[2]);else{const t=this.getUVTransformForTriangleFacet(a,c,l);n=this._polyface.addParam(H.createFrom(t?t.multiplyPoint3d(a):void 0)),r=this._polyface.addParam(H.createFrom(t?t.multiplyPoint3d(c):void 0)),o=this._polyface.addParam(H.createFrom(t?t.multiplyPoint3d(c):void 0))}this.addIndexedTriangleParamIndexes(n,r,o)}if(this._options.needNormals){if(void 0!==i&&i.length>2)n=this._polyface.addNormal(i[0]),r=this._polyface.addNormal(i[1]),o=this._polyface.addNormal(i[2]);else{const t=this.getNormalForTriangularFacet(a,c,l);n=this._polyface.addNormal(t),r=this._polyface.addNormal(t),o=this._polyface.addNormal(t)}this.addIndexedTriangleNormalIndexes(n,r,o)}this._options.needColors&&void 0!==s&&s.length>2&&(n=this._polyface.addColor(s[0]),r=this._polyface.addColor(s[1]),o=this._polyface.addColor(s[2]),this.addIndexedTriangleColorIndexes(n,r,o)),n=this.addPoint(a),r=this.addPoint(c),o=this.addPoint(l),this.addIndexedTrianglePointIndexes(n,r,o)}addIndexedTrianglePointIndexes(t,e,i,s=!0){this._reversed?(this._polyface.addPointIndex(t),this._polyface.addPointIndex(i),this._polyface.addPointIndex(e)):(this._polyface.addPointIndex(t),this._polyface.addPointIndex(e),this._polyface.addPointIndex(i)),s&&this._polyface.terminateFacet()}addIndexedTriangleParamIndexes(t,e,i){this._reversed?(this._polyface.addParamIndex(t),this._polyface.addParamIndex(i),this._polyface.addParamIndex(e)):(this._polyface.addParamIndex(t),this._polyface.addParamIndex(e),this._polyface.addParamIndex(i))}addIndexedTriangleNormalIndexes(t,e,i){this._reversed?(this._polyface.addNormalIndex(t),this._polyface.addNormalIndex(i),this._polyface.addNormalIndex(e)):(this._polyface.addNormalIndex(t),this._polyface.addNormalIndex(e),this._polyface.addNormalIndex(i))}addIndexedTriangleColorIndexes(t,e,i){this._reversed?(this._polyface.addColorIndex(t),this._polyface.addColorIndex(i),this._polyface.addColorIndex(e)):(this._polyface.addColorIndex(t),this._polyface.addColorIndex(e),this._polyface.addColorIndex(i))}setSectorIndices(t){t.xyzIndex=this.addPoint(t.xyz),t.normal&&(t.normalIndex=this._polyface.addNormal(t.normal)),t.uv&&(t.uvIndex=this._polyface.addParam(t.uv))}addSectorTriangle(t,e,i){t.xyz.isAlmostEqual(e.xyz)||e.xyz.isAlmostEqual(i.xyz)||i.xyz.isAlmostEqual(t.xyz)||(this._options.needNormals&&this.addIndexedTriangleNormalIndexes(t.normalIndex,e.normalIndex,i.normalIndex),this._options.needParams&&this.addIndexedTriangleParamIndexes(t.uvIndex,e.uvIndex,i.uvIndex),this.addIndexedTrianglePointIndexes(t.xyzIndex,e.xyzIndex,i.xyzIndex,!0))}addSectorQuadA01B01(t,e,i,s){t.xyz.isAlmostEqual(e.xyz)&&i.xyz.isAlmostEqual(s.xyz)||(this._options.shouldTriangulate?(this.addSectorTriangle(t,e,s),this.addSectorTriangle(s,i,t)):(this._options.needNormals&&this.addIndexedQuadNormalIndexes(t.normalIndex,e.normalIndex,i.normalIndex,s.normalIndex),this._options.needParams&&this.addIndexedQuadParamIndexes(t.uvIndex,e.uvIndex,i.uvIndex,s.uvIndex),this.addIndexedQuadPointIndexes(t.xyzIndex,e.xyzIndex,i.xyzIndex,s.xyzIndex,!0)))}addBetweenLineStringsWithRuleEdgeNormals(t,e,i,s,n=!1){const r=t.packedPoints,o=i.packedPoints,a=t.packedDerivatives,c=i.packedDerivatives,l=t.fractions,h=i.fractions,d=this._options.needNormals,u=this._options.needParams,f=new or(d,u,d),g=new or(d,u,d),p=new or(d,u,d),m=new or(d,u,d),x=new or(d,u,d),_=new or(d,u,d),y=r.length;if(!(y<2||y!==o.length)){f.loadIndexedPointAndDerivativeCoordinatesFromPackedArrays(0,r,a,l,e),p.loadIndexedPointAndDerivativeCoordinatesFromPackedArrays(0,o,c,h,s),d&&or.computeNormalsAlongRuleLine(f,p),this.setSectorIndices(f),this.setSectorIndices(p),x.copyContentsFrom(f),_.copyContentsFrom(p);for(let t=1;t<y;t++)g.loadIndexedPointAndDerivativeCoordinatesFromPackedArrays(t,r,a,l,e),m.loadIndexedPointAndDerivativeCoordinatesFromPackedArrays(t,o,a,h,s),or.computeNormalsAlongRuleLine(g,m),this.setSectorIndices(g),this.setSectorIndices(m),this.addSectorQuadA01B01(f,g,p,m),f.copyContentsFrom(g),p.copyContentsFrom(m);n&&this.addSectorQuadA01B01(f,x,p,_)}}addBetweenLineStringsWithStoredIndices(t,e){const i=t.pointIndices,s=e.pointIndices;let n=t.normalIndices,r=e.normalIndices;this._options.needNormals||(n=void 0,r=void 0);let o=t.paramIndices,a=e.paramIndices;this._options.needParams||(o=void 0,a=void 0);const c=i.length;for(let t=1;t<c;t++)this.options.shouldTriangulate?(lr(i.atUncheckedIndex(t-1),i.atUncheckedIndex(t),s.atUncheckedIndex(t))&&(this.addIndexedTrianglePointIndexes(i.atUncheckedIndex(t-1),i.atUncheckedIndex(t),s.atUncheckedIndex(t),!1),n&&r&&this.addIndexedTriangleNormalIndexes(n.atUncheckedIndex(t-1),n.atUncheckedIndex(t),r.atUncheckedIndex(t-1)),o&&a&&this.addIndexedTriangleParamIndexes(o.atUncheckedIndex(t-1),o.atUncheckedIndex(t),a.atUncheckedIndex(t-1))),lr(s.atUncheckedIndex(t),s.atUncheckedIndex(t-1),i.atUncheckedIndex(t-1))&&(this.addIndexedTrianglePointIndexes(i.atUncheckedIndex(t-1),s.atUncheckedIndex(t),s.atUncheckedIndex(t-1),!1),n&&r&&this.addIndexedTriangleNormalIndexes(n.atUncheckedIndex(t-1),r.atUncheckedIndex(t),r.atUncheckedIndex(t-1)),o&&a&&this.addIndexedTriangleParamIndexes(o.atUncheckedIndex(t-1),a.atUncheckedIndex(t),a.atUncheckedIndex(t-1)))):i.atUncheckedIndex(t-1)===i.atUncheckedIndex(t)&&s.atUncheckedIndex(t-1)===s.atUncheckedIndex(t)||(this.addIndexedQuadPointIndexes(i.atUncheckedIndex(t-1),i.atUncheckedIndex(t),s.atUncheckedIndex(t-1),s.atUncheckedIndex(t),!1),n&&r&&this.addIndexedQuadNormalIndexes(n.atUncheckedIndex(t-1),n.atUncheckedIndex(t),r.atUncheckedIndex(t-1),r.atUncheckedIndex(t)),o&&a&&this.addIndexedQuadParamIndexes(o.atUncheckedIndex(t-1),o.atUncheckedIndex(t),a.atUncheckedIndex(t-1),a.atUncheckedIndex(t))),this._polyface.terminateFacet()}addBetweenTransformedLineStrings(t,e,i,s=!1){if(t instanceof Me){const n=t.points.length;let r=this.findOrAddPointInLineString(t,0,e),o=this.findOrAddPointInLineString(t,0,i);const a=r,c=o;let l=0,h=0;for(let s=1;s<n;s++)l=this.findOrAddPointInLineString(t,s,e),h=this.findOrAddPointInLineString(t,s,i),this.addIndexedQuadPointIndexes(r,l,o,h),r=l,o=h;s&&this.addIndexedQuadPointIndexes(r,a,o,c)}else{const s=t.children;if(s)for(const t of s)this.addBetweenTransformedLineStrings(t,e,i)}}addBetweenStrokeSetPair(t,e,i,s){if(t instanceof Me&&i instanceof Me)this.addBetweenLineStringsWithRuleEdgeNormals(t,e,i,s,!1);else if(t instanceof bi&&i instanceof bi){if(t.children.length===i.children.length)for(let n=0;n<t.children.length;n++)this.addBetweenStrokeSetPair(t.children[n],e,i.children[n],s)}else if(t instanceof ni&&i instanceof ni){const n=t.children,r=i.children;if(n.length===r.length)for(let t=0;t<n.length;t++){const i=n[t],o=r[t];i instanceof Me&&o instanceof Me&&this.addBetweenLineStringsWithRuleEdgeNormals(i,e,o,s)}}}addCone(t){let e=16;this._options&&(e=this._options.applyTolerancesToArc(t.getMaxRadius()));let i=1;const s=t.strokeConstantVSection(0,e,this._options),n=t.strokeConstantVSection(1,e,this._options);if(this._options){const t=nt.distanceRangeBetweenCorrespondingPoints(s.packedPoints,n.packedPoints);i=this._options.applyMaxEdgeLength(1,t.low)}const r=t.maxIsoParametricDistance();this.addUVGridBody(t,e,i,Re.create(0,r.x),Re.create(0,r.y)),this.endFace(),t.capped&&(Q.isSmallMetricDistance(t.getRadiusA())||(this.addTrianglesInUncheckedConvexPolygon(s,!0),this.endFace()),Q.isSmallMetricDistance(t.getRadiusB())||(this.addTrianglesInUncheckedConvexPolygon(n,!1),this.endFace()))}addTorusPipe(t,e,i){const s=t.getThetaFraction();let n=Q.clamp(Q.resolveNumber(e,8),4,64),r=Q.clamp(Q.resolveNumber(i,Math.ceil(16*s)),2,64);this._options&&(n=this._options.applyTolerancesToArc(t.getMinorRadius()),r=this._options.applyTolerancesToArc(t.getMajorRadius(),t.getSweepAngle().radians)),this.toggleReversedFacetFlag();const o=t.maxIsoParametricDistance();if(this.addUVGridBody(t,n,r,Re.create(0,o.x),Re.create(0,o.y)),this.toggleReversedFacetFlag(),t.capped&&s<1){const e=t.getConstructiveFrame(),i=t.getMinorRadius(),s=t.getMajorRadius(),r=2*i,o=s-i,a=s+i,c=-i,l=pt.createRowValues(r,0,0,o,0,0,-1,0,0,r,0,c),h=e.multiplyTransformTransform(l).inverse();if(h){const e=$n.createLinestringOnUVLine(t,0,0,1,0,n,!1,!0);e.computeUVFromXYZTransform(h),this.addTrianglesInUncheckedConvexPolygon(e,!1)}const d=t.getSweepAngle().radians,u=Math.cos(d),f=Math.sin(d),g=pt.createRowValues(-u*r,0,-f,a*u,-f*r,0,u,a*f,0,r,0,c),p=e.multiplyTransformTransform(g).inverse();if(p){const e=$n.createLinestringOnUVLine(t,1,1,0,1,n,!1,!0);e.computeUVFromXYZTransform(p),this.addTrianglesInUncheckedConvexPolygon(e,!1)}}}addLinearSweepLineStringsXYZOnly(t,e){if(t instanceof Me){let i=j.create(),s=j.create(),n=0,r=0,o=0,a=0;const c=t.numPoints();for(let l=0;l<c;l++)i=t.pointAt(l,i),s=i.plus(e,s),r=this.addPoint(i),a=this.addPoint(s),l>0&&this.addIndexedQuadPointIndexes(n,r,o,a),n=r,o=a}else if(t instanceof ni)for(const i of t.children)this.addLinearSweepLineStringsXYZOnly(i,e)}addRotationalSweep(t){const e=t.getCurves(),i=Jn.createForParityRegionOrChain(e,this._options).getStrokes(),s=t.cloneAxisRay(),n=Zn.computeMaxVectorFromRay(s,i),r=s.direction.crossProduct(n);this._options.needNormals&&Zn.buildRotationalNormalsInLineStrings(i,s,r);const o=n.magnitude(),a=Math.abs(o*t.getSweep().radians);let c=Ie.applyAngleTol(this._options,1,t.getSweep().radians,void 0);c=Ie.applyMaxEdgeLength(this._options,c,a);for(let e=1;e<=c;e++){const s=t.getFractionalRotationTransform((e-1)/c),n=t.getFractionalRotationTransform(e/c);this.addBetweenRotatedStrokeSets(i,s,e-1,n,e)}if(t.capped){const e=t.getSweepContourRef();e.purgeFacets(),e.emitFacets(this,!0,void 0),e.emitFacets(this,!1,t.getFractionalRotationTransform(1))}}addTriangulatedRegion(t){const e=Mn.createForLinearSweep(t);e&&e.emitFacets(this,this.reversedFlag,void 0)}applyStrokeCountsToCurvePrimitives(t){const e=this._options;if(t instanceof ae)t.computeStrokeCountForOptions(e);else if(t instanceof si){const e=t.children;if(e)for(const t of e)this.applyStrokeCountsToCurvePrimitives(t)}}addBetweenStrokeSetsWithRuledNormals(t,e,i){const s=[t],n=[0];for(let r=1;r<i;r++){const o=r/i,a=Ri.interpolateBetween(t,r/i,e);s.push(a),n.push(o)}s.push(e),n.push(1);for(let t=0;t<i;t++)this.addBetweenStrokeSetPair(s[t],n[t],s[t+1],n[t+1])}createIndicesInLineString(t,e,i){const s=t.numPoints(),n=t.ensureEmptyPointIndices(),r=this.findOrAddPointInLineString(t,0,i);if(n.push(r),s>1){let e,o=r;for(let r=1;r+1<s;r++)e=this.findOrAddPointInLineString(t,r,i,o),n.push(e),o=e;e=this.findOrAddPointInLineString(t,s-1,i,r),n.push(e)}if(this._options.needNormals&&void 0!==t.packedSurfaceNormals){const e=t.ensureEmptyNormalIndices(),n=this.findOrAddNormalInLineString(t,0,i);e.push(n);let r,o=n;if(s>1){for(let n=1;n+1<s;n++)r=this.findOrAddNormalInLineString(t,n,i,o),e.push(r),o=r;r=this.findOrAddNormalInLineString(t,s-1,i,n,o),e.push(r)}}if(this._options.needParams&&void 0!==t.packedUVParams){const i=t.ensureEmptyUVIndices(),n=this.findOrAddParamInLineString(t,0,e);i.push(n);let r,o=n;if(s>1){for(let n=1;n+1<s;n++)r=this.findOrAddParamInLineString(t,n,e,o),i.push(r),o=r;r=this.findOrAddParamInLineString(t,s-1,e,o,n),i.push(r)}}}addBetweenRotatedStrokeSets(t,e,i,s,n){if(t instanceof Me){const r=t.cloneTransformed(e);this.createIndicesInLineString(r,i);const o=t.cloneTransformed(s);this.createIndicesInLineString(o,n),this.addBetweenLineStringsWithStoredIndices(r,o)}else if(t instanceof bi)for(const r of t.children)this.addBetweenRotatedStrokeSets(r,e,i,s,n);else if(t instanceof ni)for(const r of t.children)r instanceof Me&&this.addBetweenRotatedStrokeSets(r,e,i,s,n)}addLinearSweep(t){const e=t.getCurvesRef(),i=Jn.createForParityRegionOrChain(e,this._options).getStrokes(),s=t.cloneSweepVector(),n=pt.createTranslation(s),r=i.cloneTransformed(n),o=this._options.applyMaxEdgeLength(1,s.magnitude());if(this.addBetweenStrokeSetsWithRuledNormals(i,r,o),t.capped&&e.isAnyRegionType){const e=t.getSweepContourRef();e.purgeFacets();const i=e.localToWorld.matrix.dotColumnZ(s)>0;e.emitFacets(this,i,void 0),e.emitFacets(this,!i,n)}}addRuledSweep(t){const e=t.sweepContoursRef();let i,s;const n=[];for(const t of e)n.push(Jn.createForParityRegionOrChain(t.curves,this._options));if(Jn.enforceStrokeCountCompatibility(n)){Jn.enforceCompatibleDistanceSums(n);for(let t=0;t<e.length;t++){if(s=n[t].getStrokes(),s||(s=e[t].curves.cloneStroked()),t>0&&i&&s){const t=ft.createNull();if(Jn.extendDistanceRangeBetweenStrokes(i,s,t)&&!t.isNull){const e=this._options.applyMaxEdgeLength(1,t.high);this.addBetweenStrokeSetsWithRuledNormals(i,s,e)}}i=s}}return t.capped&&e[0].curves.isAnyRegionType&&(e[0].purgeFacets(),e[0].emitFacets(this,!0,void 0),e[e.length-1].purgeFacets(),e[e.length-1].emitFacets(this,!1,void 0)),!0}addSphere(t,e){let i=e||this.options.applyTolerancesToArc(t.maxAxisRadius());Q.isOdd(i)&&(i+=1);const s=Q.clampToStartEnd(Math.abs(i*t.latitudeSweepFraction),1,Math.ceil(.5*i)),n=t.strokeConstantVSection(0,i,this._options);t.capped&&!Q.isSmallMetricDistance(n.quickLength())&&(this.addTrianglesInUncheckedConvexPolygon(n,!0),this.endFace());const r=t.maxIsoParametricDistance();this.addUVGridBody(t,i,s,Re.create(0,r.x),Re.create(0,r.y)),this.endFace();const o=t.strokeConstantVSection(1,i,this._options);t.capped&&!Q.isSmallMetricDistance(o.quickLength())&&(this.addTrianglesInUncheckedConvexPolygon(o,!1),this.endFace())}addBox(t){const e=t.getCorners(),i=Q.maxXY(t.getBaseX(),t.getBaseX()),s=Q.maxXY(t.getBaseY(),t.getTopY());let n=0;for(let t=0;t<4;t++)n=Q.maxXY(n,e[t].distance(e[t+4]));const r=this._options.applyMaxEdgeLength(1,i),o=this._options.applyMaxEdgeLength(1,s),a=this._options.applyMaxEdgeLength(1,n),c=Re.create(0,i),l=Re.create(0,n);this.addUVGridBody(jn.create(e[0],e[1],e[4],e[5]),r,a,c,l),c.shift(i),this.addUVGridBody(jn.create(e[1],e[3],e[5],e[7]),o,a,c,l),c.shift(s),this.addUVGridBody(jn.create(e[3],e[2],e[7],e[6]),r,a,c,l),c.shift(i),this.addUVGridBody(jn.create(e[2],e[0],e[6],e[4]),o,a,c,l),this.endFace(),t.capped&&(c.set(0,i),l.set(0,s),this.addUVGridBody(jn.create(e[4],e[5],e[6],e[7]),r,o,c,l),this.endFace(),c.set(0,i),l.set(0,s),this.addUVGridBody(jn.create(e[2],e[3],e[0],e[1]),r,o,c,l),this.endFace())}addPolygon(t,e){for(void 0===e&&(e=t.length);e>1&&t[e-1].isAlmostEqual(t[0]);)e--;let i=0;if(this._reversed)for(let s=e;--s>=0;)i=this.addPoint(t[s]),this._polyface.addPointIndex(i);else for(let s=0;s<e;s++)i=this.addPoint(t[s]),this._polyface.addPointIndex(i);this._polyface.terminateFacet()}addPolygonGrowableXYZArray(t){let e=t.length;for(;e>2&&Q.isSmallMetricDistance(t.distanceIndexIndex(0,e-1));)e--;for(;e>2&&Q.isSmallMetricDistance(t.distanceIndexIndex(e-2,e-1));)e--;if(3===e){const i=t.crossProductIndexIndexIndex(0,1,2).magnitude(),s=t.distanceIndexIndex(0,1)+t.distanceIndexIndex(0,2)+t.distanceIndexIndex(1,2);i<Q.smallMetricDistance*s&&(e=0)}if(e>2){let i=0;if(this._reversed)for(let s=e;--s>=0;)i=this.findOrAddPointInGrowableXYZArray(t,s),this._polyface.addPointIndex(i);else for(let s=0;s<e;s++)i=this.findOrAddPointInGrowableXYZArray(t,s),this._polyface.addPointIndex(i);this._polyface.terminateFacet()}}addFacetFromGrowableArrays(t,e,i,s,n){let r=t.length;for(;r>1&&Q.isSmallMetricDistance(t.distanceIndexIndex(0,r-1));)r--;let o=0;if(e&&e.length<r&&(e=void 0),i&&i.length<r&&(i=void 0),s&&s.length<r&&(s=void 0),n&&n.length<r&&(n=void 0),this._reversed)for(let n=r;--n>=0;)o=this.findOrAddPointInGrowableXYZArray(t,n),this._polyface.addPointIndex(o),e&&(o=this.findOrAddNormalInGrowableXYZArray(e,n),this._polyface.addNormalIndex(o)),i&&(o=this.addParamInGrowableXYArray(i,n),this._polyface.addParamIndex(o)),s&&(o=this._polyface.addColor(s[n]),this._polyface.addColorIndex(o));else for(let a=0;a<r;a++)o=this.findOrAddPointInGrowableXYZArray(t,a),this._polyface.addPointIndex(o,!n||n[a]),e&&(o=this.findOrAddNormalInGrowableXYZArray(e,a),this._polyface.addNormalIndex(o)),i&&(o=this.addParamInGrowableXYArray(i,a),this._polyface.addParamIndex(o)),s&&(o=this._polyface.addColor(s[a]),this._polyface.addColorIndex(o));this._polyface.terminateFacet()}addFacetFromVisitor(t){this.addFacetFromGrowableArrays(t.point,t.normal,t.param,t.color,t.edgeVisible)}addFacetsFromVisitor(t){for(t.reset();t.moveToNextFacet();)this.addFacetFromVisitor(t)}addFacetFromIndexedVisitor(t,e){if(e.length>t.pointIndex.length)return!1;const i=new nt(e.length),s=t.normal?new nt(e.length):void 0,n=t.param?new Fe(e.length):void 0,r=t.color?new Array(e.length):void 0,o=t.edgeVisible?new Array(e.length):void 0;for(let a=0;a<e.length;++a){const c=e[a];if(c<0||c>=t.point.length)return!1;i.pushXYZ(t.point.getXAtUncheckedPointIndex(c),t.point.getYAtUncheckedPointIndex(c),t.point.getZAtUncheckedPointIndex(c)),t.normal&&s&&s.pushXYZ(t.normal.getXAtUncheckedPointIndex(c),t.normal.getYAtUncheckedPointIndex(c),t.normal.getZAtUncheckedPointIndex(c)),t.param&&n&&n.pushXY(t.param.getXAtUncheckedPointIndex(c),t.param.getYAtUncheckedPointIndex(c)),t.color&&r&&(r[a]=t.color[c]),t.edgeVisible&&o&&(o[a]=t.edgeVisible[c])}return this.addFacetFromGrowableArrays(i,s,n,r,o),!0}addIndexedPolyface(t,e=!1,i){this._polyface.addIndexedPolyface(t,e,i)}endFace(){return this._polyface.setNewFaceData()}handleCone(t){return this.addCone(t)}handleTorusPipe(t){return this.addTorusPipe(t)}handleSphere(t){return this.addSphere(t)}handleBox(t){return this.addBox(t)}handleLinearSweep(t){return this.addLinearSweep(t)}handleRotationalSweep(t){return this.addRotationalSweep(t)}handleRuledSweep(t){return this.addRuledSweep(t)}handleLoop(t){return this.addTriangulatedRegion(t)}handleParityRegion(t){return this.addTriangulatedRegion(t)}handleUnionRegion(t){return this.addTriangulatedRegion(t)}addGeometryQuery(t){t.dispatchToGeometryHandler(this)}addGraph(t,e=t=>us.testNodeMaskNotExterior(t),i=t=>us.testMateMaskExterior(t)){let s=0;const n=this._options.needNormals,r=this._options.needParams;let o=0;n&&(o=this._polyface.addNormalXYZ(0,0,1)),t.announceFaceLoops(((t,a)=>{if(e(a)&&a.countEdgesAroundFace()>2){let t=a;do{s=this.addPointXYZ(t.x,t.y,t.z),this._polyface.addPointIndex(s,void 0===i||i(t)),r&&(s=this.addParamXY(t.x,t.y),this._polyface.addParamIndex(s)),n&&this._polyface.addNormalIndex(o),t=t.faceSuccessor}while(t!==a);this._polyface.terminateFacet()}return!0}))}addGraphFaces(t){let e=0;for(const i of t){let t=i;do{e=this.addPointXYZ(t.x,t.y,t.z),this._polyface.addPointIndex(e),t=t.faceSuccessor}while(t!==i);this._polyface.terminateFacet()}}static graphToPolyface(t,e,i=t=>us.testNodeMaskNotExterior(t),s=t=>us.testMateMaskExterior(t)){const n=ar.create(e);return n.addGraph(t,i,s),n.endFace(),n.claimPolyface()}static graphFacesToPolyface(t){const e=ar.create();return e.addGraphFaces(t),e.endFace(),e.claimPolyface()}static polygonToTriangulatedPolyface(t,e){if(e||(e=Fi.createFrameWithCCWPolygon(t)),e){const i=e.multiplyInversePoint3dArray(t);Ur.areaXY(i)<0&&i.reverse();const s=Us.createTriangulatedGraphFromSingleLoop(i);if(s){const t=this.graphToPolyface(s);return t.tryTransformInPlace(e),t}}}addCoordinateFacets(t,e,i,s=!1){for(let s=0;s<t.length;s++){const n=e?e[s]:void 0,r=i?i[s]:void 0;3===t[s].length?this.addTriangleFacet(t[s],n,r):4===t[s].length&&this.addQuadFacet(t[s],n,r)}s&&this.endFace()}addUVGridBody(t,e,i,s,n){let r,o,a,c,l=new It(e),h=new It(e);const d=this._reversed,u=this.options.needNormals;u&&(a=new It(e),c=new It(e));const f=this.options.needParams;let g;f&&(r=new It(e),o=new It(e)),l.ensureCapacity(e),h.ensureCapacity(e);const p=H.create(),m=$.create(),x=1/e,_=1/i,y=Et.createXYPlane();for(let v=0;v<=i;v++){h.clear(),u&&c.clear(),f&&o.clear();for(let i=0;i<=e;i++){const e=i*x,r=v*_;t.uvFractionToPointAndTangents(e,r,y),h.push(this._polyface.addPoint(y.origin)),u&&(y.vectorU.crossProduct(y.vectorV,m),m.normalizeInPlace(),d&&m.scaleInPlace(-1),c.push(this._polyface.addNormal(m))),f&&o.push(this._polyface.addParam(H.create(s?s.fractionToPoint(e):e,n?n.fractionToPoint(r):r,p)))}if(v>0)for(let t=0;t<e;t++)this._options.shouldTriangulate?(this.addIndexedTrianglePointIndexes(l.atUncheckedIndex(t),l.atUncheckedIndex(t+1),h.atUncheckedIndex(t),!1),u&&this.addIndexedTriangleNormalIndexes(a.atUncheckedIndex(t),a.atUncheckedIndex(t+1),c.atUncheckedIndex(t)),f&&this.addIndexedTriangleParamIndexes(r.atUncheckedIndex(t),r.atUncheckedIndex(t+1),o.atUncheckedIndex(t)),this._polyface.terminateFacet(),this.addIndexedTrianglePointIndexes(h.atUncheckedIndex(t),l.atUncheckedIndex(t+1),h.atUncheckedIndex(t+1),!1),u&&this.addIndexedTriangleNormalIndexes(c.atUncheckedIndex(t),a.atUncheckedIndex(t+1),c.atUncheckedIndex(t+1)),f&&this.addIndexedTriangleParamIndexes(o.atUncheckedIndex(t),r.atUncheckedIndex(t+1),o.atUncheckedIndex(t+1)),this._polyface.terminateFacet()):(this.addIndexedQuadPointIndexes(l.atUncheckedIndex(t),l.atUncheckedIndex(t+1),h.atUncheckedIndex(t),h.atUncheckedIndex(t+1),!1),u&&this.addIndexedQuadNormalIndexes(a.atUncheckedIndex(t),a.atUncheckedIndex(t+1),c.atUncheckedIndex(t),c.atUncheckedIndex(t+1)),f&&this.addIndexedQuadParamIndexes(r.atUncheckedIndex(t),r.atUncheckedIndex(t+1),o.atUncheckedIndex(t),o.atUncheckedIndex(t+1)),this._polyface.terminateFacet());g=h,h=l,l=g,f&&(g=o),o=r,r=g,u&&(g=c),c=a,a=g}l.clear(),h.clear()}static pointsToTriangulatedPolyface(t,e){const i=Us.createTriangulatedGraphFromPoints(t,Y.ReplaceIfLarger,e?.chordTol);if(i)return ar.graphToPolyface(i,e)}addGreedyTriangulationBetweenLineStrings(t,e){nr.createContext().emitTriangles(cr(t),cr(e),(t=>{this.addTriangleFacet(t.points)}))}addMiteredPipesFromPoints(t,e,i=12){const s=Ln.createMiteredPipeSections(t,e),n=j.create(),r=j.create(),o=j.create(),a=j.create();i<3&&(i=3);const c=1/i;for(let t=1;t<s.length;t++){const e=s[t-1],l=s[t];e.fractionToPoint(0,n),l.fractionToPoint(0,o);for(let t=1;t<=i;t++,n.setFromPoint3d(r),o.setFromPoint3d(a)){const i=t*c;e.fractionToPoint(i,r),l.fractionToPoint(i,a),this.addQuadFacet([n,o,a,r])}}}addMiteredPipes(t,e,i=12){if(Array.isArray(t))this.addMiteredPipesFromPoints(new ce(t),e,i);else if(t instanceof nt)this.addMiteredPipesFromPoints(t,e,i);else if(t instanceof it)this.addMiteredPipesFromPoints(t,e,i);else if(t instanceof Me)this.addMiteredPipesFromPoints(t.packedPoints,e,i);else if(t instanceof Ot){const s=Me.create();t.emitStrokes(s,this._options),this.addMiteredPipesFromPoints(s.packedPoints,e,i)}}getEdgeIndices(t){let e=-1,i=-1;for(let s=this._polyface.facetIndex0(t.facetIndex);s<this._polyface.facetIndex1(t.facetIndex);++s)t.vertexIndexA===this._polyface.data.pointIndex[s]?e=s:t.vertexIndexB===this._polyface.data.pointIndex[s]&&(i=s);return e<0||i<0?void 0:{edgeIndexA:e,edgeIndexB:i}}addSweptFace(t,e){const i=this.getEdgeIndices(t);if(void 0===i)return!1;const s=e+t.facetIndex;if(!this._polyface.isValidFacetIndex(s))return!1;const n=this._polyface.numEdgeInFacet(t.facetIndex);if(n!==this._polyface.numEdgeInFacet(s))return!1;const r=this._polyface.facetIndex0(t.facetIndex),o=this._polyface.facetIndex0(s),a=n-1-(i.edgeIndexA-r),c=n-1-(i.edgeIndexB-r),l=[i.edgeIndexB,i.edgeIndexA,o+a,o+c],h=[];let d;void 0!==this.options.needColors&&void 0!==this._polyface.data.color&&void 0!==this._polyface.data.colorIndex&&(d=[]);for(let t=0;t<4;++t){const e=this._polyface.data.getPoint(this._polyface.data.pointIndex[l[t]]);if(void 0===e)return!1;if(h.push(e),void 0!==d){const e=this._polyface.data.getColor(this._polyface.data.colorIndex[l[t]]);if(void 0===e)return!1;d.push(e)}}return this.addQuadFacet(h,void 0,void 0,d),!0}addSweptIndexedPolyface(t,e,i=!1){let s=!0;const n=Fn.sumFacetAreas(t,e);Q.isAlmostEqualNumber(0,n)&&(s=!1);const r=Fn.partitionFacetIndicesByVisibilityVector(t,e,W.createDegrees(.001)),o=r[0].length,a=r[1].length;r[2].length>0&&(s=!1),o>0&&a>0&&(s=!1);const c=o>0,l=this._polyface.facetCount;this.addIndexedPolyface(t,c);const h=this._polyface.facetCount;this.addIndexedPolyface(t,!c,pt.createTranslation(e));const d=h-l,u=Array.from({length:d},((t,e)=>l+e)),f=Ji.createSubsetVisitor(this._polyface,u,1),g=[];Fn.createIndexedEdges(f).sortAndCollectClusters(void 0,g,void 0,void 0);const p=this._options.shouldTriangulate;this._options.shouldTriangulate=i;for(const t of g)if(t instanceof on)this.addSweptFace(t,d);else if(Array.isArray(t))for(const e of t)this.addSweptFace(e,d);return this._options.shouldTriangulate=p,s}}function cr(t){return Array.isArray(t)?new ce(t):t instanceof Me?t.packedPoints:t}function lr(t,e,i){return t!==e&&e!==i&&i!==t}ar._workPointFindOrAddA=j.create(),ar._workVectorFindOrAdd=$.create(),ar._workUVFindOrAdd=H.create();class hr{constructor(t=5){this._activeMomentData=Ei.create(),this._activeMomentData.needOrigin=!0,this._gaussMapper=new re(t)}get momentData(){return this._activeMomentData}startParentCurvePrimitive(t){}startCurvePrimitive(t){}endCurvePrimitive(t){}endParentCurvePrimitive(t){}announceIntervalForUniformStepStrokes(t,e,i,s){this.startCurvePrimitive(t),e<1&&(e=1);const n=1/e;let r,o;for(let a=1;a<=e;a++){const c=Q.interpolate(i,(a-1)*n,s),l=a===e?s:Q.interpolate(i,a*n,s),h=this._gaussMapper.mapXAndW(c,l);for(let e=0;e<h;e++){o=this._gaussMapper.gaussX[e];const i=t.fractionToPointAndDerivative(o);r=this._gaussMapper.gaussW[e]*i.direction.magnitude(),this._activeMomentData.accumulateScaledOuterProduct(i.origin,r)}}}announceSegmentInterval(t,e,i,s,n,r){this._activeMomentData.accumulateLineMomentsXYZ(e,i)}announcePointTangent(t,e,i){}visitLeaves(t){if(t instanceof ae)t.emitStrokableParts(this);else if(t instanceof si)for(const e of t.children)this.visitLeaves(e)}}class dr{pushNewChain(t){const e=[];t&&e.push(t),this._chains.push(e)}findOrCreateTailChain(){return 0===this._chains.length&&this.pushNewChain(),this._chains[this._chains.length-1]}findAnyChainToConnect(t){for(let e=0;e<this._chains.length;e++){const i=this._chains[e];if(this._xyzWork1=i[i.length-1].endPoint(this._xyzWork1),this._xyzWork1.isAlmostEqual(t))return{chainIndex:e,atEnd:!0};if(this._xyzWork1=i[0].startPoint(this._xyzWork1),this._xyzWork1.isAlmostEqual(t))return{chainIndex:e,atEnd:!1}}}constructor(t){this._chains=[],this._makeClones=t}announceCurvePrimitive(t,e=!1){if(t){if(this._makeClones){const e=t.clone();if(!(e&&e instanceof ae))return;this.transferMarkup(t,e),t=e}if(e){this._xyzWork0=t.startPoint(this._xyzWork0);let e=this.findAnyChainToConnect(this._xyzWork0);e?e.atEnd?this._chains[e.chainIndex].push(t):(t.reverseInPlace(),this._chains[e.chainIndex].splice(0,0,t)):(this._xyzWork0=t.endPoint(this._xyzWork0),e=this.findAnyChainToConnect(this._xyzWork0),e?e.atEnd?(t.reverseInPlace(),this._chains[e.chainIndex].push(t)):this._chains[e.chainIndex].splice(0,0,t):this._chains.push([t]))}else{const e=this.findOrCreateTailChain();0!==e.length&&dr.needBreakBetweenPrimitives(e[e.length-1],t)?this.pushNewChain(t):e.push(t)}}}transferMarkup(t,e){t&&e&&(e.startCut=t.startCut,e.endCut=t.endCut)}promoteArrayToCurves(t,e){if(0!==t.length)return e&&(dr._staticPointA=t[0].startPoint(dr._staticPointA),dr._staticPointB=t[t.length-1].endPoint(dr._staticPointB),dr._staticPointA.isAlmostEqual(dr._staticPointB))?hi.createArray(t):1===t.length?t[0]:oi.createArray(t)}grabResult(t=!1){const e=this._chains;if(0===e.length)return;if(1===e.length)return this.promoteArrayToCurves(e[0],t);const i=ri.create();for(const s of e){const e=this.promoteArrayToCurves(s,t);i.tryAddChild(e)}return i}static needBreakBetweenPrimitives(t,e,i=!1){return void 0===t||void 0===e||void 0!==t.endCut||void 0!==e.startCut||(dr._staticPointA=t.endPoint(dr._staticPointA),dr._staticPointB=e.startPoint(dr._staticPointB),i?!dr._staticPointA.isAlmostEqualXY(dr._staticPointB):!dr._staticPointA.isAlmostEqual(dr._staticPointB))}}class ur extends Pe{constructor(t){super(),this._options=t||new Dr}handleCurveChain(t){const e=t.children.length,i=[];let s=0;for(let n=0;n<e;){const r=t.children[n];if(this._options.consolidateLinearGeometry&&(r instanceof Ce||r instanceof Me)){i.length=0;let o=n;for(;o<t.children.length;o++){const e=t.children[o];if(e instanceof Ce)i.push(e.startPoint()),i.push(e.endPoint());else{if(!(e instanceof Me))break;{const t=e.packedPoints;for(let e=0;e<t.length;e++)i.push(t.getPoint3dAtUncheckedPointIndex(e))}}}if(i.length>1){const r=Mi.compressShortEdges(i,this._options.duplicatePointTolerance),a=Mi.compressByPerpendicularDistance(r,this._options.colinearPointTolerance);0===n&&o===e&&ki.compressColinearWrapInPlace(a,this._options.duplicatePointTolerance,this._options.colinearPointTolerance),a.length<2?t.children[s++]=Me.create(a[0]):2===a.length?t.children[s++]=Ce.create(a[0],a[1]):t.children[s++]=Me.createPoints(a)}else t.children[s++]=r;n=o}else if(this._options.consolidateCompatibleArcs&&r instanceof Ti){for(;++n<t.children.length;){const e=t.children[n];if(!(e instanceof Ti))break;if(!Ln.appendToArcInPlace(r,e))break}t.children[s++]=r}else t.children[s++]=r,n++}t.children.length=s}handlePath(t){return this.handleCurveChain(t)}handleLoop(t){return this.handleCurveChain(t)}handleParityRegion(t){for(const e of t.children)e.dispatchToGeometryHandler(this)}handleUnionRegion(t){for(const e of t.children)e.dispatchToGeometryHandler(this)}}class fr{constructor(t,e){this.fraction=t,this.otherCurveDetail=e}setFrom(t,e){e&&this.isSameFraction(t)&&(this.otherCurveDetail=t.otherCurveDetail?t.otherCurveDetail:this.otherCurveDetail),this.fraction=t.fraction}isSameFraction(t){return Q.isSmallAngleRadians(this.fraction-t.fraction)}set(t,e){this.fraction=t,this.otherCurveDetail=e}}class gr{static hasInteriorDetailAIntersections(t,e=Q.smallAngleRadians){if(0===t.length)return!1;for(const i of t)if(i.detailA.fraction>e||i.detailA.fraction<1-e)return!0;return!1}collectFragmentAndAdvanceCut(t,e,i,s){if(!e.isSameFraction(i)){const n=t.clonePartialCurve(e.fraction,i.fraction);void 0!==n&&(n.startCut=e.otherCurveDetail,n.endCut=i.otherCurveDetail,s.push(n))}e.setFrom(i,!0)}collectSinglePrimitiveFragments(t,e,i){if(void 0===e||!gr.hasInteriorDetailAIntersections(e))return void i.push(t.clone());e.sort(((t,e)=>t.detailA.fraction-e.detailA.fraction));const s=new fr(0,void 0),n=new fr(1,void 0);for(const r of e)n.set(r.detailA.fraction,r.detailB),this.collectFragmentAndAdvanceCut(t,s,n,i);n.set(1,void 0),this.collectFragmentAndAdvanceCut(t,s,n,i)}static cloneCurvesWithXYSplits(t,e){const i=new gr;if(t instanceof ae){const s=[],n=is.intersectionXYPairs(t,!1,e,!1);return i.collectSinglePrimitiveFragments(t,n,s),1===s.length?s[0]:oi.createArray(s)}if(t instanceof ni){const s=[];for(const n of t.children){const t=is.intersectionXYPairs(n,!1,e,!1);i.collectSinglePrimitiveFragments(n,t,s)}return oi.createArray(s)}}}class pr{static testPointInOnOutLoopXY(t,e,i){let s;const n=j.create(e,i);for(let r=0;Math.abs(r)<6;r=-1.2313*(r+.3212897)){s=_t.createXYAngle(e,i,W.createRadians(r));const o=s.getNormalRef(),a=[];for(const e of t.children)e instanceof ae&&e.appendPlaneIntersectionPoints(s,a);ae.snapAndRestrictDetails(a,!1,!0);let c,l,h=0,d=0,u=0;for(const t of a){if(t.intervalRole!==P.isolated&&void 0!==t.intervalRole&&u++,c=t.point.x-e,l=t.point.y-i,Q.isSameCoordinateXY(c,l,0,0))return 0;const s=Q.crossProductXYXY(o.x,o.y,c,l);if(n.isAlmostEqualXY(t.point))return 0;s<0?h++:s>0&&d++}if(0!==u)continue;const f=1&h;if(f===(1&d))return 1===f?1:-1}return-1}static testPointInOnOutParityRegionXY(t,e,i){let s=-1;for(const n of t.children)if(n instanceof hi){const t=this.testPointInOnOutLoopXY(n,e,i);if(0===t)return 0;t>0&&(s=-s)}return s}static testPointInOnOutUnionRegionXY(t,e,i){for(const s of t.children){const t=this.testPointInOnOutRegionXY(s,e,i);if(t>=0)return t}return-1}static testPointInOnOutRegionXY(t,e,i){return t instanceof hi?this.testPointInOnOutLoopXY(t,e,i):t instanceof bi?this.testPointInOnOutParityRegionXY(t,e,i):t instanceof xs?this.testPointInOnOutUnionRegionXY(t,e,i):-1}}class mr{constructor(){this.primitiveToPair=new Map,this.primitiveToIndex=new Map,this._numIndexedPrimitives=0}assignPrimitiveIndex(t){void 0!==t&&void 0===this.primitiveToIndex.get(t)&&this.primitiveToIndex.set(t,this._numIndexedPrimitives++)}insertPrimitiveToPair(t,e){if(t){const i=this.primitiveToPair.get(t);this.assignPrimitiveIndex(t),i?i.push(e):this.primitiveToPair.set(t,[e])}}insertPair(t){const e=t.detailA.curve;e&&this.insertPrimitiveToPair(e,t);const i=t.detailB.curve;i&&this.insertPrimitiveToPair(i,t)}splitAndAppendMissingClosedPrimitives(t,e=Q.smallMetricDistance){for(const i of t){let t=!1;if(i instanceof Ti?t=i.sweep.isFullCircle:i instanceof Ce||i instanceof Me||(t=i.startPoint().isAlmostEqualXY(i.endPoint(),e)),t&&!this.primitiveToPair.has(i)){const t=i.clonePartialCurve(0,.5),e=i.clonePartialCurve(.5,1);t&&e&&(this.insertPair(Pt.createCapture(vt.createCurveEvaluatedFraction(t,0),vt.createCurveEvaluatedFraction(e,1))),this.insertPair(Pt.createCapture(vt.createCurveEvaluatedFraction(t,1),vt.createCurveEvaluatedFraction(e,0))))}}}}class xr{static assembleHalfEdgeGraph(t,e,i=Q.smallMetricDistance){const s=new mr;for(const t of e)s.insertPair(t);t.length>s.primitiveToPair.size&&s.splitAndAppendMissingClosedPrimitives(t,i);const n=new fs;for(const t of s.primitiveToPair.entries()){const e=t[0],s=t[1].reduce(((t,i)=>{if(!i.detailA.hasFraction1)return[...t,i];const s=vr(i,e),n=vt.createCurveFractionPoint(e,s.fraction,s.point),r=vt.createCurveFractionPoint(e,s.fraction1,s.point1);return[...t,Pt.createCapture(n,n),Pt.createCapture(r,r)]}),[]);s.sort(((t,i)=>yr(t,e)-yr(i,e)));let r={point:e.startPoint(),fraction:0};for(const t of s){const s=vr(t,e),o=Q.restrictToInterval(s.fraction,0,1);r=this.addHalfEdge(n,e,r.point,r.fraction,s.point,o,i)}this.addHalfEdge(n,e,r.point,r.fraction,e.endPoint(),1,i)}return Hs.clusterAndMergeXYTheta(n,(t=>t.sortAngle)),n}static addHalfEdge(t,e,i,s,n,r,o=Q.smallMetricDistance){if(i.isAlmostEqualXY(n,o))return{point:i,fraction:s};const a=t.createEdgeXYAndZ(i,0,n,0),c=vt.createCurveEvaluatedFractionFraction(e,s,r),l=a.edgeMate;return a.edgeTag=c,a.sortData=1,l.edgeTag=c,l.sortData=-1,a.sortAngle=_r(e,s,!1),l.sortAngle=_r(e,r,!0),{point:n,fraction:r}}static collectSignedLoop(t,e,i=1e-10,s){let n=s?0:Er.computeXYArea(t);return void 0===n&&(n=0),Math.abs(n)<i&&(n=0),t.computedAreaInPlanarSubdivision=n,n>0?e.positiveAreaLoops.push(t):n<0?e.negativeAreaLoops.push(t):e.slivers.push(t),n}static createLoopInFace(t,e){let i=t;const s=hi.create();do{const t=i.edgeTag;if(t){let n;n=i.sortData>0?t.curve.clonePartialCurve(t.fraction,t.fraction1):t.curve.clonePartialCurve(t.fraction1,t.fraction),n&&(void 0!==e&&e(i,n,s),s.tryAddChild(n))}i=i.faceSuccessor}while(i!==t);return s}static isNullFace(t){const e=t.faceSuccessor.faceSuccessor===t;let i=!1;if(e){const e=Hs.curvatureSortKey(t),s=Hs.curvatureSortKey(t.faceSuccessor.edgeMate);Q.isSameCoordinate(e,s)||(i=!0)}return e&&!i}static nonNullEdgeMate(t,e){if(this.isNullFace(e))return;let i=e.edgeMate;for(;this.isNullFace(i);)if(i=i.faceSuccessor.edgeMate,i===e)return;return i}static collectSignedLoopSetsInHalfEdgeGraph(t,e=1e-10){const i=tn.collectConnectedComponentsWithExteriorParityMasks(t,void 0),s=[],n=new Map;for(const r of i){const i={positiveAreaLoops:[],negativeAreaLoops:[],slivers:[]},o=[];for(const s of r){const r=this.isNullFace(s),a=this.createLoopInFace(s,((e,i,s)=>{if(!r){const r=this.nonNullEdgeMate(t,e);if(void 0!==r){const t=n.get(r);if(void 0===t){const t=new di(s,i,void 0,void 0);n.set(e,t)}else t instanceof di&&(t.setB(s,i),o.push(t),n.delete(r))}}}));this.collectSignedLoop(a,i,e,r)}i.edges=o,s.push(i),n.clear()}return s}}function _r(t,e,i){const s=t.fractionToPointAndDerivative(e),n=i?-1:1;return Math.atan2(n*s.direction.y,n*s.direction.x)}function yr(t,e){return t.detailA.curve===e?t.detailA.fraction:t.detailB.curve===e?t.detailB.fraction:void 0}function vr(t,e){return t.detailA.curve===e?t.detailA:t.detailB.curve===e?t.detailB:void 0}class Pr extends Pe{constructor(){super(...arguments),this._point0=j.create(),this._point1=j.create()}handleArc3d(t){const e=this._activeMomentData,i=t.sweep.sweepRadians,s=.5*i;let n=Math.sin(s),r=Math.cos(s),o=Math.sin(i);W.isFullCircleRadians(i)&&(n=0,r=-1,o=0);const a=2*n*n*n*r/(s-n*r),c=n*n*n,l=.5*(i-o),h=.25*l*(1+a)-c*c*4/(9*l),d=.25*l*(1-a/3),u=4*n*n*n/(3*(i-o)),f=t.sweep.fractionToRadians(.5),g=t.radiansToRotatedBasis(f),p=g.origin.plusScaled(g.vectorU,u);e.accumulateXYProductsInCentroidalFrame(h,0,d,l,p,g.vectorU,g.vectorV);const m=t.fractionToPoint(0),x=t.fractionToPoint(1);e.accumulateTriangleMomentsXY(void 0,m,x)}handleLineString3d(t){this._activeMomentData.accumulateTriangleToLineStringMomentsXY(void 0,t.packedPoints)}handleLineSegment3d(t){const e=this._activeMomentData;t.startPoint(this._point0),t.endPoint(this._point1),e.accumulateTriangleMomentsXY(void 0,this._point0,this._point1)}handleLoop(t){const e=this._activeMomentData=Ei.create();e.needOrigin=!1;for(const e of t.children)e.dispatchToGeometryHandler(this);return this._activeMomentData=void 0,e}handleParityRegion(t){const e=[];let i,s=0;for(const n of t.children)if(n instanceof hi){const t=this.handleLoop(n);if(t){e.push(t);const n=Math.abs(t.quantitySum);n>s&&(s=n,i=t)}}if(i){const t=Ei.create(),s=i.signFactor(1);t.accumulateProducts(i,s);for(const s of e)if(s!==i){const e=s.signFactor(-1);t.accumulateProducts(s,e)}return t}}handleUnionRegion(t){const e=Ei.create();for(const i of t.children){const t=i.dispatchToGeometryHandler(this);if(t){const i=t.signFactor(1);e.accumulateProducts(t,i)}}return e}getStrokeOptions(){if(this._strokeOptions)return this._strokeOptions;const t=Ie.createForCurves();return t.angleTol=W.createDegrees(5),this._strokeOptions=t,t}handleCurvePrimitive(t){const e=Me.create(),i=this.getStrokeOptions();t.emitStrokes(e,i),this.handleLineString3d(e)}handleBSplineCurve3d(t){return this.handleCurvePrimitive(t)}handleBSplineCurve3dH(t){return this.handleCurvePrimitive(t)}handleTransitionSpiral(t){return this.handleCurvePrimitive(t)}}class Ar{startComponent(t){return!0}finishComponent(t){return!0}enterFace(t,e){return!0}leaveFace(t,e){return!0}}class Ir extends Ar{constructor(t,e){super(),this._inComponent=[!1,!1,!1],this._exteriorMask=e,this._faceSelectFunction=t}startComponent(t){return t.setMaskAroundFace(this._exteriorMask),!0}enterFace(t,e){const i=e.edgeTag;return 1!==e.edgeTag&&2!==e.edgeTag||(this._inComponent[i]=!this._inComponent[i]),this._faceSelectFunction(this._inComponent[1],this._inComponent[2])||e.setMaskAroundFace(this._exteriorMask),!0}leaveFace(t,e){const i=e.edgeTag;return 1!==e.edgeTag&&2!==e.edgeTag||(this._inComponent[i]=!this._inComponent[i]),!0}}class Sr{static faceToFaceSearchFromOuterLoop(t,e,i,s,n){if(e.isMaskSet(i))return;if(!n.startComponent(e))return;const r=[];e.setMaskAroundFace(i);let o=e;do{let t=o,e=o.edgeMate;if(!e.isMaskSet(i)){r.push(o),r.push(e);let a=e.faceSuccessor;if(e.setMaskAroundFace(i),t=e,n.enterFace(r,e))for(;;){if(e=a.edgeMate,!e.isMaskSet(i)){if(e.setMaskAroundFace(i),!n.enterFace(r,e))return;r.push(a),r.push(e),a=e,t=e}if(a.setMask(s),a=a.faceSuccessor,a===t){if(n.leaveFace(r,a),r.length<=2)break;r.pop(),a=r[r.length-1],r.pop(),t=r[r.length-1]}if(a.isMaskSet(s))return}}o=o.faceSuccessor}while(o!==e);n.finishComponent(e)}static doPolygonBoolean(t,e,i,s){const n=new fs,r=b.BOUNDARY_EDGE|b.PRIMARY_EDGE,o=Er.addLoopsWithEdgeTagToGraph(n,t,r,1),a=Er.addLoopsWithEdgeTagToGraph(n,e,r,2);if(s&&s("unmerged loops",n,"U"),o||a){Hs.splitIntersectingEdges(n),s&&s("After splitIntersectingEdges",n,"S"),Hs.clusterAndMergeXYTheta(n),s&&s("After clusterAndMergeXYTheta",n,"M"),new ms(n).regularizeGraph(!0,!0),s&&s("After regularize",n,"MR");const t=tn.findMinimumAreaFace(n);if(void 0===t)return;const e=b.EXTERIOR,r=n.grabMask(),o=n.grabMask(),a=e|r|o;n.clearMask(a);const c=new Ir(i,e);return this.faceToFaceSearchFromOuterLoop(n,t,r,o,c),s&&s("After faceToFaceSearchFromOuterLoop",n,"MRX"),n.dropMask(r),n.dropMask(o),n}}static doBinaryBooleanBetweenMultiLoopInputs(t,e,i,s,n,r){const o=new fs,a=b.BOUNDARY_EDGE|b.PRIMARY_EDGE,c=Tr.create(e,n);c.graph=o,c.faceAreaFunction=t=>tn.signedFaceArea(t);for(const e of t)if(e.length>2){const t=new wr(e,c.groupA);Er.addLoopsWithEdgeTagToGraph(o,e,a,t)}for(const t of s)if(t.length>2){const e=new wr(t,c.groupB);Er.addLoopsWithEdgeTagToGraph(o,t,a,e)}return Hs.splitIntersectingEdges(o),Hs.clusterAndMergeXYTheta(o),new ms(o).regularizeGraph(!0,!0),c.runClassificationSweep(i),r&&c.unmaskMaskedNullFaces(b.EXTERIOR),o}}!function(t){t[t.Union=0]="Union",t[t.Parity=1]="Parity",t[t.Intersection=2]="Intersection",t[t.NonBounding=-1]="NonBounding"}(L||(L={}));class wr{constructor(t,e){this.region=t,this.parentGroup=e,this.sweepState=0}clearState(){this.sweepState=0}}class Cr{constructor(t,e){this.members=[],this.parent=t,this.groupOpType=e,this._numIn=0}clearState(){for(const t of this.members)t.clearState();this._numIn=0}range(){const t=ut.createNull();for(const e of this.members)if(e.region instanceof Ot)e.region.extendRange(t);else{const i=ut.createFromVariantData(e.region);t.extendRange(i)}return t}getInOut(){return this.groupOpType===L.Union?this._numIn>0:this.groupOpType===L.Parity?Q.isOdd(this._numIn):this.groupOpType===L.Intersection&&this._numIn===this.members.length}addMember(t,e=!1){if(t instanceof hi||t instanceof bi){const e=t.clone();Er.consolidateAdjacentPrimitives(e),this.members.push(new wr(e,this))}else if(t instanceof xs)for(const e of t.children)this.addMember(e);else if(Array.isArray(t))for(const e of t)this.addMember(e);else e&&t instanceof Ce&&this.members.push(new wr(t,this))}recordMemberStateChange(t,e){const i=Q.isOdd(t),s=Q.isOdd(e);!i&&s?this._numIn++:i&&!s&&this._numIn--}}class Tr{constructor(t,e){this.groupA=new Cr(this,t),this.groupB=new Cr(this,e),this.extraGeometry=new Cr(this,L.NonBounding),this.binaryOp=U.Union}static create(t,e){return new Tr(t,e)}addMembers(t,e){this.groupA.addMember(t),this.groupB.addMember(e),this.addConnectives()}addConnectives(){const t=this.groupA.range(),e=this.groupB.range(),i=t.union(e),s=Er.computeXYAreaTolerance(i);let n=.1;this._workSegment=Ee.findExtremePointsInDirection(i.corners(),Tr._bridgeDirection,this._workSegment),this._workSegment&&(n*=this._workSegment.point0Ref.distanceXY(this._workSegment.point1Ref));const r=[],o=t=>{const e=Er.computeXYArea(t);void 0===e||Math.abs(e)<s||(this._workSegment=Ee.findExtremePointsInDirection(t,Tr._bridgeDirection,this._workSegment),this._workSegment&&r.push(this._workSegment.point1Ref))};for(const t of[this.groupA.members,this.groupB.members])for(const e of t)if(e.region instanceof hi)o(e.region);else if(e.region instanceof bi)for(const t of e.region.children)o(t);const a=bt.createZero();for(const t of r){const e=n+bt.create(t,Tr._bridgeDirection,a).intersectionWithRange3d(i).high,s=j.createAdd2Scaled(t,1,Tr._bridgeDirection,e),r=Ce.createXYXY(t.x,t.y,s.x,s.y);this.extraGeometry.addMember(r,!0)}}annotateAndMergeCurvesInGraph(t=Q.smallMetricDistance){const e=[];for(const t of[this.groupA,this.groupB,this.extraGeometry])for(const i of t.members){let t=e.length;if(i.region instanceof Ot)for(Er.collectCurvePrimitives(i.region,e,!0,!0);t<e.length;t++)e[t].parent=i}const i=is.allIntersectionsAmongPrimitivesXY(e,t),s=xr.assembleHalfEdgeGraph(e,i,t);this.graph=s,this.faceAreaFunction=kr}runClassificationSweep(t,e){this._announceFaceFunction=e,this.binaryOp=t,this.graph.clearMask(b.EXTERIOR);for(const t of[this.groupA,this.groupB])t.clearState();const i=this.graph.grabMask(),s=this.graph.grabMask(),n=br.create(this.graph);for(const t of n.components){const e=tn.findMinimumAreaFace(t.faces,this.faceAreaFunction);if(e){const t=b.EXTERIOR|i|s;this.graph.clearMask(t),Sr.faceToFaceSearchFromOuterLoop(this.graph,e,i,s,this)}}this.graph.dropMask(i),this.graph.dropMask(s)}unmaskMaskedNullFaces(t){for(const e of this.graph.allHalfEdges){const i=e.faceSuccessor;i.faceSuccessor===e&&e.getMask(t)&&i.getMask(t)&&(e.edgeMate.getMask(t)&&i.edgeMate.getMask(t)||(e.clearMask(t),i.clearMask(t)))}}getInOut(){return this.binaryOp===U.Union?this.groupA.getInOut()||this.groupB.getInOut():this.binaryOp===U.Intersection?this.groupA.getInOut()&&this.groupB.getInOut():this.binaryOp===U.AMinusB?this.groupA.getInOut()&&!this.groupB.getInOut():this.binaryOp===U.BMinusA?!this.groupA.getInOut()&&this.groupB.getInOut():this.binaryOp===U.Parity&&this.groupA.getInOut()!==this.groupB.getInOut()}recordTransitionAcrossEdge(t,e){const i=t=>{if(t.parentGroup.groupOpType===L.NonBounding)return t;if(0!==e){const i=t.sweepState;t.sweepState+=e,t.parentGroup.recordMemberStateChange(i,t.sweepState)}return t},s=t.edgeTag;if(s instanceof wr)return i(s);if(s instanceof vt){const t=s.curve.parent;if(t instanceof wr)return i(t)}}startComponent(t){return t.setMaskAroundFace(b.EXTERIOR),this._announceFaceFunction&&this._announceFaceFunction(this.graph,t,-1,kr(t)),!0}finishComponent(t){return!0}enterFace(t,e){this.recordTransitionAcrossEdge(e,1);const i=this.getInOut();return i||e.setMaskAroundFace(b.EXTERIOR),this._announceFaceFunction&&this._announceFaceFunction(this.graph,e,i?1:0,kr(e)),!0}leaveFace(t,e){return this.recordTransitionAcrossEdge(e,-1),!0}}function Fr(t,e,i,s){let n;n=t&&t.point1?-(t.point1.x-t.point.x)*(.5*(t.point.y+t.point1.y)-s.y):-(i.x-e.x)*(.5*(e.y+i.y)-s.y);let r=0;return t&&t.curve&&t.hasFraction1&&(t.curve instanceof Ce||t.curve instanceof Ti&&(r=t.curve.areaToChordXY(t.fraction,t.fraction1))),n+r}function kr(t){let e=0,i=t;do{e+=i.sortData*Fr(i.edgeTag,i,i.faceSuccessor,t)}while((i=i.faceSuccessor)!==t);return e}Tr._bridgeDirection=$.createNormalized(1,-.12328974132467);class Mr{constructor(t){this.faces=t,this.range=gt.createNull(),this.faceAreas=[]}buildFaceData(t,e){const i=e=>(t?t(e,this.range):this.range.extendXY(e.x,e.y),0);this.range.setNull();for(const t of this.faces)t.sumAroundFace(i);this.faceAreas.length=0,e||(e=t=>tn.signedFaceArea(t));for(const t of this.faces)this.faceAreas.push(e(t))}}class br{constructor(t){this.graph=t,this.components=[]}static create(t,e){const i=new br(t),s=tn.collectConnectedComponentsWithExteriorParityMasks(t,void 0);for(const t of s){const s=new Mr(t);s.buildFaceData(e,kr),i.components.push(s)}return i}}!function(t){t[t.Union=0]="Union",t[t.Parity=1]="Parity",t[t.Intersection=2]="Intersection",t[t.AMinusB=3]="AMinusB",t[t.BMinusA=4]="BMinusA"}(U||(U={}));class Er{static computeXYAreaMoments(t){const e=new Pr,i=t.dispatchToGeometryHandler(e);if(i instanceof Ei)return i.shiftOriginAndSumsToCentroidOfSums(),i}static computeXYAreaTolerance(t,e=Q.smallMetricDistance){const i=.5*e;return i*(t.xLength()+t.yLength()+i)}static computeXYArea(t){const e=new Pr,i=t.dispatchToGeometryHandler(e);if(i instanceof Ei)return i.quantitySum}static computeXYZWireMomentSums(t){const e=new hr;e.visitLeaves(t);const i=e.momentData;return i.shiftOriginAndSumsToCentroidOfSums(),i}static addLoopsToGraph(t,e,i){if(e instanceof hi){const s=e.getPackedStrokes();s&&this.addLoopsToGraph(t,s,i)}else if(e instanceof bi)for(const s of e.children){const e=s.getPackedStrokes();e&&this.addLoopsToGraph(t,e,i)}else if(e instanceof it){const s=Us.directCreateFaceLoopFromCoordinates(t,e);void 0!==s&&i(t,s)}else if(Array.isArray(e)&&e.length>0)if(j.isAnyImmediatePointType(e[0])){const s=Us.directCreateFaceLoopFromCoordinates(t,e);void 0!==s&&i(t,s)}else if(e[0]instanceof it)for(const s of e){const e=Us.directCreateFaceLoopFromCoordinates(t,s);void 0!==e&&i(t,e)}else for(const s of e)Array.isArray(s)&&this.addLoopsToGraph(t,s,i)}static addLoopsWithEdgeTagToGraph(t,e,i,s){const n=[];if(this.addLoopsToGraph(t,e,((t,e)=>{e&&(n.push(e),e.setMaskAndEdgeTagAroundFace(i,s,!0))})),n.length>0)return n}static finishGraphToPolyface(t,e){if(t)return e&&(Us.triangulateAllPositiveAreaFaces(t),Us.flipTriangles(t)),ar.graphToPolyface(t)}static polygonXYAreaIntersectLoopsToPolyface(t,e,i=!1){const s=Sr.doPolygonBoolean(t,e,((t,e)=>t&&e),this._graphCheckPointFunction);return this.finishGraphToPolyface(s,i)}static polygonXYAreaUnionLoopsToPolyface(t,e,i=!1){const s=Sr.doPolygonBoolean(t,e,((t,e)=>t||e),this._graphCheckPointFunction);return this.finishGraphToPolyface(s,i)}static polygonXYAreaDifferenceLoopsToPolyface(t,e,i=!1){const s=Sr.doPolygonBoolean(t,e,((t,e)=>t&&!e),this._graphCheckPointFunction);return this.finishGraphToPolyface(s,i)}static regionBooleanXY(t,e,i,s=Q.smallMetricDistance){const n=xs.create(),r=Tr.create(L.Union,L.Union);r.addMembers(t,e),r.annotateAndMergeCurvesInGraph(s);const o=r.groupA.range().union(r.groupB.range()),a=this.computeXYAreaTolerance(o,s);return r.runClassificationSweep(i,((t,e,i,s)=>{if(!(e.countEdgesAroundFace()<2||Math.abs(s)<a||1!==i)){const t=xr.createLoopInFace(e);t&&n.tryAddChild(t)}})),n}static polygonBooleanXYToPolyface(t,e,i,s=!1){const n=Sr.doBinaryBooleanBetweenMultiLoopInputs(t,L.Union,e,i,L.Union,!0);return this.finishGraphToPolyface(n,s)}static polygonBooleanXYToLoops(t,e,i){const s=Sr.doBinaryBooleanBetweenMultiLoopInputs(t,L.Union,e,i,L.Union,!0);if(!s)return;const n=tn.collectExtendedBoundaryLoopsInGraph(s,b.EXTERIOR),r=[];for(const t of n){const e=new nt;for(const i of t)e.pushXYZ(i.x,i.y,i.z);e.pushWrap(1);const i=hi.create();i.tryAddChild(Me.createCapture(e)),r.push(i)}return Er.sortOuterAndHoleLoopsXY(r)}static constructPolygonWireXYOffset(t,e,i){return(new rs).constructPolygonWireXYOffset(t,e,i)}static constructCurveXYOffset(t,e){const i=we.create(e);return as.constructCurveXYOffset(t,i)}static testPointInOnOutRegionXY(t,e,i){return pr.testPointInOnOutRegionXY(t,e,i)}static createLoopPathOrBagOfCurves(t,e=!0,i=!1){const s=t.length;if(0===s)return;let n,r=0,o=!1;e&&(r=Q.maxXY(r,t[0].startPoint().distance(t[s-1].endPoint())));for(let e=0;e+1<s;e++)r=Q.maxXY(r,t[e].endPoint().distance(t[e+1].startPoint()));Q.isSmallMetricDistance(r)?(n=e?hi.create():oi.create(),o=!0):n=ri.create();for(const e of t)n.tryAddChild(e);return o&&i&&Er.consolidateAdjacentPrimitives(n),n}static setCheckPointFunction(t){this._graphCheckPointFunction=t}static cloneCurvesWithXYSplits(t,e){return gr.cloneCurvesWithXYSplits(t,e)}static splitToPathsBetweenBreaks(t,e){if(void 0===t)return;if(t instanceof ae)return t;const i=t.collectCurvePrimitives(),s=new dr(e);for(const t of i)s.announceCurvePrimitive(t);return s.grabResult()}static collectInsideAndOutsideOffsets(t,e,i){return as.collectInsideAndOutsideXYOffsets(t,e,i)}static collectChains(t,e=Q.smallMetricDistance){return as.collectChains(t,e)}static splitPathsByRegionInOnOutXY(t,e){const i={insideParts:[],outsideParts:[],coincidentParts:[]},s=Er.cloneCurvesWithXYSplits(t,e),n=Er.splitToPathsBetweenBreaks(s,!0);if(n instanceof si)for(const t of n.children){const s=si.createCurveLocationDetailOnAnyCurvePrimitive(t);s&&Rr(t,Er.testPointInOnOutRegionXY(e,s.point.x,s.point.y),i.outsideParts,i.coincidentParts,i.insideParts)}else if(n instanceof ae){const t=si.createCurveLocationDetailOnAnyCurvePrimitive(n);t&&Rr(n,Er.testPointInOnOutRegionXY(e,t.point.x,t.point.y),i.outsideParts,i.coincidentParts,i.insideParts)}return i}static rectangleEdgeTransform(t,e=!0){if(t instanceof Me)return this.rectangleEdgeTransform(t.packedPoints);if(t instanceof it){let i;if(e&&5===t.length){if(!Q.isSmallMetricDistance(t.distanceIndexIndex(0,4)))return;i=t}else if(e||4!==t.length){if(t.length<(e?5:4))return;if(i=nt.create(t),ki.compressInPlaceByShortEdgeLength(i,Q.smallMetricDistance),i.length<(e?5:4))return}else i=t;const s=i.vectorIndexIndex(0,1),n=i.vectorIndexIndex(0,3),r=i.vectorIndexIndex(1,2),o=s.crossProduct(n);if(o.normalizeInPlace()&&r.isAlmostEqual(n)&&s.isPerpendicularTo(n))return pt.createOriginAndMatrixColumns(i.getPoint3dAtUncheckedPointIndex(0),s,n,o)}else{if(Array.isArray(t))return this.rectangleEdgeTransform(new ce(t),e);if(t instanceof hi&&1===t.children.length&&t.children[0]instanceof Me)return this.rectangleEdgeTransform(t.children[0].packedPoints,!0);if(t instanceof oi&&1===t.children.length&&t.children[0]instanceof Me)return this.rectangleEdgeTransform(t.children[0].packedPoints,e);if(t instanceof ni&&!t.checkForNonLinearPrimitives()){const e=t.getPackedStrokes();if(e)return this.rectangleEdgeTransform(e)}}}static consolidateAdjacentPrimitives(t,e){const i=new ur(e);t.dispatchToGeometryHandler(i)}static sortOuterAndHoleLoopsXY(t){const e=[];for(const i of t)if(i instanceof hi)Or.pushLoop(e,i);else if(i instanceof it){const t=hi.createPolygon(i);Or.pushLoop(e,t)}return Or.sortAsAnyRegion(e)}static constructAllXYRegionLoops(t,e=Q.smallMetricDistance){const i=Er.collectCurvePrimitives(t,void 0,!0,!0),s=this.curveArrayRange(i),n=this.computeXYAreaTolerance(s,e),r=is.allIntersectionsAmongPrimitivesXY(i,e),o=xr.assembleHalfEdgeGraph(i,r,e);return xr.collectSignedLoopSetsInHalfEdgeGraph(o,n)}static collectCurvePrimitives(t,e,i=!1,s=!1){const n=void 0===e?[]:e;if(t instanceof ae)t.collectCurvePrimitives(n,i,s);else if(t instanceof si)t.collectCurvePrimitives(n,i,s);else if(Array.isArray(t))for(const e of t)this.collectCurvePrimitives(e,n,i,s);return n}static expandLineStrings(t){const e=[];for(const i of t)if(i instanceof Me)for(let t=0;t+1<i.packedPoints.length;t++){const s=i.getIndexedSegment(t);void 0!==s&&e.push(s)}else e.push(i);return e}static curveArrayRange(t,e){const i=ut.create();if(t instanceof Ot)t.extendRange(i,e);else if(Array.isArray(t))for(const s of t)s instanceof Ot?s.extendRange(i,e):s instanceof j?i.extendPoint(s,e):s instanceof nt?i.extendRange(s.getRange(e)):Array.isArray(s)&&i.extendRange(this.curveArrayRange(s,e));return i}static triangulateStrokedRegionComponent(t){let e;if(Array.isArray(t)){if(0===t.length)return;const i=t[0];if(j.isAnyImmediatePointType(i))e=Us.createTriangulatedGraphFromSingleLoop(t);else if(t.length>1){let s;if(i instanceof st)s=t;else{s=[];for(const e of t)s.push(nt.create(e))}const n=Ur.sortOuterAndHoleLoopsXY(s);1===n.length&&(e=Us.createTriangulatedGraphFromLoops(n[0]))&&Us.flipTriangles(e)}else e=Us.createTriangulatedGraphFromSingleLoop(i)}else e=Us.createTriangulatedGraphFromSingleLoop(t);return e||(e=Sr.doPolygonBoolean(t,[],((t,e)=>t)))&&Us.triangulateAllPositiveAreaFaces(e)&&Us.flipTriangles(e),e}static strokeRegionComponent(t,e){const i=t.cloneStroked(e),s=[];if(i instanceof hi)i.children.length>0&&i.children[0]instanceof Me&&s.push(i.children[0].packedPoints);else if(i instanceof bi)for(const t of i.children)t.children.length>0&&t.children[0]instanceof Me&&s.push(t.children[0].packedPoints);return s}static triangulateRegionComponent(t,e){const i=this.strokeRegionComponent(t,e);return this.triangulateStrokedRegionComponent(i)}static facetRegionXY(t,e){let i;if(t instanceof xs)for(const s of t.children){const t=Er.triangulateRegionComponent(s,e);t&&(i?i.allHalfEdges.push(...t.allHalfEdges):i=t)}else i=this.triangulateRegionComponent(t,e);if(i)return e?.maximizeConvexFacets&&Gs.expandConvexFaces(i),ar.graphToPolyface(i,e)}static convexDecomposePolygonXY(t,e=!0){const i=Er.triangulateStrokedRegionComponent(t);if(!i)return;e&&Gs.expandConvexFaces(i);const s=[];return i.announceFaceLoops(((t,e)=>(e.isMaskSet(b.EXTERIOR)||s.push(nt.create(e.collectAroundFace((t=>t.getPoint3d())))),!0))),s}}function Rr(t,e,i,s,n){e>0?n.push(t):e<0?i.push(t):s.push(t)}class Dr{constructor(){this.consolidateLinearGeometry=!0,this.consolidateCompatibleArcs=!0,this.duplicatePointTolerance=Q.smallMetricDistance,this.colinearPointTolerance=Q.smallMetricDistance}}class Xr{}class zr extends Xr{get signedArea(){return this._signedArea}constructor(t){super(),this.data=t,this._signedArea=Ur.areaXY(t)}classifyPointXY(t){return Ur.classifyPointInPolygonXY(t.x,t.y,this.data)}getAnyInteriorPoint(){for(let t=0;t<this.data.length;t++){const e=this.constructInteriorPointNearEdge(t,.2349);if(void 0!==e)return e}}grabPolygon(){return this.data}grabLoop(){return hi.createPolygon(this.data)}reverseForAreaSign(t){t*this._signedArea<0&&(this.data.reverseInPlace(),this._signedArea*=-1)}constructInteriorPointNearEdge(t,e){if(t+1<this.data.length){const i=this.data.getPoint3dAtUncheckedPointIndex(t),s=this.data.getPoint3dAtUncheckedPointIndex(t+1),n=i.vectorTo(s),r=i.interpolate(e,s);if(n.rotate90CCWXY(n),n.normalizeInPlace()){this._signedArea<0&&n.scaleInPlace(-1);const t=Math.sqrt(Math.abs(this._signedArea));for(let e=1e-5;e<3;e*=5){const i=r.plusScaled(n,e*t);if(1===this.classifyPointXY(i))return i}}}}}class Nr extends Xr{get signedArea(){return this._signedArea}constructor(t){super(),this.data=t;const e=Er.computeXYAreaMoments(t);this._signedArea=void 0!==e?e.quantitySum:0}classifyPointXY(t){return Er.testPointInOnOutRegionXY(this.data,t.x,t.y)}constructInteriorPointNearChild(t,e){if(t<this.data.children.length){const i=this.data.children[t].fractionToPointAndUnitTangent(e);i.direction.rotate90CCWXY(i.direction),this._signedArea<0&&i.direction.scaleInPlace(-1);const s=Math.sqrt(Math.abs(this._signedArea));for(let t=1e-5;t<3;t*=5){const e=i.fractionToPoint(t*s);if(1===this.classifyPointXY(e))return e}}}getAnyInteriorPoint(){for(let t=0;t<this.data.children.length;t++){const e=this.constructInteriorPointNearChild(t,.2349);if(void 0!==e)return e}}grabPolygon(){const t=this.data.cloneStroked();if(t instanceof ni){const e=Me.create();for(const i of t.children)i instanceof ae&&i.emitStrokes(e);return e.numPoints()>0?e.packedPoints:void 0}}grabLoop(){return this.data}reverseForAreaSign(t){t*this._signedArea<0&&(this.data.reverseChildrenInPlace(),this._signedArea*=-1)}}class Or{constructor(t,e){this._loopCarrier=t instanceof st?new zr(t):new Nr(t),this.range=e,this.sortKey=Math.abs(this._loopCarrier.signedArea),this.isHole=!1}static pushPolygon(t,e){const i=e.getRange(),s=new Or(e,i);return s.sortKey>0&&(t.push(s),!0)}static pushLoop(t,e){const i=e.range(),s=new Or(e,i);return s.sortKey>0&&(t.push(s),!0)}static assignParentsAndDepth(t){t.sort(((t,e)=>e.sortKey-t.sortKey));for(let e=t.length;e-- >0;){const i=t[e],s=i._loopCarrier.getAnyInteriorPoint();if(void 0!==s){t[e].parentIndex=void 0,t[e].outputSetIndex=void 0;for(let n=e;n-- >0;){const e=t[n];if(e.range.containsXY(s.x,s.y)&&1===e._loopCarrier.classifyPointXY(s)){i.parentIndex=n;break}}}}}static assemblePolygonSet(t){const e=[];for(const i of t){i.isHole=!1;const s=i.parentIndex;void 0!==s&&(i.isHole=!t[s].isHole),i.isHole?(i._loopCarrier.reverseForAreaSign(-1),e[t[s].outputSetIndex].push(i._loopCarrier.grabPolygon())):(i._loopCarrier.reverseForAreaSign(1),i.outputSetIndex=e.length,e.push([]),e[i.outputSetIndex].push(i._loopCarrier.grabPolygon()))}return e}static assembleLoopSet(t){const e=[],i=t.length;for(let s=0;s<i;s++){const n=t[s],r=n.parentIndex;if(n.isHole=void 0!==r&&!t[r].isHole,!n.isHole){n._loopCarrier.reverseForAreaSign(1);const r=n._loopCarrier.grabLoop();let o;for(let e=s+1;e<i;e++){const i=t[e];i.parentIndex===s&&(void 0===o?(o=bi.create(),o.tryAddChild(r),i._loopCarrier.reverseForAreaSign(-1),o.tryAddChild(i._loopCarrier.grabLoop())):(i._loopCarrier.reverseForAreaSign(-1),o.tryAddChild(i._loopCarrier.grabLoop())))}void 0!==o?e.push(o):void 0!==r&&e.push(r)}}return e}static sortAsAnyRegion(t){this.assignParentsAndDepth(t);const e=this.assembleLoopSet(t);if(1===e.length)return e[0];{const t=xs.create();for(const i of e)t.tryAddChild(i);return t}}static sortAsArrayOfArrayOfPolygons(t){return this.assignParentsAndDepth(t),this.assemblePolygonSet(t)}grabPolygon(){return this._loopCarrier.grabPolygon()}grabLoop(){return this._loopCarrier.grabLoop()}reverseForAreaSign(t){this._loopCarrier.reverseForAreaSign(t)}getAnyInteriorPoint(){return this._loopCarrier.getAnyInteriorPoint()}}class Yr{constructor(){this.point=new j,this.a=0,this.v=new $,this.code=_.Unknown,this.closestEdgeIndex=0,this.closestEdgeParam=0}invalidate(){this.point.setZero(),this.a=0,this.v.setZero(),this.code=_.Unknown,this.closestEdgeIndex=0,this.closestEdgeParam=0}static create(t){return void 0===t?t=new Yr:t.invalidate(),t}copyContentsFrom(t){this.point.setFrom(t.point),this.a=t.a,this.v.setFrom(t.v),this.code=t.code,this.closestEdgeIndex=t.closestEdgeIndex,this.closestEdgeParam=t.closestEdgeParam}get isValid(){return this.code!==_.Unknown}get isInsideOrOn(){return this.code===_.InsidePolygon||this.code===_.OnPolygonVertex||this.code===_.OnPolygonEdgeInterior||this.code===_.InsidePolygonProjectsToVertex||this.code===_.InsidePolygonProjectsToEdgeInterior}static createAtVertexOrEdge(t,e,i=0){const s=new Yr;return s.point.setFrom(t),s.closestEdgeIndex=e,s.closestEdgeParam=i,i=Q.clamp(i,0,1),s.code=i>0&&i<1?_.OnPolygonEdgeInterior:_.OnPolygonVertex,s}}class Br{constructor(t,e){this.detailA=t||Yr.create(),this.detailB=e||Yr.create()}static create(t,e,i){return i?(i.detailA=t,i.detailB=e,i):new Br(t,e)}clone(t){return(t=t||new Br).detailA.copyContentsFrom(this.detailA),t.detailB.copyContentsFrom(this.detailB),t}swapDetails(){const t=this.detailA;this.detailA=this.detailB,this.detailB=t}}class Vr{constructor(t){this.xyz=t,this.edge=void 0,this.sortCoordinate0=this.sortCoordinate1=0,this.sortDelta=0,this.isNotch=!1}static createCaptureWithReturnEdge(t){const e=new Vr(t);return t.length>=2&&(e.edge=bt.createStartEnd(t.front(),t.back())),e}setSortCoordinates(t){this.sortDelta=this.edge.direction.dotProduct(t.direction);const e=t.dotProductToPoint(this.edge.origin);this.sortDelta>=0?(this.sortCoordinate0=e,this.sortCoordinate1=e+this.sortDelta):(this.sortCoordinate0=e+this.sortDelta,this.sortCoordinate1=e)}containsSortLimits(t){return t.sortCoordinate0>=this.sortCoordinate1||t.sortCoordinate0<=this.sortCoordinate0||t.sortCoordinate1<=this.sortCoordinate0||t.sortCoordinate1>=this.sortCoordinate1?0:this.sortDelta*t.sortDelta>0?1:-1}absorb(t){this.xyz.pushFromGrowableXYZArray(t.xyz),this.sortCoordinate0=t.sortCoordinate1}static sortFunction(t,e){return t.sortCoordinate0-e.sortCoordinate0>0?1:-1}front(t){return this.xyz.front(t)}back(t){return this.xyz.back(t)}}class Lr{constructor(){this.inputLoops=[],this.outputLoops=[]}mostDistantPoint(t,e,i){let s,n=-1;i.setZero();for(const r of this.inputLoops)r.front(e),s=e.distanceSquared(t),s>n&&(n=s,i.setFromPoint3d(e)),r.back(e),s=e.distanceSquared(t),s>n&&(n=s,i.setFromPoint3d(e))}sortInputs(){if(this.inputLoops.length>0&&this.inputLoops[0].xyz.length>0){const t=this.inputLoops[0].xyz.front(),e=j.create(),i=j.create();this.mostDistantPoint(t,e,i),this.mostDistantPoint(i,e,t);const s=bt.createStartEnd(t,i);s.direction.normalizeInPlace();for(const t of this.inputLoops)t.setSortCoordinates(s);this.inputLoops.sort(((t,e)=>Vr.sortFunction(t,e)))}}sortAndMergeLoops(){this.sortInputs();const t=this.inputLoops,e=this.outputLoops,i=[];e.length=0;for(const s of t){for(s.isNotch=!1;i.length>0;){const t=i[i.length-1],n=t.containsSortLimits(s);if(0!==n){if(1===n){s.isNotch=!1;break}t.absorb(s),s.isNotch=!0;break}t.isNotch||e.push(t),i.pop()}i.push(s)}for(const t of i)t.isNotch||e.push(t)}}class Ur{static sumTriangleAreas(t){let e=0;const i=t.length;if(Array.isArray(t)){if(i>=3){const s=t[0],n=s.vectorTo(t[1]);let r=$.create();for(let o=2;o<i;o++)r=s.vectorTo(t[o],r),e+=n.crossProductMagnitude(r),n.setFrom(r)}return.5*e}const s=$.create();for(let n=2;n<i;n++)t.crossProductIndexIndexIndex(0,n-1,n,s),e+=s.magnitude();return.5*e}static sumTriangleAreasPerpendicularToUpVector(t,e){let i=e.magnitude();i<Q.smallMetricDistance&&(e=$.create(0,0,1),i=1);let s=0;const n=t.length;if(Array.isArray(t)){if(n>=3){const i=t[0],r=i.vectorTo(t[1]);let o=$.create();for(let a=2;a<n;a++)o=i.vectorTo(t[a],o),s+=r.tripleProduct(o,e),r.setFrom(o)}return.5*s/i}const r=$.create();for(let i=2;i<n;i++)t.crossProductIndexIndexIndex(0,i-1,i,r),s+=r.dotProduct(e);return.5*s/i}static sumTriangleAreasXY(t){let e=0;const i=t.length;if(i>=3){const s=t[0],n=s.vectorTo(t[1]);let r=$.create();for(let o=2;o<i;o++)r=s.vectorTo(t[o],r),e+=n.crossProductXY(r),n.setFrom(r)}return e*=.5,e}static areaNormalGo(t,e){e?e.setZero():e=new $;const i=t.length;if(3===i)t.crossProductIndexIndexIndex(0,1,2,e);else if(i>3)for(let s=2;s<i;s++)t.accumulateCrossProductIndexIndexIndex(0,s-1,s,e);return e.scaleInPlace(.5),e.isZero?void 0:e}static areaNormal(t,e){return e||(e=$.create()),Ur.areaNormalGo(new ce(t),e),e}static area(t){return Ur.areaNormal(t).magnitude()}static areaXY(t){let e=0;if(t instanceof it){if(t.length>2){const i=t.getXAtUncheckedPointIndex(0),s=t.getYAtUncheckedPointIndex(0);let n,r,o=t.getXAtUncheckedPointIndex(1)-i,a=t.getYAtUncheckedPointIndex(1)-s;for(let c=2;c+1<t.length;c++,o=n,a=r)n=t.getXAtUncheckedPointIndex(c)-i,r=t.getYAtUncheckedPointIndex(c)-s,e+=Q.crossProductXYXY(o,a,n,r)}}else for(let i=1;i+1<t.length;i++)e+=t[0].crossProductToPointsXY(t[i],t[i+1]);return.5*e}static sumAreaXY(t){let e=0;for(const i of t)e+=this.areaXY(i);return e}static centroidAreaNormal(t){if(Array.isArray(t)){const e=new ce(t);return this.centroidAreaNormal(e)}const e=t.length;if(3===e){const e=t.crossProductIndexIndexIndex(0,1,2),i=.5*e.magnitude(),s=t.getPoint3dAtCheckedPointIndex(0);t.accumulateScaledXYZ(1,1,s),t.accumulateScaledXYZ(2,1,s),s.scaleInPlace(1/3);const n=bt.createCapture(s,e);return n.tryNormalizeInPlaceWithAreaWeight(i)?n:void 0}if(e>=3){const i=$.createZero();for(let s=2;s<e;s++)t.accumulateCrossProductIndexIndexIndex(0,s-1,s,i);i.normalizeInPlace();const s=t.getPoint3dAtCheckedPointIndex(0),n=$.create(),r=$.create();t.vectorXYAndZIndex(s,1,n);let o=$.create();const a=$.createZero(),c=$.createZero();let l;for(let h=2;h<e;h++){t.vectorXYAndZIndex(s,h,r),o=n.crossProduct(r,o),l=i.dotProduct(o),c.addInPlace(o);const e=l/6;a.plus2Scaled(n,e,r,e,a),n.setFrom(r)}const h=.5*c.magnitude(),d=Q.conditionalDivideFraction(1,h);if(void 0!==d){const t=bt.createCapture(s.plusScaled(a,d),c);return t.tryNormalizeInPlaceWithAreaWeight(h),t}}}static centroidAndAreaXY(t,e){let i=0;if(e.set(0,0),t.length<3)return;const s=t[0];let n=J.create(0,0),r=0;for(let e=1;e+1<t.length;e++){const i=s.vectorTo(t[e]),o=s.vectorTo(t[e+1]),a=i.crossProduct(o);n=n.plus(i.plus(o).scale(a)),r+=a}i=.5*r;const o=Q.conditionalDivideFraction(1,6*i);if(void 0!==o)return e.setFrom(s.plusScaled(n,o)),i;e.setFrom(s)}static unitNormal(t,e){e.setZero();let i=t.length;return i>1&&t.getPoint3dAtUncheckedPointIndex(0).isExactEqual(t.getPoint3dAtUncheckedPointIndex(i-1))&&--i,3===i?(t.crossProductIndexIndexIndex(0,1,2,e),e.normalizeInPlace()):4===i?(t.vectorIndexIndex(0,2,Ur._vector0),t.vectorIndexIndex(1,3,Ur._vector1),Ur._vector0.crossProduct(Ur._vector1,e),e.normalizeInPlace()):(Ur.areaNormalGo(t,e),e.normalizeInPlace())}static addSecondMomentAreaProducts(t,e,i){this.addSecondMomentTransformedProducts(Ur._triangleMomentWeights,t,e,2,i)}static addSecondMomentVolumeProducts(t,e,i){this.addSecondMomentTransformedProducts(Ur._tetrahedralMomentWeights,t,e,3,i)}static addSecondMomentTransformedProducts(t,e,i,s,n){const r=Ur._normal;if(Ur.unitNormal(e,r)){const o=Ur._vector0,a=Ur._vector1,c=Ur._vector2,l=Ur._matrixA,h=Ur._matrixB,d=Ur._matrixC,u=e.vectorXYAndZIndex(i,0,Ur._vectorOrigin),f=e.length;let g=0;for(let p=2;p<f;p++)2===s?(e.vectorIndexIndex(0,p-1,o),e.vectorIndexIndex(0,p,a),g=r.tripleProduct(o,a),l.setOriginAndVectors(u,o,a,r),l.multiplyMatrixMatrix(t,h),h.multiplyMatrixMatrixTranspose(l,d),n.addScaledInPlace(d,g)):3===s&&(e.vectorXYAndZIndex(i,0,o),e.vectorXYAndZIndex(i,p-1,a),e.vectorXYAndZIndex(i,p,c),g=o.tripleProduct(a,c),l.setOriginAndVectors(i,o,a,c),l.multiplyMatrixMatrix(t,h),h.multiplyMatrixMatrixTranspose(l,d),n.addScaledInPlace(d,g))}}static testXYPolygonTurningDirections(t){let e=t.length,i=e-1;for(;i>1&&t[i].x===t[0].x&&t[i].y===t[0].y;)e=i--;if(e>2){let s=H.create(t[i].x-t[i-1].x,t[i].y-t[i-1].y);const n=H.create(t[0].x-t[i].x,t[0].y-t[i].y),r=s.x*n.y-s.y*n.x;for(let i=1;i<e;i++)if(s=n.clone(),H.create(t[i].x-t[i-1].x,t[i].y-t[i-1].y,n),(s.x*n.y-s.y*n.x)*r<=0)return 0;return r>0?1:-1}return 0}static isConvex(t){if(!(t instanceof it))return this.isConvex(new ce(t));let e=t.length;e>1&&t.getPoint3dAtUncheckedPointIndex(0).isExactEqual(t.getPoint3dAtUncheckedPointIndex(e-1))&&--e;const i=$.create();if(!this.unitNormal(t,i))return!1;let s=0,n=0;const r=this._vector0;let o=$.createStartEnd(t.getPoint3dAtUncheckedPointIndex(e-1),t.getPoint3dAtUncheckedPointIndex(0),this._vector1);for(let a=1;a<=e;a++){r.setFromVector3d(o),o=$.createStartEnd(t.getPoint3dAtUncheckedPointIndex(a-1),t.getPoint3dAtUncheckedPointIndex(a%e),o);const c=i.tripleProduct(r,o);c>=0?s+=c:n+=c}return Math.abs(n)<Q.smallMetricDistanceSquared*s}static classifyPointInPolygon(t,e,i){const s=new zt(t,e);let n=0;const r=i.length;let o,a=-1;for(n=0;n<r;n++)if(o=n+1,o>=r&&(o=0),s.tryStartEdge(i[n].x,i[n].y,i[o].x,i[o].y)){a=o;break}if(!(a<0)){for(let t=1;t<=r;t++)if(o=a+t,o>=r&&(o-=r),!s.advance(i[o].x,i[o].y))return s.classifyCounts();return s.classifyCounts()}}static classifyPointInPolygonXY(t,e,i){const s=new zt(t,e);let n=0;const r=i.length;let o,a=-1;for(n=0;n<r;n++)if(o=n+1,o>=r&&(o=0),s.tryStartEdge(i.getXAtUncheckedPointIndex(n),i.getYAtUncheckedPointIndex(n),i.getXAtUncheckedPointIndex(o),i.getYAtUncheckedPointIndex(o))){a=o;break}if(!(a<0)){for(let t=1;t<=r;t++)if(o=a+t,o>=r&&(o-=r),!s.advance(i.getXAtUncheckedPointIndex(o),i.getYAtUncheckedPointIndex(o)))return s.classifyCounts();return s.classifyCounts()}}static orientLoopsCCWForOutwardNormalInPlace(t,e){if(t instanceof it)return this.orientLoopsCCWForOutwardNormalInPlace([t],e);const i=$.create();let s=0;for(const n of t)this.unitNormal(n,i)&&i.dotProduct(e)<0&&(n.reverseInPlace(),s++);return s}static sortOuterAndHoleLoopsXY(t){const e=[];for(const i of t)Or.pushPolygon(e,i);return Or.sortAsArrayOfArrayOfPolygons(e)}static sortOuterAndHoleLoops(t,e){const i=Fi.createRightHandedFrame(e,t),s=i?.inverse(),n=[];if(void 0!==s)for(const e of t){const t=new nt(e.length);for(const i of e.points)t.push(s.multiplyPoint3d(i));n.push(t)}const r=Ur.sortOuterAndHoleLoopsXY(n),o=[];if(void 0!==i)for(const t of r){const e=[];for(const s of t){const t=new nt(s.length);for(const e of s.points)t.push(i.multiplyPoint3d(e));e.push(t)}o.push(e)}return o}static closestPointOnBoundary(t,e,i=Q.smallMetricDistance,s){if(!(t instanceof it))return this.closestPointOnBoundary(new ce(t),e,i,s);const n=i*i;let r=t.length;for(;r>1&&!(t.distanceSquaredIndexIndex(0,r-1)>n);)--r;if(s=Yr.create(s),0===r)return s;if(1===r)return t.getPoint3dAtUncheckedPointIndex(0,s.point),s.a=s.point.distance(e),s.v.setZero(),s.code=_.OnPolygonVertex,s.closestEdgeIndex=0,s.closestEdgeParam=0,s;let o=r-1,a=Q.largeCoordinateResult;for(let i=0;i<r;++i){let c=i+1;c===r&&(c=0);const l=t.distanceSquaredIndexIndex(i,c);if(l<=n)continue;const h=t.distanceSquaredIndexXYAndZ(i,e),d=t.dotProductIndexIndexXYAndZ(i,c,e)/l;if(d<=0){const r=h;if(r<=n)return t.getPoint3dAtUncheckedPointIndex(i,s.point),s.a=Math.sqrt(r),s.v.setZero(),s.code=_.OnPolygonVertex,s.closestEdgeIndex=i,s.closestEdgeParam=0,s;r<a&&t.dotProductIndexIndexXYAndZ(i,o,e)<=0&&(t.getPoint3dAtUncheckedPointIndex(i,s.point),s.a=Math.sqrt(r),t.crossProductIndexIndexIndex(i,o,c,s.v),s.code=_.OnPolygonVertex,s.closestEdgeIndex=i,s.closestEdgeParam=0,a=r)}else if(d<=1){const r=h-d*d*l;if(r<=n){const e=h;if(d<=.5&&e<=n)return t.getPoint3dAtUncheckedPointIndex(i,s.point),s.a=Math.sqrt(e),s.v.setZero(),s.code=_.OnPolygonVertex,s.closestEdgeIndex=i,s.closestEdgeParam=0,s;const o=r+(1-d)*(1-d)*l;return d>.5&&o<=n?(t.getPoint3dAtUncheckedPointIndex(c,s.point),s.a=Math.sqrt(o),s.v.setZero(),s.code=_.OnPolygonVertex,s.closestEdgeIndex=c,s.closestEdgeParam=0,s):(t.interpolateIndexIndex(i,d,c,s.point),s.a=Math.sqrt(r),s.v.setZero(),s.code=_.OnPolygonEdgeInterior,s.closestEdgeIndex=i,s.closestEdgeParam=d,s)}r<a&&(t.interpolateIndexIndex(i,d,c,s.point),s.a=Math.sqrt(r),t.crossProductIndexIndexXYAndZ(i,c,e,s.v),s.code=_.OnPolygonEdgeInterior,s.closestEdgeIndex=i,s.closestEdgeParam=d,a=r)}o=i}return s}static closestPoint(t,e,i=Q.smallMetricDistance,s){if(!(t instanceof it))return this.closestPoint(new ce(t),e,i,s);if(!this.unitNormal(t,this._normal))return Yr.create(s);const n=this._workPlane=_t.createXYZUVW(t.getXAtUncheckedPointIndex(0),t.getYAtUncheckedPointIndex(0),t.getZAtUncheckedPointIndex(0),this._normal.x,this._normal.y,this._normal.z,this._workPlane),r=this._workXYZ=n.projectPointToPlane(e,this._workXYZ);return(s=this.closestPointOnBoundary(t,r,i,s)).isValid&&(s.v.dotProduct(this._normal)>0&&(s.point.setFrom(r),_.OnPolygonVertex===s.code?s.code=_.InsidePolygonProjectsToVertex:_.OnPolygonEdgeInterior===s.code&&(s.code=_.InsidePolygonProjectsToEdgeInterior)),s.a=e.distance(s.point),s.v.setZero()),s}static intersectRay3d(t,e,i=Q.smallMetricDistance,s){if(!(t instanceof it))return this.intersectRay3d(new ce(t),e,i,s);if(!this.unitNormal(t,this._normal))return Yr.create(s);this._workPlane=_t.createXYZUVW(t.getXAtUncheckedPointIndex(0),t.getYAtUncheckedPointIndex(0),t.getZAtUncheckedPointIndex(0),this._normal.x,this._normal.y,this._normal.z,this._workPlane);const n=this._workXYZ=j.createZero(this._workXYZ),r=e.intersectionWithPlane(this._workPlane,n);if(void 0===r)return Yr.create(s);if((s=this.closestPointOnBoundary(t,n,i,s)).isValid){s.point.setFrom(n),s.a=r;const t=s.v.dotProduct(this._normal);0===t||(_.OnPolygonVertex===s.code?s.code=t>0?_.InsidePolygonProjectsToVertex:_.OutsidePolygonProjectsToVertex:_.OnPolygonEdgeInterior===s.code&&(s.code=t>0?_.InsidePolygonProjectsToEdgeInterior:_.OutsidePolygonProjectsToEdgeInterior))}return s}static intersectSegment(t,e,i,s=Q.smallMetricDistance,n){return this._workRay=bt.createStartEnd(e,i,this._workRay),this.intersectRay3d(t,this._workRay,s,n)}static computeEdgeDataXY(t,e,i,s,n=Q.smallMetricDistance,r){const o=e%t.length,a=(o+1)%t.length;t.vectorIndexIndex(o,a,s).unitPerpendicularXY(s).negate(s);const c=t.getXAtUncheckedPointIndex(o)-i.x,l=t.getYAtUncheckedPointIndex(o)-i.y;let h=Q.dotProductXYXY(c,l,s.x,s.y);const d=Q.crossProductXYXY(c,l,s.x,s.y),u=Q.distanceXYXY(t.getXAtUncheckedPointIndex(o),t.getYAtUncheckedPointIndex(o),t.getXAtUncheckedPointIndex(a),t.getYAtUncheckedPointIndex(a));let f=Q.safeDivideFraction(d,u,0);return Q.isSameCoordinate(0,h,n)&&(h=0),Q.isSameCoordinate(0,f,n)?f=0:Q.isSameCoordinate(1,f,n)&&(f=1),H.create(h,f,r)}static convexBarycentricCoordinatesOnEdge(t,e,i,s,n,r,o,a){const c=!i.isZero&&0===s.x&&Q.isIn01(s.y),l=!r.isZero&&0===o.x&&Q.isIn01(o.y);if(c&&l)return a.fill(0),a[n]=1,a;const h=t.length;if(c){a.fill(0);const t=e,i=n,r=s.y;return a[t]=1-r,a[i]=r,a}if(l){a.fill(0);const t=n,e=(n+1)%h,i=o.y;return a[t]=1-i,a[e]=i,a}}static convexBarycentricCoordinates(t,i,s=Q.smallMetricDistance){if(Array.isArray(t))return this.convexBarycentricCoordinates(new ce(t),i);let n=t.length;for(;n>1&&t.getPoint3dAtUncheckedPointIndex(0).isExactEqual(t.getPoint3dAtUncheckedPointIndex(n-1));)--n;if(n<3||!Ur.unitNormal(t,this._normal))return;const r=this._workMatrix3d=xt.createRigidHeadsUp(this._normal,g.ZXY,this._workMatrix3d),o=new nt(n);for(let e=0;e<n;++e)o.push(r.multiplyInverseXYZAsPoint3d(t.getXAtUncheckedPointIndex(e),t.getYAtUncheckedPointIndex(e),t.getZAtUncheckedPointIndex(e),this._workXYZ));const a=this._workXYZ=r.multiplyInverseXYZAsPoint3d(i.x,i.y,i.z,this._workXYZ);let c=n-1;const l=this._vector0,h=this._workXY0=this.computeEdgeDataXY(o,c,a,l,s,this._workXY0);if(h.x<0)return;const d=$.createFrom(l,this._vector1),u=this._workXY1=H.createFrom(h,this._workXY1),f=Array(t.length).fill(0),p=s>0?1/(s*s):Q.largeCoordinateResult;let m=0;for(let t=0;t<n;++t){const i=$.createFrom(l,this._vector2),r=this._workXY2=t<n-1?this.computeEdgeDataXY(o,t,a,i,s,this._workXY2):H.createFrom(h,this._workXY2);if(r.x<0)return;if(void 0!==this.convexBarycentricCoordinatesOnEdge(o,c,d,u,t,i,r,f))return f;if(0===i.x&&0===i.y)continue;if(0===u.x||0===r.x)continue;const g=Math.abs(d.crossProductXY(i)),x=Q.conditionalDivideCoordinate(g,u.x*r.x,p);void 0===x&&e(!1,"unexpectedly small projection distance to an edge"),f[t]=x,m+=x,d.setFrom(i),u.setFrom(r),c=t}const x=Q.conditionalDivideCoordinate(1,m);void 0===x&&e(!1,"unexpected zero barycentric coordinate sum");for(let t=0;t<n;++t)f[t]*=x;return f}static forceClosure(t,e=Q.smallMetricDistance){t.length>=2&&(t instanceof nt?t.forceClosure(e):t[0].distance(t[t.length-1])>e?t.push(t[0].clone()):t[t.length-1].setFromPoint3d(t[0]))}static ensureClosed(t,e=Q.smallMetricDistance){if(t.length>=2){let i=!1;if(i=t instanceof it?!t.almostEqualIndexIndex(0,t.length-1,0):!t[0].isExactEqual(t[t.length-1]),i){const i=nt.create(t);this.forceClosure(i,e),t=i}}return t}static closestApproach(t,e,i=Number.MAX_VALUE,s=!1){let n;const r=this.ensureClosed(t),o=this.ensureClosed(e),a=this._workCLDPair=Mi.closestApproach(r,!1,o,!1,i,this._workCLDPair);return a&&a.detailA.childDetail&&a.detailB.childDetail&&(n=Br.create(Yr.createAtVertexOrEdge(a.detailA.point,a.detailA.childDetail.a,a.detailA.childDetail.fraction),Yr.createAtVertexOrEdge(a.detailB.point,a.detailB.childDetail.a,a.detailB.childDetail.fraction)),n.detailA.a=n.detailB.a=a.detailA.a),n}}Ur._triangleMomentWeights=Xt.createRowValues(2/24,1/24,0,4/24,1/24,2/24,0,4/24,0,0,0,0,4/24,4/24,0,.5),Ur._tetrahedralMomentWeights=Xt.createRowValues(1/60,1/120,1/120,1/24,1/120,1/60,1/120,1/24,1/120,1/120,1/60,1/24,1/24,1/24,1/24,1/6),Ur._vector0=$.create(),Ur._vector1=$.create(),Ur._vector2=$.create(),Ur._vectorOrigin=$.create(),Ur._normal=$.create(),Ur._matrixA=Xt.createIdentity(),Ur._matrixB=Xt.createIdentity(),Ur._matrixC=Xt.createIdentity();class Zr{static splitConvexPolygonInsideOutsidePlane(t,e,i,s,n){const r=Zr._xyz0Work,o=Zr._xyz1Work,a=Zr._xyz2Work,c=e.length;if(i.clear(),s.clear(),c>2){e.back(r),n.setNull();let l=t.altitude(r);n.extendX(l);for(let h=0;h<c;h++){e.getPoint3dAtUncheckedPointIndex(h,o);const c=t.altitude(o);n.extendX(c);let d=!1;if(l*c<0){const t=-l/(c-l);t>1-1e-8&&c>=0?d=!0:(r.interpolate(t,o,a),i.push(a),s.push(a))}(c>=0||d)&&i.push(o),(c<=0||d)&&s.push(o),r.setFromPoint3d(o),l=c}}}static clipConvexPolygonInPlace(t,e,i,s=!0,n=Q.smallMetricDistance){i.clear();const r=s?1:-1,o=e.length;let a=0;const c=-n;let l=0;if(e.length>1){let s,h=e.length-1,d=r*e.evaluateUncheckedIndexPlaneAltitude(h,t);Math.abs(d)<n&&(d=0);for(let u=0;u<o;d=s,h=u++){if(s=r*e.evaluateUncheckedIndexPlaneAltitude(u,t),Math.abs(s)<n&&(s=0),s<0&&a++,d*s<0){const t=-d/(s-d);t>1-1e-8&&s>=0||(i.pushInterpolatedFromGrowableXYZArray(e,h,t,u),s>0&&l++)}s>=c&&(i.pushFromGrowableXYZArray(e,u),d<-c&&l++),h=u,d=s}}return i.length<=2?e.clear():a>0&&(e.clear(),e.pushFromGrowableXYZArray(i)),i.clear(),l}static polygonPlaneCrossings(t,e,i){if(i.length=0,e.length>=2){const s=this._xyz0Work;e.getPoint3dAtUncheckedPointIndex(e.length-1,s);let n=t.altitude(s);const r=this._xyz1Work;for(let o=0;o<e.length;o++){e.getPoint3dAtUncheckedPointIndex(o,r);const a=t.altitude(r);if(n*a<0){const t=-n/(a-n);i.push(s.interpolate(t,r))}0===a&&i.push(r.clone()),s.setFromPoint3d(r),n=a}}}static gatherCutLoopsFromPlaneClip(t,e,i=3,s=Q.smallMetricDistance){const n=new Lr;let r=0;const o=e.length;for(;r<o;r++){const i=e.evaluateUncheckedIndexPlaneAltitude(r,t);if(Math.abs(i)<=s)break}if(r===o)return n;let a=r;for(;a<o;){const c=new nt;c.pushFromGrowableXYZArray(e,a);let l=a+1;for(;l<o;){c.pushFromGrowableXYZArray(e,l);const i=e.evaluateUncheckedIndexPlaneAltitude(l,t);if(Math.abs(i)<=s)break;l++}if(l===o)for(let t=0;t<=r;t++)c.pushFromGrowableXYZArray(e,t);c.length>=i&&n.inputLoops.push(Vr.createCaptureWithReturnEdge(c)),a=l}return n}static reorderCutLoops(t){if(1!==t.inputLoops.length){if(2===t.inputLoops.length){if(t.inputLoops[0].edge.direction.dotProduct(t.inputLoops[1].edge.direction)>0)return t.outputLoops.push(t.inputLoops[0]),void t.outputLoops.push(t.inputLoops[1]);const e=t.inputLoops[1].xyz;return t.inputLoops[0].xyz.pushFromGrowableXYZArray(e),void t.outputLoops.push(t.inputLoops[0])}t.sortAndMergeLoops()}}static intersectRangeConvexPolygonInPlace(t,e){if(t.isNull)return;const i=new nt,s=Dt.create();return s.set(0,0,-1,t.high.z),this.clipConvexPolygonInPlace(s,e,i,!0),0!==e.length&&(s.set(0,0,1,-t.low.z),this.clipConvexPolygonInPlace(s,e,i,!0),0!==e.length&&(s.set(0,-1,0,t.high.y),this.clipConvexPolygonInPlace(s,e,i,!0),0!==e.length&&(s.set(0,1,0,-t.low.y),this.clipConvexPolygonInPlace(s,e,i,!0),0!==e.length&&(s.set(-1,0,0,t.high.x),this.clipConvexPolygonInPlace(s,e,i,!0),0!==e.length&&(s.set(1,0,0,-t.low.x),this.clipConvexPolygonInPlace(s,e,i,!0),0!==e.length)))))?e:void 0}}Zr._xyz0Work=j.create(),Zr._xyz1Work=j.create(),Zr._xyz2Work=j.create();class qr{static convexPolygonSplitInsideOutsidePlane(t,e,i,s,n){const r=new ce(e),o=new ce(i),a=new ce(s);Zr.splitConvexPolygonInsideOutsidePlane(t,r,o,a,n)}static polygonPlaneCrossings(t,e,i){const s=new ce(e);return Zr.polygonPlaneCrossings(t,s,i)}static convexPolygonClipInPlace(t,e,i,s=Q.smallMetricDistance){void 0===i&&(i=[]),i.length=0;let n=0;const r=-s;if(e.length>2){let s=e[e.length-1],o=t.altitude(s);for(const a of e){const e=t.altitude(a);if(e<0&&n++,o*e<0){const t=-o/(e-o);t>1-1e-8&&e>=0||i.push(s.interpolate(t,a))}e>=r&&i.push(a),s=j.createFrom(a),o=e}}if(i.length<=2)e.length=0;else if(n>0){e.length=0;for(const t of i)e.push(t);i.length=0}}}qr._xyz0Work=j.create();class Wr extends tt{constructor(t,e,i,s){super(),this._invisible=i,this._interior=s,this._inwardNormal=t,this._distanceFromOrigin=e}isAlmostEqual(t){return Q.isSameCoordinate(this._distanceFromOrigin,t._distanceFromOrigin)&&this._inwardNormal.isAlmostEqual(t._inwardNormal)&&this._interior===t._interior&&this._invisible===t._invisible}clone(){return new Wr(this._inwardNormal.clone(),this._distanceFromOrigin,this._invisible,this._interior)}cloneNegated(){const t=new Wr(this._inwardNormal.clone(),this._distanceFromOrigin,this._invisible,this._interior);return t.negateInPlace(),t}static createPlane(t,e=!1,i=!1,s){const n=t.getNormalRef().dotProduct(t.getOriginRef());return s?(s._invisible=e,s._interior=i,s._inwardNormal=t.getNormalRef().clone(),s._distanceFromOrigin=n,s):new Wr(t.getNormalRef().clone(),n,e,i)}static createNormalAndDistance(t,e,i=!1,s=!1,n){const r=t.normalize();if(r)return n&&(n._invisible=i,n._interior=s,n._inwardNormal=r,n._distanceFromOrigin=e),new Wr(r,e,i,s)}static createNormalAndPoint(t,e,i=!1,s=!1,n){const r=t.normalize();if(r){const t=r.dotProduct(e);return n&&(n._invisible=i,n._interior=s,n._inwardNormal=r,n._distanceFromOrigin=t),new Wr(r,t,i,s)}}static createOriginAndVectors(t,e,i,s=!1,n=!1,r){const o=i.crossProduct(e);return this.createNormalAndPoint(o,t,s,n,r)}static createNormalAndPointXYZXYZ(t,e,i,s,n,r,o=!1,a=!1,c){const l=Q.hypotenuseXYZ(t,e,i),h=Q.conditionalDivideFraction(1,l);if(void 0!==h){if(c)return c._inwardNormal.set(t*h,e*h,i*h),c._distanceFromOrigin=c._inwardNormal.dotProductXYZ(s,n,r),c._invisible=o,c._interior=a,c;const l=$.create(t*h,e*h,i*h);return new Wr(l,l.dotProductXYZ(s,n,r),o,a)}}toJSON(){const t={normal:this.inwardNormalRef.toJSON(),dist:this.distance};return this.interior&&(t.interior=!0),this.invisible&&(t.invisible=!0),t}static fromJSON(t,e){return t&&t.normal&&void 0!==t.dist&&Number.isFinite(t.dist)?Wr.createNormalAndDistance($.fromJSON(t.normal),t.dist,!!t.invisible,!!t.interior):Wr.createNormalAndDistance($.unitZ(),0,!1,!1,e)}setFlags(t,e){this._invisible=t,this._interior=e}get distance(){return this._distanceFromOrigin}get inwardNormalRef(){return this._inwardNormal}get interior(){return this._interior}get invisible(){return this._invisible}static createEdgeAndUpVector(t,e,i,s,n){const r=$.createFrom(e.minus(t));let o=i.crossProduct(r).normalize();if(o){if(void 0!==s&&!s.isAlmostZero){const t=$.createRotateVectorAroundVector(o,r,s);t&&(o=t.clone())}return o.negate(o),Wr.createNormalAndPoint(o,t,!1,!1,n)}}static createEdgeXY(t,e,i){const s=$.create(t.y-e.y,e.x-t.x);if(s.normalizeInPlace())return Wr.createNormalAndPoint(s,t,!1,!1,i)}getPlane3d(){const t=this._distanceFromOrigin;return _t.create(j.create(this._inwardNormal.x*t,this._inwardNormal.y*t,this._inwardNormal.z*t),this._inwardNormal)}getPlane4d(){return Dt.create(this._inwardNormal.x,this._inwardNormal.y,this._inwardNormal.z,-this._distanceFromOrigin)}setPlane4d(t){const e=Math.sqrt(t.x*t.x+t.y*t.y+t.z*t.z),i=0===e?1:1/e;this._inwardNormal.x=i*t.x,this._inwardNormal.y=i*t.y,this._inwardNormal.z=i*t.z,this._distanceFromOrigin=-i*t.w}weightedAltitude(t){return t.x*this._inwardNormal.x+t.y*this._inwardNormal.y+t.z*this._inwardNormal.z-t.w*this._distanceFromOrigin}altitude(t){return t.x*this._inwardNormal.x+t.y*this._inwardNormal.y+t.z*this._inwardNormal.z-this._distanceFromOrigin}altitudeXYZ(t,e,i){return t*this._inwardNormal.x+e*this._inwardNormal.y+i*this._inwardNormal.z-this._distanceFromOrigin}normalX(){return this._inwardNormal.x}normalY(){return this._inwardNormal.y}normalZ(){return this._inwardNormal.z}velocity(t){return t.x*this._inwardNormal.x+t.y*this._inwardNormal.y+t.z*this._inwardNormal.z}velocityXYZ(t,e,i){return t*this._inwardNormal.x+e*this._inwardNormal.y+i*this._inwardNormal.z}dotProductPlaneNormalPoint(t){return t.x*this._inwardNormal.x+t.y*this._inwardNormal.y+t.z*this._inwardNormal.z}isPointOnOrInside(t,e=Q.smallMetricDistance){let i=this.altitude(t);return e&&(i+=e),i>=0}isPointInside(t,e=Q.smallMetricDistance){let i=this.altitude(t);return e&&(i-=e),i>0}isPointOn(t,e=Q.smallMetricDistance){return Math.abs(this.altitude(t))<=e}appendIntersectionRadians(t,e){const i=t.toVectors(),s=this.altitude(t.center),n=this.velocity(i.vector0),r=this.velocity(i.vector90);wt.appendImplicitLineUnitCircleIntersections(s,n,r,void 0,void 0,e)}announceClippedArcIntervals(t,e){const i=Wr._clipArcFractionArray;return i.clear(),this.appendIntersectionRadians(t,i),t.sweep.radiansArrayToPositivePeriodicFractions(i),Rs.selectIntervals01(t,i,this,e)}getBoundedSegmentSimpleIntersection(t,e){const i=this.altitude(t),s=this.altitude(e);if(!(i*s>0||0===i&&0===s))return-i/(s-i)}transformInPlace(t){const e=this.getPlane3d(),i=t.matrix,s=t.multiplyPoint3d(e.getOriginRef()),n=i.multiplyInverseTranspose(e.getNormalRef());if(!n)return!1;e.set(s,n);const r=e.getNormalRef().normalize();return!!r&&(this._inwardNormal=r,this._distanceFromOrigin=this._inwardNormal.dotProduct(e.getOriginRef()),!0)}setInvisible(t){this._invisible=t}negateInPlace(){this._inwardNormal=this._inwardNormal.negate(),this._distanceFromOrigin=-this._distanceFromOrigin}offsetDistance(t){this._distanceFromOrigin+=t}clipConvexPolygonInPlace(t,e,i=!0,s=Q.smallMetricDistance){return Zr.clipConvexPolygonInPlace(this,t,e,i,s)}multiplyPlaneByMatrix4d(t,e=!0,i=!0){const s=this.getPlane4d();if(e){const e=t.createInverse();return!!e&&this.multiplyPlaneByMatrix4d(e,!1,i)}return i?t.multiplyTransposePoint4d(s,s):t.multiplyPoint4d(s,s),this.setPlane4d(s),!0}announceClippedSegmentIntervals(t,e,i,s,n){if(e<t)return!1;const r=-this.altitude(i),o=-this.altitude(s)-r,a=Q.conditionalDivideFraction(-r,o);return void 0===a?r<=0&&(n&&n(t,e),!0):(o>0?a<e&&(e=a):a>t&&(t=a),!(e<t||(n&&n(t,e),0)))}getFrame(){const t=this._distanceFromOrigin,e=j.create(this._inwardNormal.x*t,this._inwardNormal.y*t,this._inwardNormal.z*t),i=xt.createRigidHeadsUp(this._inwardNormal,g.ZXY);return pt.createOriginAndMatrix(e,i)}intersectRange(t,e=!1){if(t.isNull)return;const i=t.corners(),s=this.getFrame();s.multiplyInversePoint3dArrayInPlace(i);const n=ut.createArray(i);if(n.low.z*n.high.z>0)return;const r=new nt;return r.pushXYZ(n.low.x,n.low.y,0),r.pushXYZ(n.high.x,n.low.y,0),r.pushXYZ(n.high.x,n.high.y,0),r.pushXYZ(n.low.x,n.high.y,0),r.multiplyTransformInPlace(s),Zr.intersectRangeConvexPolygonInPlace(t,r),0!==r.length?(e&&r.pushWrap(1),r):void 0}appendPolygonClip(t,e,i,s){const n=ft.createNull(),r=s.grabFromCache(),o=s.grabFromCache();Zr.splitConvexPolygonInsideOutsidePlane(this,t,r,o,n),Rs.captureOrDrop(r,3,e,s),Rs.captureOrDrop(o,3,i,s)}projectPointToPlane(t,e){const i=-this.altitude(t);return t.plusXYZ(i*this._inwardNormal.x,i*this._inwardNormal.y,i*this._inwardNormal.z,e)}}Wr._clipArcFractionArray=new It;const Gr={aliceBlue:16775408,amber:49151,antiqueWhite:14150650,aqua:16776960,aquamarine:13959039,azure:16777200,beige:14480885,bisque:12903679,black:0,blanchedAlmond:13495295,blue:16711680,blueViolet:14822282,brown:2763429,burlyWood:8894686,cadetBlue:10526303,chartreuse:65407,chocolate:1993170,coral:5275647,cornflowerBlue:15570276,cornSilk:14481663,crimson:3937500,cyan:16776960,darkBlue:9109504,darkBrown:2179941,darkCyan:9145088,darkGoldenrod:755384,darkGray:11119017,darkGreen:25600,darkGrey:11119017,darkKhaki:7059389,darkMagenta:9109643,darkOliveGreen:3107669,darkOrange:36095,darkOrchid:13382297,darkRed:139,darkSalmon:8034025,darkSeagreen:9419919,darkSlateBlue:9125192,darkSlateGray:5197615,darkSlateGrey:5197615,darkTurquoise:13749760,darkViolet:13828244,deepPink:9639167,deepSkyBlue:16760576,dimGray:6908265,dimGrey:6908265,dodgerBlue:16748574,fireBrick:2237106,floralWhite:15792895,forestGreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostWhite:16775416,gold:55295,goldenrod:2139610,gray:8421504,green:32768,greenYellow:3145645,grey:8421504,honeydew:15794160,hotPink:11823615,indianRed:6053069,indigo:8519755,ivory:15794175,khaki:9234160,lavender:16443110,lavenderBlush:16118015,lawnGreen:64636,lemonChiffon:13499135,lightBlue:15128749,lightCoral:8421616,lightCyan:16777184,lightGoldenrodYellow:13826810,lightGray:13882323,lightGreen:9498256,lightGrey:13882323,lightPink:12695295,lightSalmon:8036607,lightSeagreen:11186720,lightSkyBlue:16436871,lightSlateGray:10061943,lightSlateGrey:10061943,lightSteelBlue:14599344,lightyellow:14745599,lime:65280,limeGreen:3329330,linen:15134970,magenta:16711935,maroon:128,mediumAquamarine:11193702,mediumBlue:13434880,mediumOrchid:13850042,mediumPurple:14381203,mediumSeaGreen:7451452,mediumSlateBlue:15624315,mediumSpringGreen:10156544,mediumTurquoise:13422920,mediumVioletRed:8721863,midnightBlue:7346457,mintCream:16449525,mistyRose:14804223,moccasin:11920639,navajoWhite:11394815,navy:8388608,oldLace:15136253,olive:32896,oliveDrab:2330219,orange:42495,orangeRed:17919,orchid:14053594,paleGoldenrod:11200750,paleGreen:10025880,paleTurquoise:15658671,paleVioletRed:9662683,papayaWhip:14020607,peachPuff:12180223,peru:4163021,pink:13353215,plum:14524637,powderBlue:15130800,purple:8388736,rebeccaPurple:10040166,red:255,rosyBrown:9408444,royalBlue:14772545,saddleBrown:1262987,salmon:7504122,sandyBrown:6333684,seaGreen:5737262,seaShell:15660543,sienna:2970272,silver:12632256,skyBlue:15453831,slateBlue:13458026,slateGray:9470064,slateGrey:9470064,snow:16448255,springGreen:8388352,steelBlue:11829830,tan:9221330,teal:8421376,thistle:14204888,tomato:4678655,turquoise:13688896,violet:15631086,wheat:11788021,white:16777215,whiteSmoke:16119285,yellow:65535,yellowGreen:3329434};class Hr{constructor(t=0,e=0,i=0){this.h=t,this.s=e,this.l=i}clone(t,e,i){return new Hr(t??this.h,e??this.s,i??this.l)}toColorDef(t=0){return $r.fromHSL(this.h,this.s,this.l,t)}static fromColorDef(t){return t.toHSL()}}var Jr;!function(t){t[t.VISIBILITY_GOAL=40]="VISIBILITY_GOAL",t[t.HSV_SATURATION_WEIGHT=4]="HSV_SATURATION_WEIGHT",t[t.HSV_VALUE_WEIGHT=2]="HSV_VALUE_WEIGHT"}(Jr||(Jr={}));class Qr{constructor(t=0,e=0,i=0){this.h=t,this.s=e,this.v=i}clone(t,e,i){return new Qr(t??this.h,e??this.s,i??this.v)}toColorDef(t=0){return $r.fromHSV(this,t)}static fromColorDef(t){return t.toHSV()}adjusted(t,e){let i;if(t){if(i=e*Jr.HSV_VALUE_WEIGHT,this.v>=i)return new Qr(this.h,this.s,this.v-i);i-=this.v;const t=Math.min(this.s+i,100);return new Qr(this.h,t,0)}if(i=e*Jr.HSV_SATURATION_WEIGHT,this.s>=i)return new Qr(this.h,this.s-i,this.v);i-=this.s;const s=Math.min(this.v+i,100);return new Qr(this.h,0,s)}}const Kr=new Uint8Array(4),jr=new Uint32Array(Kr.buffer);class $r{constructor(t){jr[0]=t,this._tbgr=jr[0]}static create(t){return this.fromTbgr(this.computeTbgr(t))}static computeTbgr(t){switch(typeof t){case"number":return t;case"string":return this.computeTbgrFromString(t);default:return 0}}toJSON(){return this._tbgr}static fromJSON(t){return this.create(t)}static from(t,e,i,s){return this.fromTbgr(this.computeTbgrFromComponents(t,e,i,s))}static computeTbgrFromComponents(t,e,i,s){return Kr[0]=t,Kr[1]=e,Kr[2]=i,Kr[3]=s||0,jr[0]}static fromTbgr(t){switch(t){case Gr.black:return this.black;case Gr.white:return this.white;case Gr.red:return this.red;case Gr.green:return this.green;case Gr.blue:return this.blue;default:return new $r(t)}}static fromAbgr(t){return this.fromTbgr(this.getAbgr(t))}static fromString(t){return this.fromTbgr(this.computeTbgrFromString(t))}static isValidColor(t){return"number"==typeof t?t>=0&&t<=4294967295&&Math.floor(t)===t:void 0!==this.tryComputeTbgrFromString(t)}static computeTbgrFromString(t){return this.tryComputeTbgrFromString(t)??0}static tryComputeTbgrFromString(t){if("string"!=typeof t)return;t=t.toLowerCase();let e=/^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t);if(e){let t;const i=e[1],s=e[2],n=t=>"%"===t[t.length-1],r=t=>{const e=parseFloat(t);return 255*Q.clamp(n(t)?e/100:e,0,1)},o=t=>{const e=n(t)?parseFloat(t)/100*255:parseInt(t,10);return Q.clamp(e,0,255)};switch(i){case"rgb":case"rgba":if(t=/^(\d+%*)\s*[, ]\s*(\d+%*)\s*[, ]\s*(\d+%*)\s*([,\/]\s*([0-9]*\.?[0-9]+%*)\s*)?$/.exec(s),t)return this.computeTbgrFromComponents(o(t[1]),o(t[2]),o(t[3]),"string"==typeof t[5]?255-r(t[5]):0);break;case"hsl":case"hsla":if(t=/^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(s),t){const e=parseFloat(t[1])/360,i=parseInt(t[2],10)/100,s=parseInt(t[3],10)/100,n="string"==typeof t[5]?255-r(t[5]):0;return this.computeTbgrFromHSL(e,i,s,n)}}}else if(e=/^\#([a-f0-9]+)$/.exec(t)){const t=e[1],i=t.length;if(3===i)return this.computeTbgrFromComponents(parseInt(t.charAt(0)+t.charAt(0),16),parseInt(t.charAt(1)+t.charAt(1),16),parseInt(t.charAt(2)+t.charAt(2),16),0);if(6===i)return this.computeTbgrFromComponents(parseInt(t.charAt(0)+t.charAt(1),16),parseInt(t.charAt(2)+t.charAt(3),16),parseInt(t.charAt(4)+t.charAt(5),16),0)}if(t&&t.length>0)for(const[e,i]of Object.entries(Gr))if(e.toLowerCase()===t)return i}get colors(){return $r.getColors(this._tbgr)}static getColors(t){return jr[0]=t,{b:Kr[2],g:Kr[1],r:Kr[0],t:Kr[3]}}get tbgr(){return this._tbgr}getAbgr(){return $r.getAbgr(this._tbgr)}static getAbgr(t){return jr[0]=t,Kr[3]=255-Kr[3],jr[0]}getRgb(){return $r.getRgb(this._tbgr)}static getRgb(t){return jr[0]=t,(Kr[0]<<16)+(Kr[1]<<8)+Kr[2]}withAlpha(t){const e=$r.withAlpha(this._tbgr,t);return e===this._tbgr?this:$r.fromTbgr(e)}static withAlpha(t,e){return jr[0]=t,Kr[3]=255-(0|e),jr[0]}getAlpha(){return $r.getAlpha(this._tbgr)}static getAlpha(t){return jr[0]=t,255-Kr[3]}get isOpaque(){return $r.isOpaque(this._tbgr)}static isOpaque(t){return 255===this.getAlpha(t)}getTransparency(){return $r.getTransparency(this._tbgr)}static getTransparency(t){return jr[0]=t,Kr[3]}withTransparency(t){const e=$r.withTransparency(this._tbgr,t);return e===this._tbgr?this:$r.fromTbgr(e)}static withTransparency(t,e){return this.withAlpha(t,255-e)}get name(){return $r.getName(this.tbgr)}static getName(t){for(const[e,i]of Object.entries(Gr))if(i===t)return e}toHexString(){return $r.toHexString(this.tbgr)}static toHexString(t){return`#${`000000${this.getRgb(t).toString(16)}`.slice(-6)}`}static getColorsString(t){const e=this.getColors(t);return`${e.r},${e.g},${e.b}`}toRgbString(){return $r.toRgbString(this.tbgr)}static toRgbString(t){return`rgb(${this.getColorsString(t)})`}toRgbaString(){return $r.toRgbaString(this.tbgr)}static toRgbaString(t){return`rgba(${this.getColorsString(t)},${this.getAlpha(t)/255})`}lerp(t,e){return $r.fromTbgr($r.lerp(this.tbgr,t.tbgr,e))}static lerp(t,e,i){const s=this.getColors(t),n=this.getColors(e);return s.r+=(n.r-s.r)*i,s.g+=(n.g-s.g)*i,s.b+=(n.b-s.b)*i,this.computeTbgrFromComponents(s.r,s.g,s.b,s.t)}inverse(){return $r.fromTbgr($r.inverse(this.tbgr))}static inverse(t){const e=this.getColors(t);return this.computeTbgrFromComponents(255-e.r,255-e.g,255-e.b)}static fromHSL(t,e,i,s=0){return this.fromTbgr(this.computeTbgrFromHSL(t,e,i,s))}static computeTbgrFromHSL(t,e,i,s=0){const n=(t,e,i)=>Math.round(255*((t,e,i)=>(i<0&&(i+=1),i>1&&(i-=1),i<1/6?t+6*(e-t)*i:i<.5?e:i<2/3?t+6*(e-t)*(2/3-i):t))(t,e,i));if(t=(t%1+1)%1,e=Q.clamp(e,0,1),i=Q.clamp(i,0,1),0===e)return i*=255,this.computeTbgrFromComponents(i,i,i,s);const r=i<=.5?i*(1+e):i+e-i*e,o=2*i-r;return this.computeTbgrFromComponents(n(o,r,t+1/3),n(o,r,t),n(o,r,t-1/3),s)}toHSL(){const t=this.colors;t.r/=255,t.g/=255,t.b/=255;const e=Math.max(t.r,t.g,t.b),i=Math.min(t.r,t.g,t.b);let s,n=0;const r=(i+e)/2;if(i===e)s=0;else{const o=e-i;switch(s=r<=.5?o/(e+i):o/(2-e-i),e){case t.r:n=(t.g-t.b)/o+(t.g<t.b?6:0);break;case t.g:n=(t.b-t.r)/o+2;break;case t.b:n=(t.r-t.g)/o+4}n/=6}return new Hr(n,s,r)}toHSV(){const{r:t,g:e,b:i}=this.colors;let s=t<e?t:e;i<s&&(s=i);let n=t>e?t:e;i>n&&(n=i);const r=Math.floor(n/255*100+.5),o=n-s,a=0!==n?Math.floor(o/n*100+.5):0;let c=0;if(a){const s=(n-t)/o,r=(n-e)/o,a=(n-i)/o;let l;l=t===n?a-r:e===n?2+s-a:4+r-s,l*=60,l<0&&(l+=360),c=Math.floor(l+.5),c>=360&&(c=0)}else c=0;return new Qr(c,a,r)}static fromHSV(t,e=0){if(!t.s||-1===t.h){const e=255&Math.floor(255*t.v/100+.5+3e-14);return $r.from(e,e,e,0)}let i=t.h,s=t.s,n=t.v;360===i&&(i=0),i/=60;const r=Math.floor(i),o=i-r;n/=100,s/=100;const a=255&Math.floor(n*(1-s)*255+.5),c=255&Math.floor(n*(1-s*o)*255+.5),l=255&Math.floor(n*(1-s*(1-o))*255+.5),h=255&Math.floor(255*n+.5);let d=0,u=0,f=0;switch(r){case 0:d=h,f=l,u=a;break;case 1:d=c,f=h,u=a;break;case 2:d=a,f=h,u=l;break;case 3:d=a,f=c,u=h;break;case 4:d=l,f=a,u=h;break;case 5:d=h,f=a,u=c}return $r.from(d,f,u,e)}visibilityCheck(t){const e=this.colors,i=t.colors;return.3*Math.abs(e.r-i.r)+.59*Math.abs(e.g-i.g)+.11*Math.abs(e.b-i.b)}adjustedForContrast(t,e){const i=this.visibilityCheck(t);if(Jr.VISIBILITY_GOAL<=i)return void 0!==e?this.withAlpha(e):this;const s=Math.floor((Jr.VISIBILITY_GOAL-i)/255*100);let n=this.toHSV(),r=n.clone();n=n.adjusted(!0,s),r=r.adjusted(!1,s),void 0===e&&(e=this.getAlpha());const o=$r.fromHSV(n).withAlpha(e),a=$r.fromHSV(r).withAlpha(e);return a.getRgb()===t.getRgb()?o:o.getRgb()===t.getRgb()||a.visibilityCheck(t)>=o.visibilityCheck(t)?a:o}equals(t){return this._tbgr===t._tbgr}}$r.black=new $r(Gr.black),$r.white=new $r(Gr.white),$r.red=new $r(Gr.red),$r.green=new $r(Gr.green),$r.blue=new $r(Gr.blue);class to{constructor(t,e,i){this.r=t,this.g=e,this.b=i,this.r=Math.max(0,Math.min(this.r,255)),this.g=Math.max(0,Math.min(this.g,255)),this.b=Math.max(0,Math.min(this.b,255))}static fromColorDef(t){const e=t.colors;return new to(e.r,e.g,e.b)}toColorDef(t=0){return $r.from(this.r,this.g,this.b,t)}toJSON(){return{r:this.r,g:this.g,b:this.b}}static fromJSON(t){let e=255,i=255,s=255;return void 0!==t&&("number"==typeof t.r&&(e=t.r),"number"==typeof t.g&&(i=t.g),"number"==typeof t.b&&(s=t.b)),new to(e,i,s)}equals(t){return this.r===t.r&&this.g===t.g&&this.b===t.b}compareTo(t){return i(this.r,t.r)||i(this.g,t.g)||i(this.b,t.b)}toHexString(){return this.toColorDef().toHexString()}}class eo{constructor(t,e){this.value=t,this.index=e}}class io{constructor(t,e=Number.MAX_SAFE_INTEGER,i=Le){this._array=[],this._compareValues=t,this._clone=i,this._maximumSize=e}get length(){return this._array.length}get isFull(){return this.length>=this._maximumSize}get isEmpty(){return 0===this.length}clear(){this._array=[]}insert(t,e){const i=this.lowerBound(t);if(i.equal)return this._array[i.index].index;if(this.isFull)return-1;const s=new eo(this._clone(t),this._array.length);return void 0!==e&&e(s.value),this._array.splice(i.index,0,s),s.index}indexOf(t){const e=this.lowerBound(t);return e.equal?this._array[e.index].index:-1}lowerBound(t){return Ue(t,this._array,((t,e)=>this._compareValues(t,e.value)))}toArray(){const t=[];for(const e of this._array)t[e.index]=e.value;return t}}var so,no,ro,oo,ao,co;!function(t){t[t.Never=0]="Never",t[t.ByView=1]="ByView",t[t.Always=2]="Always",t[t.Blanking=3]="Blanking"}(so||(so={})),function(t){t[t.None=0]="None",t[t.Solid=1]="Solid",t[t.Outline=2]="Outline"}(no||(no={})),function(t){t[t.Primary=0]="Primary",t[t.Construction=1]="Construction",t[t.Dimension=2]="Dimension",t[t.Pattern=3]="Pattern"}(ro||(ro={}));class lo{constructor(t=h.invalid,e=h.invalid,i=ro.Primary){this.elementId=t,this.subCategoryId=e,this.geometryClass=i}get isDefined(){return!h.isInvalid(this.elementId)||!h.isInvalid(this.subCategoryId)||this.geometryClass!==ro.Primary}get isUndefined(){return!this.isDefined}equals(t){return 0===this.compare(t)}compare(t){if(this===t)return 0;let e=i(this.geometryClass,t.geometryClass);return 0===e&&(e=n(this.elementId,t.elementId),0===e&&(e=n(this.subCategoryId,t.subCategoryId))),e}}!function(t){t.create=function(){return{modelId:h.invalid,elementId:h.invalid,subCategoryId:h.invalid,geometryClass:ro.Primary}},t.isDefined=function(t){return!h.isInvalid(t.modelId)||!h.isInvalid(t.elementId)||!h.isInvalid(t.subCategoryId)||t.geometryClass!==ro.Primary},t.unpack=function(t,e,i){return e.modelId=i??h.fromUint32PairObject(t.modelId),e.elementId=h.fromUint32PairObject(t.elementId),e.subCategoryId=h.fromUint32PairObject(t.subCategoryId),e.geometryClass=t.geometryClass,e}}(oo||(oo={})),function(t){function e(){const t={upper:0,lower:0};return{modelId:{...t},elementId:{...t},subCategoryId:{...t},geometryClass:ro.Primary,animationNodeId:0}}t.create=e,t.createWithIndex=function(){const t=e();return t.index=0,t}}(ao||(ao={})),function(t){t[t.Primary=0]="Primary",t[t.VolumeClassifier=1]="VolumeClassifier",t[t.PlanarClassifier=2]="PlanarClassifier"}(co||(co={}));class ho extends io{constructor(t,e=h.invalid,i=co.Primary){super(((t,e)=>t.compare(e)),t),this.modelId=e,this.type=i}get maxFeatures(){return this._maximumSize}get anyDefined(){return this.length>1||1===this.length&&this._array[0].value.isDefined}get isUniform(){return 1===this.length}get uniform(){return 1===this.length?this._array[0].value:void 0}get isVolumeClassifier(){return co.VolumeClassifier===this.type}get isPlanarClassifier(){return co.PlanarClassifier===this.type}findFeature(t){for(const e of this._array)if(e.index===t)return e.value}insertWithIndex(t,i){const s=this.lowerBound(t);e(!s.equal),e(!this.isFull);const n=new eo(t,i);this._array.splice(s.index,0,n)}getArray(){return this._array}pack(){return go.pack(this)}}const uo=ao.create();function fo(t,i,s){let n;e(s>0);const r=ao.createWithIndex();for(const o of t.iterable(r)){const r=i(o);if(e(r<=s),0!==r){if(!n){const e=t.numFeatures;n=s<256?new Uint8Array(e):s<65536?new Uint16Array(e):new Uint32Array(e)}n[o.index]=r}}return n}class go{get byteLength(){return this.data.byteLength}constructor(t,i,s,n,r){switch(this.data=t,this.batchModelId=i,this.batchModelIdPair=h.getUint32Pair(i),this.numFeatures=s,this.type=n,this.animationNodeIds=r,this.numFeatures){case 0:this.anyDefined=!1;break;case 1:this.anyDefined=oo.isDefined(this.getFeature(0,oo.create()));break;default:this.anyDefined=!0}e(this.data.length>=this._subCategoriesOffset),e(void 0===this.animationNodeIds||this.animationNodeIds.length===this.numFeatures)}static pack(t){const i=new Map;for(const e of t.getArray())void 0===i.get(e.value.subCategoryId.toString())&&i.set(e.value.subCategoryId,i.size);const s=3*t.length,n=s+2*i.size,r=new Uint32Array(n);for(const s of t.getArray()){const t=s.value,n=3*s.index;let o=i.get(t.subCategoryId);e(void 0!==o),o|=t.geometryClass<<24,r[n+0]=h.getLowerUint32(t.elementId),r[n+1]=h.getUpperUint32(t.elementId),r[n+2]=o}return i.forEach(((t,e,i)=>{const n=s+2*t;r[n+0]=h.getLowerUint32(e),r[n+1]=h.getUpperUint32(e)})),new go(r,t.modelId,t.length,t.type)}getFeature(t,e){const i=this.getPackedFeature(t,uo);return oo.unpack(i,e,this.batchModelId)}findFeature(t,e){return t<this.numFeatures?this.getFeature(t,e):void 0}getElementIdPair(t,i){i=i??{lower:0,upper:0},e(t<this.numFeatures);const s=3*t;return i.lower=this.data[s],i.upper=this.data[s+1],i}getSubCategoryIdPair(t){const e=3*t;let i=this.data[e+2];return i=(16777215&i)>>>0,i=2*i+this._subCategoriesOffset,{lower:this.data[i],upper:this.data[i+1]}}getAnimationNodeId(t){return void 0!==this.animationNodeIds&&t<this.numFeatures?this.animationNodeIds[t]:0}getPackedFeature(t,i){e(t<this.numFeatures);const s=3*t;i.elementId.lower=this.data[s],i.elementId.upper=this.data[s+1];const n=this.data[s+2];i.geometryClass=n>>>24&255;let r=(16777215&n)>>>0;return r=2*r+this._subCategoriesOffset,i.subCategoryId.lower=this.data[r],i.subCategoryId.upper=this.data[r+1],i.animationNodeId=this.getAnimationNodeId(t),i.modelId.lower=this.batchModelIdPair.lower,i.modelId.upper=this.batchModelIdPair.upper,i}getModelIdPair(t,e){return e.lower=this.batchModelIdPair.lower,e.upper=this.batchModelIdPair.upper,e}findElementId(t){return t>=this.numFeatures?void 0:this.readId(3*t)}get isUniform(){return 1===this.numFeatures}getUniform(t){return this.isUniform?this.getFeature(0,t):void 0}get isVolumeClassifier(){return co.VolumeClassifier===this.type}get isPlanarClassifier(){return co.VolumeClassifier===this.type}get isClassifier(){return this.isVolumeClassifier||this.isPlanarClassifier}unpack(){const t=new ho(this.numFeatures,this.batchModelId),e=oo.create();for(let i=0;i<this.numFeatures;i++)this.getFeature(i,e),t.insertWithIndex(new lo(e.elementId,e.subCategoryId,e.geometryClass),i);return t}populateAnimationNodeIds(t,i){e(void 0===this.animationNodeIds),this.animationNodeIds=fo(this,t,i)}*iterator(t){for(let e=0;e<this.numFeatures;e++)this.getPackedFeature(e,t),t.index=e,yield t}iterable(t){return{[Symbol.iterator]:()=>this.iterator(t)}}get _subCategoriesOffset(){return 3*this.numFeatures}readId(t){return h.fromUint32Pair(this.data[t],this.data[t+1])}}const po={lastFeatureIndex:-1,idLower:-1,idUpper:-1};class mo{constructor(t){this._data=t,e(this._data.length%3==0)}get length(){return this._data.length/3}get byteLength(){return this._data.byteLength}getLastFeatureIndex(t){return this._data[3*t]}getEntry(t,e){if(t>=this.length)return e.idLower=e.idUpper=0,e.lastFeatureIndex=Number.MAX_SAFE_INTEGER,e;const i=3*t;return e.lastFeatureIndex=this._data[i+0],e.idLower=this._data[i+1],e.idUpper=this._data[i+2],e}getModelIdPair(t,e){e?e.lower=e.upper=0:e={lower:0,upper:0};let i=0;const s=this.length;let n=s;for(;n>0;){const e=Math.floor(n/2),s=i+e;t>this.getLastFeatureIndex(s)?(i=s+1,n-=e+1):n=e}return i<s&&(e.lower=this._data[3*i+1],e.upper=this._data[3*i+2]),e}}class xo{constructor(t,e){this._features=t,this._models=e}static create(t,e,i,s,n){const r=3*i+2*n,o=t.subarray(0,r),a=new go(o,e,i,s),c=t.subarray(r),l=new mo(c);return new xo(a,l)}get batchModelId(){return this._features.batchModelId}get batchModelIdPair(){return this._features.batchModelIdPair}get numFeatures(){return this._features.numFeatures}get type(){return this._features.type}get animationNodeIds(){return this._features.animationNodeIds}set animationNodeIds(t){this._features.animationNodeIds=t}get byteLength(){return this._features.byteLength+this._models.byteLength}getPackedFeature(t,e){return this._features.getPackedFeature(t,e),this._models.getModelIdPair(t,e.modelId),e}getFeature(t,e){const i=this.getPackedFeature(t,uo);return oo.unpack(i,e)}findFeature(t,e){return t<this.numFeatures?this.getFeature(t,e):void 0}getElementIdPair(t,e){return this._features.getElementIdPair(t,e)}getModelIdPair(t,e){return this._models.getModelIdPair(t,e),e}findElementId(t){return this._features.findElementId(t)}*iterator(t){let e=0;const i=this._models.getEntry(e,po);for(let s=0;s<this.numFeatures;s++)s>i.lastFeatureIndex&&this._models.getEntry(++e,i),this._features.getPackedFeature(s,t),t.modelId.lower=i.idLower,t.modelId.upper=i.idUpper,t.index=s,yield t}iterable(t){return{[Symbol.iterator]:()=>this.iterator(t)}}getAnimationNodeId(t){return this._features.getAnimationNodeId(t)}populateAnimationNodeIds(t,e){this._features.animationNodeIds=fo(this,t,e)}}function _o(t,e){if(t.clear(),"string"==typeof e)t.addId(e);else for(const i of e)t.addId(i)}function yo(t,e){return t===e||!(!t||!e)&&t.equals(e)}function vo(t,e){return t===e||void 0!==t&&void 0!==e&&Math.floor(255*t)===Math.floor(255*e)}function Po(t){if(void 0===t)return;const e=1e-4;return 1-(t=Math.max(0,Math.min(t,1)))<e?t=1:t<e&&(t=0),t}class Ao{static fromJSON(t){return!t||function(t){return!(t.rgb||t.lineRgb||void 0!==t.weight||void 0!==t.linePixels||void 0!==t.transparency||void 0!==t.lineTransparency||t.ignoresMaterial||t.nonLocatable||t.emphasized)}(t)?this.defaults:new Ao(t)}static fromRgb(t){return new Ao({rgb:to.fromColorDef(t)})}static fromRgba(t,e=!1){return new Ao({rgb:to.fromColorDef(t),transparency:t.colors.t/255,viewDependentTransparency:!!e||void 0})}static fromTransparency(t,e=!1){return new Ao({transparency:t,viewDependentTransparency:!!e||void 0})}static fromSubCategoryOverride(t){const e=void 0!==t.color?to.fromColorDef(t.color):void 0,i=t.transparency,s=t.weight,n=!(void 0===t.material||!h.isValid(t.material))||void 0;return this.fromJSON({rgb:e,transparency:i,weight:s,ignoresMaterial:n,viewDependentTransparency:!0})}get matchesDefaults(){return this.equals(Ao.defaults)}get overridesRgb(){return void 0!==this.rgb}get overridesTransparency(){return void 0!==this.transparency}get overridesLinePixels(){return void 0!==this.linePixels}get overridesWeight(){return void 0!==this.weight}getLineRgb(){return!1!==this.lineRgb?this.lineRgb??this.rgb:void 0}getLineTransparency(){return!1!==this.lineTransparency?this.lineTransparency??this.transparency:void 0}get overridesSymbology(){return this.overridesRgb||this.overridesTransparency||this.overridesWeight||this.overridesLinePixels||!!this.ignoresMaterial||this.emphasized||this.overridesNonLocatable||void 0!==this.getLineRgb()||void 0!==this.getLineTransparency()}get overridesNonLocatable(){return void 0!==this.nonLocatable}get isFullyTransparent(){const t=this.transparency??0,e=this.getLineTransparency()??0;return t>=1&&e>=1}get anyOverridden(){return this.overridesSymbology||this.overridesNonLocatable}equals(t){return this===t||yo(this.rgb,t.rgb)&&this.weight===t.weight&&vo(this.transparency,t.transparency)&&this.linePixels===t.linePixels&&this.ignoresMaterial===t.ignoresMaterial&&this.nonLocatable===t.nonLocatable&&this.emphasized===t.emphasized&&this.viewDependentTransparency===t.viewDependentTransparency&&((i=this.lineTransparency)===(s=t.lineTransparency)||("number"==typeof i&&"number"==typeof s?vo(i,s):(e(void 0===i||!1===i),e(void 0===s||!1===s),!1)))&&function(t,i){return t===i||(t instanceof to&&i instanceof to?yo(t,i):(e(void 0===t||!1===t),e(void 0===i||!1===i),!1))}(this.lineRgb,t.lineRgb);var i,s}toJSON(){const t={};return this.rgb&&(t.rgb=this.rgb.toJSON()),void 0!==this.weight&&(t.weight=this.weight),void 0!==this.transparency&&(t.transparency=this.transparency,this.viewDependentTransparency&&(t.viewDependentTransparency=!0)),void 0!==this.linePixels&&(t.linePixels=this.linePixels),!0===this.ignoresMaterial&&(t.ignoresMaterial=!0),!0===this.nonLocatable&&(t.nonLocatable=!0),!0===this.emphasized&&(t.emphasized=!0),void 0!==this.lineTransparency&&(t.lineTransparency=this.lineTransparency),this.lineRgb&&(t.lineRgb=this.lineRgb,this.viewDependentTransparency&&(t.viewDependentTransparency=!0)),t}cloneProps(t){return{...this.toJSON(),...t}}clone(t){return Ao.fromJSON(this.cloneProps(t))}extendAppearance(t){if(!this.overridesSymbology)return t;const e=t.toJSON();return void 0===e.rgb&&(e.rgb=this.rgb),void 0===e.transparency&&(e.transparency=this.transparency),void 0===e.linePixels&&(e.linePixels=this.linePixels),void 0===e.weight&&(e.weight=this.weight),void 0===e.ignoresMaterial&&this.ignoresMaterial&&(e.ignoresMaterial=!0),void 0===e.nonLocatable&&this.nonLocatable&&(e.nonLocatable=!0),void 0===e.emphasized&&this.emphasized&&(e.emphasized=!0),e.lineRgb||(e.lineRgb=this.lineRgb),void 0===e.lineTransparency&&(e.lineTransparency=this.lineTransparency),!this.viewDependentTransparency||void 0===e.transparency&&void 0===e.lineTransparency||(e.viewDependentTransparency=!0),Ao.fromJSON(e)}constructor(t){this.rgb=void 0!==t.rgb?to.fromJSON(t.rgb):void 0,this.lineRgb="object"==typeof t.lineRgb?to.fromJSON(t.lineRgb):!1!==t.lineRgb&&void 0,this.transparency=Po(t.transparency),this.lineTransparency="number"==typeof t.lineTransparency?Po(t.lineTransparency):!1!==t.lineTransparency&&void 0,this.weight=t.weight,this.linePixels=t.linePixels,this.ignoresMaterial=t.ignoresMaterial,this.nonLocatable=t.nonLocatable,this.emphasized=t.emphasized,void 0!==this.weight&&(this.weight=Math.max(1,Math.min(this.weight,32))),!t.viewDependentTransparency||void 0===this.transparency&&void 0===this.getLineTransparency()||(this.viewDependentTransparency=!0)}}Ao.defaults=new Ao({});const Io={elementId:{lower:0,upper:0},animationNodeId:0};class So{ignoreAnimationOverrides(t){this._ignoreAnimationOverrides.push(t)}get defaultOverrides(){return this._defaultOverrides}get lineWeights(){return this._lineWeights}get neverDrawn(){return this._neverDrawn}get alwaysDrawn(){return this._alwaysDrawn}isNeverDrawn(t,e,i){return!!this._neverDrawn.has(t,e)||this.neverDrawnAnimationNodes.has(i)}isAlwaysDrawn(t,e){return this._alwaysDrawn.has(t,e)}isSubCategoryVisible(t,e){return this._visibleSubCategories.has(t,e)}isSubCategoryVisibleInModel(t,e,i,s){if(this.ignoreSubCategory)return!0;let n=this.isSubCategoryVisible(t,e);const r=this._modelSubCategoryOverrides.get(i,s);return void 0!==r&&r.has(t,e)&&(n=!n),n}getModelOverrides(t,e){return this._modelOverrides.get(t,e)}getElementAnimationOverrides(t,e,i){if(0===this.animationNodeOverrides.size)return;const s=this.animationNodeOverrides.get(i);if(!s||0===i||0===this._ignoreAnimationOverrides.length)return s;const n=Io;return n.elementId.lower=t,n.elementId.upper=e,n.animationNodeId=i,this._ignoreAnimationOverrides.some((t=>t(n)))?void 0:s}getElementOverrides(t,e,i){const s=this._elementOverrides.get(t,e),n=this.getElementAnimationOverrides(t,e,i);return s?n?n.extendAppearance(s):s:n}getSubCategoryOverrides(t,e){return this._subCategoryOverrides.get(t,e)}setVisibleSubCategory(t){this._visibleSubCategories.addId(t)}setNeverDrawn(t){this._neverDrawn.addId(t)}setAlwaysDrawn(t){this._alwaysDrawn.addId(t)}setAnimationNodeNeverDrawn(t){this.neverDrawnAnimationNodes.add(t)}setNeverDrawnSet(t){_o(this._neverDrawn,t)}setAlwaysDrawnSet(t,e,i=!0){_o(this._alwaysDrawn,t),this.isAlwaysDrawnExclusive=e,this.alwaysDrawnIgnoresSubCategory=i}getFeatureAppearance(t,e,i=co.Primary,s=0){return this.getAppearance(h.getLowerUint32(t.elementId),h.getUpperUint32(t.elementId),h.getLowerUint32(t.subCategoryId),h.getUpperUint32(t.subCategoryId),t.geometryClass,h.getLowerUint32(e),h.getUpperUint32(e),i,s)}getAppearance(t,e,i,s,n,r,o,a,c){if(co.VolumeClassifier===a||co.PlanarClassifier===a)return this.getClassifierAppearance(t,e,i,s,r,o,c);let l=this._lineWeights?Ao.defaults:So._weight1Appearance;const d=this.getModelOverrides(r,o);void 0!==d&&(l=d.extendAppearance(l));let u,f,g=!1;if(h.isValidUint32Pair(t,e)){if(this.isNeverDrawn(t,e,c))return;if(g=this.isAlwaysDrawn(t,e),!g&&this.isAlwaysDrawnExclusive)return;u=this.getElementOverrides(t,e,c),void 0!==u&&(l=void 0!==d?u.extendAppearance(l):u)}if(!this.ignoreSubCategory&&h.isValidUint32Pair(i,s)){if(!(g&&this.alwaysDrawnIgnoresSubCategory||this.isSubCategoryVisibleInModel(i,s,r,o)))return;f=this.getSubCategoryOverrides(i,s),void 0!==f&&(l=f.extendAppearance(l))}void 0===u&&void 0===d&&void 0===f&&(l=this._defaultOverrides.extendAppearance(l));let p=g||this.isClassVisible(n);return p&&l.isFullyTransparent&&(p=!1),p?l:void 0}getClassifierAppearance(t,e,i,s,n,r,o){let a=Ao.defaults;const c=this.getModelOverrides(n,r);void 0!==c&&(a=c.extendAppearance(a));const l=this.getElementOverrides(t,e,o);if(void 0!==l&&(a=void 0!==c?l.extendAppearance(a):l),!this.ignoreSubCategory&&h.isValidUint32Pair(i,s)){const t=this.getSubCategoryOverrides(i,s);void 0!==t&&(a=t.extendAppearance(a))}return void 0===l&&void 0===c&&(a=this._defaultOverrides.extendAppearance(a)),a}isClassVisible(t){switch(t){case ro.Construction:return this._constructions;case ro.Dimension:return this._dimensions;case ro.Pattern:return this._patterns;default:return!0}}override(t){let i,s;void 0!==t.elementId?(i=t.elementId,s=this._elementOverrides):void 0!==t.modelId?(i=t.modelId,s=this._modelOverrides):(i=t.subCategoryId,s=this._subCategoryOverrides);let n=t.appearance;const r=h.getLowerUint32(i),o=h.getUpperUint32(i);if(void 0!==t.elementId&&this.isNeverDrawn(r,o,0))return;const a="replace"===t.onConflict?void 0:s.get(r,o);if(a)switch(e("replace"!==t.onConflict),t.onConflict){case"skip":return;case"extend":n=n.extendAppearance(a);break;default:n=a.extendAppearance(n)}s.set(r,o,n)}overrideModel(t,e,i=!0){this.override({modelId:t,appearance:e,onConflict:i?"replace":"skip"})}overrideSubCategory(t,e,i=!0){this.override({subCategoryId:t,appearance:e,onConflict:i?"replace":"skip"})}overrideElement(t,e,i=!0){this.override({elementId:t,appearance:e,onConflict:i?"replace":"skip"})}overrideAnimationNode(t,e){this.animationNodeOverrides.set(t,e)}setDefaultOverrides(t,e=!0){!e&&t.overridesSymbology||(this._defaultOverrides=t)}getSubCategoryPriority(t,e){return this._subCategoryPriorities.get(t,e)??0}addInvisibleElementOverridesToNeverDrawn(){this._elementOverrides.forEach(((t,e)=>{const i=this.getElementOverrides(t,e,0);i?.isFullyTransparent&&this._neverDrawn.add(t,e)}))}constructor(){this._ignoreAnimationOverrides=[],this._neverDrawn=new h.Uint32Set,this._alwaysDrawn=new h.Uint32Set,this.isAlwaysDrawnExclusive=!1,this.alwaysDrawnIgnoresSubCategory=!0,this.ignoreSubCategory=!1,this._defaultOverrides=Ao.defaults,this._constructions=!1,this._dimensions=!1,this._patterns=!1,this._lineWeights=!0,this._modelOverrides=new h.Uint32Map,this._elementOverrides=new h.Uint32Map,this._subCategoryOverrides=new h.Uint32Map,this._visibleSubCategories=new h.Uint32Set,this._subCategoryPriorities=new h.Uint32Map,this._modelSubCategoryOverrides=new h.Uint32Map,this.neverDrawnAnimationNodes=new Set,this.animationNodeOverrides=new Map}isSubCategoryIdVisible(t){return this.isSubCategoryVisible(h.getLowerUint32(t),h.getUpperUint32(t))}getModelOverridesById(t){return this.getModelOverrides(h.getLowerUint32(t),h.getUpperUint32(t))}getElementOverridesById(t){return this.getElementOverrides(h.getLowerUint32(t),h.getUpperUint32(t),0)}getSubCategoryOverridesById(t){return this.getSubCategoryOverrides(h.getLowerUint32(t),h.getUpperUint32(t))}isFeatureVisible(t){const{elementId:e,subCategoryId:i,geometryClass:s}=t,n=h.isInvalid(e)?void 0:h.getUint32Pair(e);if(void 0!==n&&this.isNeverDrawn(n.lower,n.upper,0))return!1;const r=void 0!==n&&this.isAlwaysDrawn(n.lower,n.upper);return r||this.isAlwaysDrawnExclusive?r:!!this.isSubCategoryIdVisible(i)&&this.isClassVisible(s)}}var wo;function Co(t,e,i){return t+i*(e-t)}function To(t,e){return i(t.x,e.x)||i(t.y,e.y)||i(t.z,e.z)}So._weight1Appearance=Ao.fromJSON({weight:1}),function(t){t.supplement=function(t){return{getFeatureAppearance:(e,i,s,n,r,o,a,c,l,h)=>{const d=e.getAppearance(i,s,n,r,o,a,c,l,h);return d?t(d):d}}},t.chain=function(t,e){return t===e?t:{getFeatureAppearance:(i,s,n,r,o,a,c,l,h,d)=>e.getFeatureAppearance(function(t,e){return{getAppearance:(i,s,n,r,o,a,c,l,h)=>e.getFeatureAppearance(t,i,s,n,r,o,a,c,l,h)}}(i,t),s,n,r,o,a,c,l,h,d)}}}(wo||(wo={}));const Fo=new $,ko=new $;function Mo(t,e){return i(t.low,e.low)||i(t.high,e.high)}var bo,Eo,Ro,Do,Xo,zo,No,Oo,Yo,Bo,Vo,Lo,Uo,Zo,qo,Wo,Go,Ho,Jo,Qo,Ko,jo,$o,ta,ea,ia;function sa(t,e){e&&t.add(e.buffer)}function na(t,e){if("pattern"!==e.type)switch(sa(t,e.params.vertices.data),"instances"===e.modifier?.type&&(sa(t,e.modifier.transforms),sa(t,e.modifier.featureIds),sa(t,e.modifier.symbologyOverrides)),e.type){case"point":sa(t,e.params.indices);break;case"polyline":sa(t,e.params.polyline.indices),sa(t,e.params.polyline.prevIndices),sa(t,e.params.polyline.nextIndicesAndParams);break;case"mesh":sa(t,e.params.surface.indices);const i=e.params.edges;i&&(sa(t,i.segments?.indices),sa(t,i.segments?.endPointAndQuadIndices),sa(t,i.silhouettes?.indices),sa(t,i.silhouettes?.endPointAndQuadIndices),sa(t,i.silhouettes?.normalPairs),sa(t,i.polylines?.indices),sa(t,i.polylines?.prevIndices),sa(t,i.polylines?.nextIndicesAndParams),sa(t,i.indexed?.indices),sa(t,i.indexed?.edges.data))}else sa(t,e.params.xyOffsets)}function ra(t){const e=new Set,i=t=>{t&&e.add(t.buffer)};i(t.binaryData),i(t.featureTable.data),i(t.featureTable.animationNodeIds);for(const i of t.nodes)if(void 0!==i.groupId)for(const t of i.nodes)for(const i of t.primitives)na(e,i);else for(const t of i.primitives)na(e,t);for(const i of t.patterns.values())for(const t of i)na(e,t);return Array.from(e)}!function(t){let o;!function(t){t[t.Step=1]="Step",t[t.Linear=2]="Linear"}(o=t.Interpolation||(t.Interpolation={}));class a{constructor(t){this.time=t.time,this.interpolation=t.interpolation===o.Linear?t.interpolation:o.Step}toJSON(){const t={time:this.time};return this.interpolation===o.Linear&&(t.interpolation=this.interpolation),t}compareTo(t){return i(this.interpolation,t.interpolation)||i(this.time,t.time)}equals(t){return 0===this.compareTo(t)}}t.TimelineEntry=a;class c extends a{constructor(t){super(t),"number"!=typeof t.value?this.value=100:this.value=Math.max(0,Math.min(100,t.value))}toJSON(){const t=super.toJSON();return 100!==this.value&&(t.value=this.value),t}compareTo(t){return e(t instanceof c),super.compareTo(t)||i(this.value,t.value)}}t.VisibilityEntry=c;class l extends a{constructor(t){super(t),t.value&&(this.value=new to(t.value.red,t.value.green,t.value.blue))}toJSON(){const t=super.toJSON();return this.value&&(t.value={red:this.value.r,green:this.value.g,blue:this.value.b}),t}compareTo(t){return e(t instanceof l),super.compareTo(t)||r(((t,e)=>t.compareTo(e)),this.value,t.value)}}t.ColorEntry=l;class d{constructor(t,e,i){this.position=t,this.pivot=e,this.orientation=i}static fromJSON(t){return t.pivot&&t.position&&t.orientation?new d($.fromJSON(t.position),$.fromJSON(t.pivot),Dt.fromJSON(t.orientation)):void 0}toJSON(){return{position:[this.position.x,this.position.y,this.position.z],pivot:[this.pivot.x,this.pivot.y,this.pivot.z],orientation:[this.orientation.x,this.orientation.y,this.orientation.z,this.orientation.w]}}compareTo(t){return To(this.pivot,t.pivot)||To(this.position,t.position)||(e=this.orientation,s=t.orientation,i(e.x,s.x)||i(e.y,s.y)||i(e.z,s.z)||i(e.w,s.w));var e,s}equals(t){return this.pivot.isAlmostEqual(t.pivot)&&this.position.isAlmostEqual(t.position)&&this.orientation.isAlmostEqual(t.orientation)}}t.TransformComponents=d;class g extends a{constructor(t){super(t),this.value=t.value?pt.fromJSON(t.value.transform):pt.identity,t.value&&(this.components=d.fromJSON(t.value))}toJSON(){const t=super.toJSON();return this.components?(t.value=this.components.toJSON(),t.value.transform=this.value.toRows()):t.value={transform:this.value.toRows()},t}compareTo(t){e(t instanceof g);const i=super.compareTo(t);return 0!==i?i:this.components||t.components?this.components&&t.components?this.components.compareTo(t.components):this.components?1:-1:To(this.value.origin,t.value.origin)||(s=this.value.matrix,n=t.value.matrix,To(s.columnX(Fo),n.columnX(ko))||To(s.columnY(Fo),n.columnY(ko))||To(s.columnZ(Fo),n.columnZ(ko)));var s,n}}t.TransformEntry=g;class p{constructor(t){this.position=j.fromJSON(t.position),this.direction=j.fromJSON(t.direction),this.hidden=!0===t.hidden,this.visible=!0===t.visible}toJSON(){const t={position:[this.position.x,this.position.y,this.position.z],direction:[this.direction.x,this.direction.y,this.direction.z]};return this.visible&&(t.visible=!0),this.hidden&&(t.hidden=!0),t}compareTo(t){return To(this.position,t.position)||To(this.direction,t.direction)||s(this.visible,t.visible)||s(this.hidden,t.hidden)}equals(t){return 0===this.compareTo(t)}}t.CuttingPlane=p;class m extends a{constructor(t){super(t),t.value&&(this.value=new p(t.value))}toJSON(){const t=super.toJSON();return this.value&&(t.value=this.value.toJSON()),t}compareTo(t){return e(t instanceof m),super.compareTo(t)||r(((t,e)=>t.compareTo(e)),this.value,t.value)}}t.CuttingPlaneEntry=m;class x{constructor(t=0,e=0,i=0){this.init(t,e,i)}init(t=0,e=0,i=0){this.lowerIndex=t,this.upperIndex=e,this.fraction=i}}t.Interval=x;class _{constructor(t,e){this.duration=ft.createNull(),this._entries=t.map((t=>{const i=new e(t);return this.duration.extendX(i.time),i}))}get length(){return this._entries.length}[Symbol.iterator](){return this._entries[Symbol.iterator]()}getEntry(t){return this._entries[t]}getValue(t){return this.getEntry(t)?.value}toJSON(){return this._entries.map((t=>t.toJSON()))}compareTo(t){let e=i(this._entries.length,t._entries.length)||Mo(this.duration,t.duration);if(0===e)for(let i=0;i<this.length&&0===(e=this._entries[i].compareTo(t._entries[i]));i++);return e}equals(t){return 0===this.compareTo(t)}findInterval(t,e){if(0===this.length)return;if(e=e??new x,t<this._entries[0].time)return e.init(0,0,0),e;const i=this.length-1;if(t>=this._entries[i].time)return e.init(i,i,0),e;for(let s=0;s<i;s++){const i=this._entries[s].time,n=this._entries[s+1].time;if(i<=t&&n>=t){let r;return r=o.Linear===this._entries[s].interpolation?(t-i)/(n-i):0,e.init(s,s+1,r),e}}}}t.TimelineEntryList=_;const y=new x;class v extends _{getValue(t){return super.getValue(t)??100}}t.VisibilityTimelineEntries=v;class P extends _{getValue(t){return super.getValue(t)??pt.identity}}t.TransformTimelineEntries=P;class A{constructor(t){this.duration=ft.createNull(),t.visibilityTimeline&&(this.visibility=new v(t.visibilityTimeline,c),this.duration.extendRange(this.visibility.duration)),t.colorTimeline&&(this.color=new _(t.colorTimeline,l),this.duration.extendRange(this.color.duration)),t.transformTimeline&&(this.transform=new P(t.transformTimeline,g),this.duration.extendRange(this.transform.duration)),t.cuttingPlaneTimeline&&(this.cuttingPlane=new _(t.cuttingPlaneTimeline,m),this.duration.extendRange(this.cuttingPlane.duration))}toJSON(){return{visibilityTimeline:this.visibility?.toJSON(),colorTimeline:this.color?.toJSON(),transformTimeline:this.transform?.toJSON(),cuttingPlaneTimeline:this.cuttingPlane?.toJSON()}}compareTo(t){const e=Mo(this.duration,t.duration);return 0!==e?e:!!this.visibility!=!!t.visibility?this.visibility?1:-1:!!this.color!=!!t.color?this.color?1:-1:!!this.transform!=!!t.transform?this.transform?1:-1:!!this.cuttingPlane!=!!t.cuttingPlane?this.cuttingPlane?1:-1:r(((t,e)=>t.compareTo(e)),this.visibility,t.visibility)||r(((t,e)=>t.compareTo(e)),this.color,t.color)||r(((t,e)=>t.compareTo(e)),this.transform,t.transform)||r(((t,e)=>t.compareTo(e)),this.cuttingPlane,t.cuttingPlane)}equals(t){return 0===this.compareTo(t)}getVisibility(t){let e;if(!this.visibility||!(e=this.visibility.findInterval(t,y)))return 100;let i=this.visibility.getValue(e.lowerIndex)??100;return e.fraction>0&&(i=Co(i,this.visibility.getValue(e.upperIndex)??100,e.fraction)),i}getColor(t){let e;if(!this.color||!(e=this.color.findInterval(t,y)))return;const i=this.color.getValue(e.lowerIndex);if(i&&e.fraction>0){const t=this.color.getValue(e.upperIndex);if(t)return function(t,e,i){return new to(Co(t.r,e.r,i),Co(t.g,e.g,i),Co(t.b,e.b,i))}(i,t,e.fraction)}return i}getAnimationTransform(t){let e;if(!this.transform||!(e=this.transform.findInterval(t,y)))return pt.identity;let i=this.transform.getValue(e.lowerIndex);if(e.fraction>0){const t=this.transform.getEntry(e.lowerIndex)?.components,s=this.transform.getEntry(e.upperIndex)?.components;if(t&&s){const n=Dt.interpolateQuaternions(t.orientation,e.fraction,s.orientation),r=xt.createFromQuaternion(n),o=pt.createTranslation(t.pivot),a=pt.createTranslation(t.position.interpolate(e.fraction,s.position)).multiplyTransformMatrix3d(r);a.multiplyTransformTransform(o,a),i=a}else{const t=this.transform.getValue(e.upperIndex),s=i.matrix.inverse()?.toQuaternion(),n=t.matrix.inverse()?.toQuaternion();if(s&&n){const r=Dt.interpolateQuaternions(s,e.fraction,n),o=xt.createFromQuaternion(r),a=$.createFrom(i.origin),c=$.createFrom(t.origin);i=pt.createRefs(a.interpolate(e.fraction,c),o)}}}return i}getCuttingPlane(t){let e;if(!this.cuttingPlane||!(e=this.cuttingPlane.findInterval(t,y)))return;const i=this.cuttingPlane.getValue(e.lowerIndex);if(!i)return;const s=j.createFrom(i.position),n=$.createFrom(i.direction),r=e.fraction>0?this.cuttingPlane.getValue(e.upperIndex):void 0;if(r)s.interpolate(e.fraction,r.position,s),n.interpolate(e.fraction,r.direction,n);else if(i.hidden||i.visible)return;return n.negate(n),n.normalizeInPlace(),_t.create(s,n)}getClipVector(t){const e=this.getCuttingPlane(t);if(!e)return;const i=Wr.createPlane(e),s=vs.createConvexSets([kn.createPlanes([i])]),n=Cs.createCapture(s);return bs.createCapture([n])}getFeatureAppearance(t,e){const i=t<100?1-t/100:void 0,s=this.getColor(e);return void 0!==s||void 0!==i?Ao.fromJSON({rgb:s,transparency:i}):void 0}}t.Timeline=A;class I extends A{constructor(t){super(t),this.batchId=t.batchId,this._elementIds=t.elementIds}static fromJSON(t){return new I(t??{elementIds:[],batchId:0})}toJSON(){return{...super.toJSON(),batchId:this.batchId,elementIds:this._elementIds}}get containsElementIds(){return this._elementIds.length>0}compareElementIds(t){if(typeof this._elementIds==typeof t._elementIds){const s=i(this._elementIds.length,t._elementIds.length);if(0!==s)return s;if("string"==typeof this._elementIds)return e("string"==typeof t._elementIds),n(this._elementIds,t._elementIds)}const r=this.elementIds[Symbol.iterator](),o=t.elementIds[Symbol.iterator]();for(;;){const t=r.next(),e=o.next();if(t.done!==e.done)return s(!!t.done,!!e.done);if(t.done)return 0;const i=n(t.value,e.value);if(0!==i)return i}}compareTo(t){return e(t instanceof I),i(this.batchId,t.batchId)||this.compareElementIds(t)||super.compareTo(t)}static getElementIds(t){return"string"==typeof t?f.iterable(t):Array.isArray(t)?t:[]}get elementIds(){return I.getElementIds(this._elementIds)}get containsFeatureOverrides(){return void 0!==this.visibility||void 0!==this.color}get requiresBatching(){return!!this.cuttingPlane||0!==this.batchId&&(void 0!==this.color||void 0!==this.visibility)}get containsTransform(){return void 0!==this.transform}addSymbologyOverrides(t,i){e(0!==this.batchId);const s=this.getVisibility(i);if(s<=0)return void t.setAnimationNodeNeverDrawn(this.batchId);const n=this.getFeatureAppearance(s,i);n&&t.overrideAnimationNode(this.batchId,n)}}t.ElementTimeline=I;class S extends A{constructor(t){super(t),this._cachedComparisons=new WeakMap,this.modelId=t.modelId,this.realityModelUrl=t.realityModelUrl,this.containsModelClipping=void 0!==this.cuttingPlane;let e=void 0!==this.visibility||void 0!==this.color,i=!1,s=!1;const n=[],r=[];let o=!1;for(const a of t.elementTimelines){const t=I.fromJSON(a);r.push(t),this.duration.extendRange(t.duration),t.containsTransform&&(s=!0,t.batchId&&n.push(t.batchId)),e||=t.containsFeatureOverrides,i||=t.requiresBatching,o=o||t.containsElementIds}this.elementTimelines=r,this.transformBatchIds=n,this.omitsElementIds=r.length>0&&!o,this.containsFeatureOverrides=e,this.requiresBatching=i,this.containsTransform=s}static fromJSON(t){return new S(t??{elementTimelines:[],modelId:h.invalid})}toJSON(){return{...super.toJSON(),modelId:this.modelId,realityModelUrl:this.realityModelUrl,elementTimelines:this.elementTimelines.map((t=>t.toJSON()))}}compareTo(t){if(this===t)return 0;const o=this._cachedComparisons.get(t);if(void 0!==o)return o;e(t instanceof S);let a=n(this.modelId,t.modelId)||r(n,this.realityModelUrl,t.realityModelUrl)||i(this.elementTimelines.length,t.elementTimelines.length)||s(this.containsFeatureOverrides,t.containsFeatureOverrides)||s(this.containsModelClipping,t.containsModelClipping)||s(this.containsTransform,t.containsTransform)||super.compareTo(t);if(0===a)for(let e=0;e<this.elementTimelines.length&&0===(a=this.elementTimelines[e].compareTo(t.elementTimelines[e]));e++);return this._cachedComparisons.set(t,a),t._cachedComparisons.set(this,-a),a}findByBatchId(t){return this.elementTimelines.find((e=>e.batchId===t))}addSymbologyOverrides(t,e){const i=this.getFeatureAppearance(this.getVisibility(e),e);i&&t.override({modelId:this.modelId,appearance:i});for(const i of this.elementTimelines)i.addSymbologyOverrides(t,e)}getTransform(t,e){return this.findByBatchId(t)?.getAnimationTransform(e)}get maxBatchId(){if(void 0===this._maxBatchId){this._maxBatchId=0;for(const t of this.elementTimelines)this._maxBatchId=Math.max(this._maxBatchId,t.batchId)}return this._maxBatchId}getTimelineForElement(t,e){if(!this._idPairToElementTimeline){this._idPairToElementTimeline=new h.Uint32Map;for(const t of this.elementTimelines)for(const e of t.elementIds)this._idPairToElementTimeline.setById(e,t)}return this._idPairToElementTimeline.get(t,e)}get discreteBatchIds(){if(!this._discreteBatchIds){this._discreteBatchIds=new Set(this.transformBatchIds);for(const t of this.elementTimelines)t.containsTransform||void 0===t.cuttingPlane||this._discreteBatchIds.add(t.batchId)}return this._discreteBatchIds}getBatchIdForFeature(t){e(h.fromUint32PairObject(t.modelId)===this.modelId);const i=this.getTimelineForElement(t.elementId.lower,t.elementId.upper);return i?.batchId??0}}t.ModelTimeline=S;class w{compareTo(t){if(this===t)return 0;const e=this._cachedComparisons.get(t);if(void 0!==e)return e;let n=i(this.modelTimelines.length,t.modelTimelines.length)||s(this.containsModelClipping,t.containsModelClipping)||s(this.requiresBatching,t.requiresBatching)||s(this.containsTransform,t.containsTransform)||s(this.containsFeatureOverrides,t.containsFeatureOverrides)||Mo(this.duration,t.duration);if(0===n)for(let e=0;e<this.modelTimelines.length&&0===(n=this.modelTimelines[e].compareTo(t.modelTimelines[e]));e++);return this._cachedComparisons.set(t,n),t._cachedComparisons.set(this,-n),n}equals(t){return 0===this.compareTo(t)}constructor(t){this._cachedComparisons=new WeakMap,this.duration=ft.createNull();const e=new Set,i=[];let s=!1,n=!1,r=!1,o=!1;for(const a of t){const t=S.fromJSON(a);i.push(t),this.duration.extendRange(t.duration),s||=t.containsModelClipping,n||=t.requiresBatching,r||=t.containsTransform,o||=t.containsFeatureOverrides;for(const i of t.transformBatchIds)e.add(i)}this.modelTimelines=i,this.containsModelClipping=s,this.containsTransform=r,this.requiresBatching=n||this.containsTransform,this.containsFeatureOverrides=o,this.transformBatchIds=e}static fromJSON(t){if(Array.isArray(t)&&0!==t.length)return new w(t)}toJSON(){return this.modelTimelines.map((t=>t.toJSON()))}find(t){return this.modelTimelines.find((e=>e.modelId===t))}getTransformBatchIds(t){return this.find(t)?.transformBatchIds}getTransform(t,e,i){return this.find(t)?.getTransform(e,i)}addSymbologyOverrides(t,e){for(const i of this.modelTimelines)i.addSymbologyOverrides(t,e)}discloseIds(t){for(const e of this.modelTimelines){t.addModel(e.modelId);for(const i of e.elementTimelines)for(const e of i.elementIds)t.addElement(e)}}modelRequiresBatching(t){return this.requiresBatching&&this.modelTimelines.some((e=>e.modelId===t&&e.requiresBatching))}get discreteBatchIds(){if(this._discreteBatchIds)return this._discreteBatchIds;this._discreteBatchIds=new Set;for(const t of this.modelTimelines)for(const e of t.discreteBatchIds)this._discreteBatchIds.add(e);return this._discreteBatchIds}getBatchIdForFeature(t){let e;const i=this._lastFeatureModelTimeline;if(i&&i.idLower===t.modelId.lower&&i.idUpper===t.modelId.upper)e=i.timeline;else{const i=h.fromUint32PairObject(t.modelId);e=this.find(i),this._lastFeatureModelTimeline={timeline:e,idLower:t.modelId.lower,idUpper:t.modelId.upper}}return e?.getBatchIdForFeature(t)??0}get maxBatchId(){return this._maxBatchId??(this._maxBatchId=this.modelTimelines.reduce(((t,e)=>Math.max(t,e.maxBatchId)),0))}}t.Script=w,t.ScriptReference=class{constructor(t,i){"string"==typeof t?(e(i instanceof w),this.sourceId=t,this.script=i):(e(void 0===i),this.script=t,this.sourceId=h.invalid)}};class C{addVisibility(t,e,i=o.Linear){this.visibility||(this.visibility=[]),this.visibility.push({time:t,value:e,interpolation:i})}addColor(t,e,i=o.Linear){this.color||(this.color=[]);const s=e instanceof to?{red:e.r,green:e.g,blue:e.b}:e;this.color.push({time:t,value:s,interpolation:i})}addCuttingPlane(t,e,i=o.Linear){let s;this.cuttingPlane||(this.cuttingPlane=[]),e&&(s={position:[e.position.x,e.position.y,e.position.z],direction:[e.direction.x,e.direction.y,e.direction.z]},e.visible&&(s.visible=!0),e.hidden&&(s.hidden=!0)),this.cuttingPlane.push({time:t,value:s,interpolation:i})}addTransform(t,e,i,s=o.Linear){this.transform||(this.transform=[]);const n={transform:e?.toRows()};i&&(n.pivot=[i.pivot.x,i.pivot.y,i.pivot.z],n.orientation=i.orientation.toJSON(),n.position=[i.position.x,i.position.y,i.position.z]),this.transform.push({time:t,value:n,interpolation:s})}finish(){const t={};return this.visibility?.length&&(t.visibilityTimeline=this.visibility),this.color?.length&&(t.colorTimeline=this.color),this.transform?.length&&(t.transformTimeline=this.transform),this.cuttingPlane?.length&&(t.cuttingPlaneTimeline=this.cuttingPlane),t}}t.TimelineBuilder=C;class T extends C{constructor(t,e){super(),this.batchId=t,this.elementIds=e}finish(){const t=super.finish();return t.batchId=this.batchId,t.elementIds=this.elementIds,t}}t.ElementTimelineBuilder=T;class F extends C{constructor(t,e){super(),this._elements=[],this.modelId=t,this._obtainNextBatchId=e}addElementTimeline(t){const e=this._obtainNextBatchId();let i;if("string"==typeof t&&h.isValidId64(t)&&(t=[t]),"string"==typeof t)i=t;else{const e=Array.from(t);u.sortArray(e),i=f.compressIds(e)}const s=new T(e,i);return this._elements.push(s),s}finish(){const t=super.finish();return t.modelId=this.modelId,void 0!==this.realityModelUrl&&(t.realityModelUrl=this.realityModelUrl),t.elementTimelines=this._elements.map((t=>t.finish())),t}}t.ModelTimelineBuilder=F,t.ScriptBuilder=class{constructor(){this._nextBatchId=1,this._models=[]}addModelTimeline(t){const e=new F(t,(()=>this._nextBatchId++));return this._models.push(e),e}finish(){return this._models.map((t=>t.finish()))}}}(bo||(bo={})),function(t){function e(t){return"object"==typeof t&&0===Object.keys(t).length}function i(t){return void 0===t||e(t)}function s(t){return null==t}t.asBool=function(t,e=!1){return s(t)?e:!!t},t.asInt=function(t,e=0){return"number"==typeof t?Math.trunc(t):e},t.asDouble=function(t,e=0){return"number"==typeof t?t:e},t.asString=function(t,e=""){return s(t)?e:t.toString()},t.asArray=function(t){return Array.isArray(t)?t:void 0},t.asObject=function(t){return"object"==typeof t?t:void 0},t.setOrRemoveNumber=function(t,e,i,s){i===s?delete t[e]:t[e]=i},t.setOrRemoveBoolean=function(t,e,i,s){i===s?delete t[e]:t[e]=i},t.isEmptyObject=e,t.isEmptyObjectOrUndefined=i,t.isNonEmptyObject=function(t){return!i(t)},t.toObject=function t(e){if("boolean"==typeof e||"number"==typeof e||"string"==typeof e)return e;if("object"!=typeof e)return;if(void 0!==e.toJSON)return t(e.toJSON());if(Array.isArray(e)){const i=new Array(e.length);return e.forEach(((e,s)=>i[s]=t(e))),i}const i={};return Object.getOwnPropertyNames(e).forEach((s=>{const n=t(e[s]);void 0!==n&&(i[s]=n)})),i}}(Eo||(Eo={}));class oa{constructor(t,e){this._curPos=0,void 0!==e?(this._view=new DataView(t,e.byteOffset,e.byteLength),this._byteOffset=e.byteOffset):(this._view=new DataView(t),this._byteOffset=0)}static fromUint8Array(t){const{byteOffset:e,byteLength:i}=t;return new oa(t.buffer,{byteOffset:e,byteLength:i})}static fromArrayBuffer(t,e){return new oa(t,e)}get length(){return this._view.byteLength}get remainingLength(){return this.length-this.curPos}get isPastTheEnd(){return this.curPos>this.length}get isAtTheEnd(){return this.curPos===this.length}get curPos(){return this._curPos}set curPos(t){this._curPos=t,e(!this.isPastTheEnd)}advance(t){return this.curPos=this.curPos+t,!this.isPastTheEnd}rewind(t){return!(this.curPos-t<0||(this.curPos=this.curPos-t,0))}reset(){this.curPos=0}readUint8(){return this.read(1,(t=>t.getUint8(this.curPos)))}readUint16(){return this.read(2,(t=>t.getUint16(this.curPos,!0)))}readUint32(){return this.read(4,(t=>t.getUint32(this.curPos,!0)))}readInt32(){return this.read(4,(t=>t.getInt32(this.curPos,!0)))}readFloat32(){return this.read(4,(t=>t.getFloat32(this.curPos,!0)))}readFloat64(){return this.read(8,(t=>t.getFloat64(this.curPos,!0)))}readId64(){return h.fromUint32Pair(this.readUint32(),this.readUint32())}readUint24(){return this.readUint8()|this.readUint8()<<8|this.readUint8()<<16}get nextUint8(){return this.readUint8()}get nextUint16(){return this.readUint16()}get nextUint32(){return this.readUint32()}get nextInt32(){return this.readInt32()}get nextFloat32(){return this.readFloat32()}get nextFloat64(){return this.readFloat64()}get nextId64(){return this.readId64()}get nextUint24(){return this.readUint24()}nextBytes(t){const e=new Uint8Array(this.arrayBuffer,this.curPos+this._byteOffset,t);return this.advance(t),e}readBytes(t,e){return new Uint8Array(this.arrayBuffer,t+this._byteOffset,e)}nextUint32s(t){const e=4*t,i=new Uint32Array(this.arrayBuffer,this.curPos+this._byteOffset,t);return this.advance(e),i}get arrayBuffer(){return this._view.buffer}read(t,e){const i=e(this._view);return this.advance(t),i}}(Xo=Ro||(Ro={}))[Xo.Unknown=0]="Unknown",Xo[Xo.B3dm=1835283298]="B3dm",Xo[Xo.Gltf=1179937895]="Gltf",Xo[Xo.Pnts=1937010288]="Pnts",Xo[Xo.IModel=1818512745]="IModel",Xo[Xo.Cmpt=1953525091]="Cmpt",Xo[Xo.I3dm=1835283305]="I3dm",Xo[Xo.A3x=5780289]="A3x",function(t){t[t.Success=0]="Success",t[t.InvalidTileData=1]="InvalidTileData",t[t.InvalidHeader=2]="InvalidHeader",t[t.InvalidBatchTable=3]="InvalidBatchTable",t[t.InvalidScene=4]="InvalidScene",t[t.InvalidFeatureTable=5]="InvalidFeatureTable",t[t.NewerMajorVersion=6]="NewerMajorVersion",t[t.Canceled=7]="Canceled"}(Do||(Do={}));class aa{constructor(t){this._format=function(t){const e=t;return function(t){switch(t){case Ro.Unknown:case Ro.B3dm:case Ro.Gltf:case Ro.IModel:case Ro.Pnts:case Ro.Cmpt:case Ro.I3dm:case Ro.A3x:return!0;default:return!1}}(e)?e:Ro.Unknown}(t.readUint32()),this.version=t.readUint32()}get format(){return this._format}invalidate(){this._format=Ro.Unknown}}function ca(t,e){const i=t.readFloat64(),s=t.readFloat64(),n=t.readFloat64();return void 0===e?new j(i,s,n):(e.set(i,s,n),e)}!function(t){t[t.Version1=1]="Version1",t[t.Version2=2]="Version2",t[t.CurrentVersion=1]="CurrentVersion",t[t.Gltf1SceneFormat=0]="Gltf1SceneFormat"}(zo||(zo={})),function(t){t[t.JSON=1313821514]="JSON",t[t.Binary=5130562]="Binary"}(No||(No={}));class la{get isTileSection(){return la.Type.TileSection===this.type}get isGlyph(){return la.Type.Glyph===this.type}get isSkyBox(){return la.Type.SkyBox===this.type}constructor(t){this.type=t,this._guid=d.createValue()}compare(t){return n(this._guid,t._guid)}}!function(t){let e;!function(t){t[t.Normal=0]="Normal",t[t.Glyph=1]="Glyph",t[t.TileSection=2]="TileSection",t[t.SkyBox=3]="SkyBox",t[t.FilteredTileSection=4]="FilteredTileSection",t[t.ThematicGradient=5]="ThematicGradient"}(e=t.Type||(t.Type={})),t.Params=class{constructor(e,i=t.Type.Normal,s=!1){this.key=e,this.type=i,this.isOwned=s}get isTileSection(){return t.Type.TileSection===this.type}get isGlyph(){return t.Type.Glyph===this.type}get isSkyBox(){return t.Type.SkyBox===this.type}}}(la||(la={}));class ha{constructor(t){this.key=t.key,this.textureMapping=t.textureMapping,this._guid=d.createValue()}get hasTexture(){return void 0!==this.textureMapping?.texture}compare(t){return n(this._guid,t._guid)}}!function(t){class e{constructor(t){this.diffuse=.6,this.specular=.4,this.specularExponent=13.5,this.reflect=0,this.refract=1,this.ambient=.3,this.shadows=!0,this.key=t}get alpha(){return this._alpha}set alpha(t){var e;this._alpha=void 0!==t?(e=t,Math.max(0,Math.min(1,e))):void 0}static fromColors(t,i,s,n,r,o){const a=new e;return a.key=t,a.diffuseColor=i,a.specularColor=s,a.emissiveColor=n,a.reflectColor=r,a.textureMapping=o,a}}e.defaults=new e,t.Params=e}(ha||(ha={})),Object.freeze(ha.Params.defaults),function(t){function e(e,i=t.rangeScale16){return e>=0&&e<i+1}function i(e,i,s,n=t.rangeScale16){return Math.floor(Math.max(0,Math.min(n,.5+(e-i)*s)))}t.rangeScale16=65535,t.rangeScale8=255,t.computeScale=function(e,i=t.rangeScale16){return 0===e?e:i/e},t.isInRange=e,t.quantize=i,t.isQuantizable=function(s,n,r,o=t.rangeScale16){return e(i(s,n,r,o))},t.unquantize=function(t,e,i){return 0===i?e:e+t/i},t.isQuantized=function(t){return e(t)&&t===Math.floor(t)}}(Oo||(Oo={}));class da{constructor(t=0,e=0,i=0,s=0){this.origin=new H,this.scale=new H,this.setFrom(t,e,i,s)}setFrom(t,e,i,s){this.origin.x=t,this.origin.y=e,this.scale.x=i,this.scale.y=s}copyFrom(t){this.setFrom(t.origin.x,t.origin.y,t.scale.x,t.scale.y)}clone(t){const e=void 0!==t?t:new da;return e.copyFrom(this),e}setFromRange(t,e=Oo.rangeScale16){t.isNull?this.origin.x=this.origin.y=this.scale.x=this.scale.y=0:this.setFrom(t.low.x,t.low.y,Oo.computeScale(t.high.x-t.low.x,e),Oo.computeScale(t.high.y-t.low.y,e))}static fromRange(t,e,i=Oo.rangeScale16){const s=void 0!==e?e:new da;return s.setFromRange(t,i),s}unquantize(t,e,i){return(i=i??new H).x=Oo.unquantize(t,this.origin.x,this.scale.x),i.y=Oo.unquantize(e,this.origin.y,this.scale.y),i}static fromNormalizedRange(t=Oo.rangeScale16){return da.fromRange(gt.createArray([H.create(-1,-1),H.create(1,1)]),void 0,t)}static fromZeroToOne(t=Oo.rangeScale16){return da.fromRange(gt.createArray([H.create(0,0),H.create(1,1)]),void 0,t)}static fromOriginAndScale(t,e,i,s){return new da(t,e,i,s)}get rangeDiagonal(){return J.createFrom({x:0===this.scale.x?0:Oo.rangeScale16/this.scale.x,y:0===this.scale.y?0:Oo.rangeScale16/this.scale.y})}isQuantizable(t){return Oo.isQuantizable(t.x,this.origin.x,this.scale.x)&&Oo.isQuantizable(t.y,this.origin.y,this.scale.y)}toJSON(){return{origin:{x:this.origin.x,y:this.origin.y},scale:{x:this.scale.x,y:this.scale.y}}}static fromJSON(t){return this.fromOriginAndScale(t.origin.x,t.origin.y,t.scale.x,t.scale.y)}}class ua{get x(){return this._x}set x(t){e(Oo.isQuantized(t)),this._x=t}get y(){return this._y}set y(t){e(Oo.isQuantized(t)),this._y=t}constructor(){this._x=0,this._y=0}init(t,e){this.x=Oo.quantize(t.x,e.origin.x,e.scale.x),this.y=Oo.quantize(t.y,e.origin.y,e.scale.y)}static create(t,e){const i=new ua;return i.init(t,e),i}copyFrom(t){this.x=t.x,this.y=t.y}clone(t){const e=void 0!==t?t:new ua;return e.copyFrom(this),e}setFromScalars(t,e){this.x=t,this.y=e}static fromScalars(t,e){const i=new ua;return i.setFromScalars(t,e),i}unquantize(t,e){const i=void 0!==e?e:new H;return i.x=Oo.unquantize(this.x,t.origin.x,t.scale.x),i.y=Oo.unquantize(this.y,t.origin.y,t.scale.y),i}}!function(t){const e=new ua;function i(t,e,i){const s=2*e,n=t[s+0],r=t[s+1];if(void 0===n||void 0===r)throw new Error("Index out of range");return(i=i??new ua).setFromScalars(n,r),i}t.getQPoint=i,t.unquantizePoint=function(t,s,n){return i(t.points,s,e).unquantize(t.params,n)}}(Yo||(Yo={}));class fa{constructor(t=0,e=0,i=0,s=0,n=0,r=0){this.origin=new j,this.scale=new j,this.setFrom(t,e,i,s,n,r)}setFrom(t,e,i,s,n,r){this.origin.x=t,this.origin.y=e,this.origin.z=i,this.scale.x=s,this.scale.y=n,this.scale.z=r}copyFrom(t){this.setFrom(t.origin.x,t.origin.y,t.origin.z,t.scale.x,t.scale.y,t.scale.z)}clone(t){const e=void 0!==t?t:new fa;return e.copyFrom(this),e}setFromOriginAndScale(t,e){this.setFrom(t.x,t.y,t.z,e.x,e.y,e.z)}setFromRange(t,e=Oo.rangeScale16){t.isNull?(this.origin.x=this.origin.y=this.origin.z=0,this.scale.x=this.scale.y=this.scale.z=0):this.setFrom(t.low.x,t.low.y,t.low.z,Oo.computeScale(t.high.x-t.low.x,e),Oo.computeScale(t.high.y-t.low.y,e),Oo.computeScale(t.high.z-t.low.z,e))}unquantize(t,e,i,s){const n=void 0!==s?s:new j;return n.x=Oo.unquantize(t,this.origin.x,this.scale.x),n.y=Oo.unquantize(e,this.origin.y,this.scale.y),n.z=Oo.unquantize(i,this.origin.z,this.scale.z),n}static fromRange(t,e,i=Oo.rangeScale16){const s=void 0!==e?e:new fa;return s.setFromRange(t,i),s}static fromOriginAndScale(t,e,i){const s=void 0!==i?i:new fa;return s.setFromOriginAndScale(t,e),s}static fromNormalizedRange(t=Oo.rangeScale16){return fa.fromRange(ut.createArray([j.create(-1,-1,-1),j.create(1,1,1)]),void 0,t)}static fromZeroToOne(t=Oo.rangeScale16){return fa.fromRange(ut.createArray([j.create(0,0,0),j.create(1,1,1)]),void 0,t)}get rangeDiagonal(){return $.createFrom({x:0===this.scale.x?0:Oo.rangeScale16/this.scale.x,y:0===this.scale.y?0:Oo.rangeScale16/this.scale.y,z:0===this.scale.z?0:Oo.rangeScale16/this.scale.z})}isQuantizable(t){return Oo.isQuantizable(t.x,this.origin.x,this.scale.x)&&Oo.isQuantizable(t.y,this.origin.y,this.scale.y)&&Oo.isQuantizable(t.z,this.origin.z,this.scale.z)}computeRange(t){const e=ut.createNull(t);return e.extendPoint(this.origin),e.extendPoint(this.origin.plus(this.rangeDiagonal)),e}toJSON(){return{origin:{x:this.origin.x,y:this.origin.y,z:this.origin.z},scale:{x:this.scale.x,y:this.scale.y,z:this.scale.z}}}static fromJSON(t,e){return this.fromOriginAndScale(j.fromJSON(t.origin),j.fromJSON(t.scale),e)}}class ga{get x(){return this._x}set x(t){e(Oo.isQuantized(t)),this._x=t}get y(){return this._y}set y(t){e(Oo.isQuantized(t)),this._y=t}get z(){return this._z}set z(t){e(Oo.isQuantized(t)),this._z=t}constructor(){this._x=0,this._y=0,this._z=0}init(t,e){this.x=Oo.quantize(t.x,e.origin.x,e.scale.x),this.y=Oo.quantize(t.y,e.origin.y,e.scale.y),this.z=Oo.quantize(t.z,e.origin.z,e.scale.z)}static create(t,e){const i=new ga;return i.init(t,e),i}copyFrom(t){this.x=t.x,this.y=t.y,this.z=t.z}clone(t){const e=void 0!==t?t:new ga;return e.copyFrom(this),e}setFromScalars(t,e,i){this.x=t,this.y=e,this.z=i}static fromScalars(t,e,i,s){const n=void 0===s?new ga:s;return n.setFromScalars(t,e,i),n}unquantize(t,e){const i=void 0!==e?e:new j;return i.x=Oo.unquantize(this.x,t.origin.x,t.scale.x),i.y=Oo.unquantize(this.y,t.origin.y,t.scale.y),i.z=Oo.unquantize(this.z,t.origin.z,t.scale.z),i}equals(t){return this.x===t.x&&this.y===t.y&&this.z===t.z}compare(t){let e=this.x-t.x;return 0===e&&(e=this.y-t.y,0===e&&(e=this.z-t.z)),e}}!function(t){const e=new ga;function i(t,e,i){const s=3*e,n=t[s+0],r=t[s+1],o=t[s+2];if(void 0===n||void 0===r||void 0===o)throw new Error("Index out of range");return(i=i??new ga).setFromScalars(n,r,o),i}t.getQPoint=i,t.unquantizePoint=function(t,s,n){return i(t.points,s,e).unquantize(t.params,n)}}(Bo||(Bo={})),Symbol.iterator,function(t){t[t.None=0]="None",t[t.ContainsCurves=1]="ContainsCurves",t[t.Incomplete=4]="Incomplete",t[t.DisallowMagnification=8]="DisallowMagnification",t[t.MultiModelFeatureTable=16]="MultiModelFeatureTable"}(Vo||(Vo={})),function(t){t[t.Major=35]="Major",t[t.Minor=0]="Minor",t[t.Combined=2293760]="Combined"}(Lo||(Lo={}));class pa extends aa{get versionMajor(){return this.version>>>16}get versionMinor(){return(65535&this.version)>>>0}get isValid(){return Ro.IModel===this.format}get isReadableVersion(){return this.versionMajor<=Lo.Major}constructor(t){super(t),this.headerLength=t.readUint32(),this.flags=t.readUint32(),this.contentRange=new ut,ca(t,this.contentRange.low),ca(t,this.contentRange.high),this.tolerance=t.readFloat64(),this.numElementsIncluded=t.readUint32(),this.numElementsExcluded=t.readUint32(),this.tileLength=t.readUint32(),this.emptySubRanges=this.versionMajor>=2?t.readUint32():0;const i=this.headerLength-t.curPos;e(i>=0),t.advance(i),t.isPastTheEnd&&this.invalidate()}}class ma{static readFrom(t){const e=t.readUint32(),i=t.readUint32(),s=t.readUint32();return t.isPastTheEnd?void 0:new ma(e,i,s)}constructor(t,e,i){this.length=t,this.numSubCategories=e,this.count=i}}ma.sizeInBytes=12,function(t){t[t.Normal=0]="Normal",t[t.Edge=1]="Edge",t[t.Outline=2]="Outline"}(Uo||(Uo={}));class xa{constructor(t,e){this.texture=t,this.params=e}computeUVParams(t,e){return this.params.computeUVParams(t,e)}compare(t){return this===t?0:this.texture.compare(t.texture)||this.params.compare(t.params)||r(((t,e)=>{return n=e,r(((t,e)=>t.compare(e)),(s=t).normalMap,n.normalMap)||o(s.greenUp,n.greenUp)||function(t,e){return r(i,t,e)}(s.scale,n.scale)||o(s.useConstantLod,n.useConstantLod);var s,n}),this.normalMapParams,t.normalMapParams)}}!function(t){let e;!function(t){t[t.None=-1]="None",t[t.Parametric=0]="Parametric",t[t.ElevationDrape=1]="ElevationDrape",t[t.Planar=2]="Planar",t[t.DirectionalDrape=3]="DirectionalDrape",t[t.Cubic=4]="Cubic",t[t.Spherical=5]="Spherical",t[t.Cylindrical=6]="Cylindrical",t[t.Solid=7]="Solid",t[t.FrontProject=8]="FrontProject"}(e=t.Mode||(t.Mode={}));class n{constructor(t=1,e=0,i=0,s=0,n=1,r=0){const o=new j(i,r,0),a=xt.createRowValues(t,e,0,s,n,0,0,0,1);this.transform=pt.createRefs(o,a)}compare(t){if(this===t)return 0;const e=i(this.transform.origin.x,t.transform.origin.x)||i(this.transform.origin.y,t.transform.origin.y);if(0!==e)return e;for(const e of[0,1,3,4]){const s=i(this.transform.matrix.coffs[e],t.transform.matrix.coffs[e]);if(0!==s)return s}return 0}}n.identity=new n,t.Trans2x3=n,t.Params=class{constructor(t){this.textureMatrix=t?.textureMat2x3??n.identity,this.weight=t?.textureWeight??1,this.mode=t?.mapMode??e.Parametric,this.worldMapping=t?.worldMapping??!1,this.useConstantLod=t?.useConstantLod??!1,this.constantLodParams={repetitions:t?.constantLodProps?.repetitions??1,offset:t?.constantLodProps?.offset??{x:0,y:0},minDistClamp:t?.constantLodProps?.minDistClamp??1,maxDistClamp:t?.constantLodProps?.maxDistClamp??4294967296}}compare(t){return this===t?0:i(this.weight,t.weight)||i(this.mode,t.mode)||s(this.worldMapping,t.worldMapping)||s(this.useConstantLod,t.useConstantLod)||this.textureMatrix.compare(t.textureMatrix)||(e=this.constantLodParams,n=t.constantLodParams,i(e.repetitions,n.repetitions)||i(e.offset.x,n.offset.x)||i(e.offset.y,n.offset.y)||i(e.minDistClamp,n.minDistClamp)||i(e.maxDistClamp,n.maxDistClamp));var e,n}computeUVParams(e,i){switch(this.mode){default:case t.Mode.Parametric:return this.computeParametricUVParams(e,this.textureMatrix.transform,!this.worldMapping);case t.Mode.Planar:{const t=e.normalIndex;if(!t)return;return this.worldMapping&&(void 0===e.normalIndex||t[0]===t[1]&&t[0]===t[2])?this.computePlanarUVParams(e,this.textureMatrix.transform):this.computeParametricUVParams(e,this.textureMatrix.transform,!this.worldMapping)}case t.Mode.ElevationDrape:return this.computeElevationDrapeUVParams(e,this.textureMatrix.transform,i)}}computeParametricUVParams(t,e,i){const s=[];for(let n=0;n<t.numEdgesThisFacet;n++){let r=H.create();!i&&t.tryGetDistanceParameter(n,r)||t.tryGetNormalizedParameter(n,r)||(r=t.getParam(n)),s.push(e.multiplyPoint2d(r))}return s}computePlanarUVParams(t,e){const i=[],s=t.point;let n;if(n=void 0===t.normal?s.getPoint3dAtUncheckedPointIndex(0).crossProductToPoints(s.getPoint3dAtUncheckedPointIndex(1),s.getPoint3dAtUncheckedPointIndex(2)):t.normal.getVector3dAtCheckedVectorIndex(0),!n.normalize(n))return;n.scale(-1,n);const r=$.create(n.y,-n.x,0),o=r.magnitude();r.normalize(r),o<.001&&(n.set(0,0,-1),r.set(1,0,0));const a=r.crossProduct(n).normalize();if(!a)return;const c=t.numEdgesThisFacet;for(let t=0;t<c;t++){const n=$.createFrom(s.getPoint3dAtUncheckedPointIndex(t));i.push(H.create(n.dotProduct(r),n.dotProduct(a))),e.multiplyPoint2d(i[t],i[t])}return i}computeElevationDrapeUVParams(t,e,i){const s=[],n=t.numEdgesThisFacet;for(let r=0;r<n;r++){const n=t.point.getPoint3dAtUncheckedPointIndex(r);void 0!==i&&i.multiplyPoint3d(n,n),s.push(H.createFrom(n)),e.multiplyPoint2d(s[r],s[r])}return s}}}(xa||(xa={})),Object.freeze(xa.Trans2x3.identity),(ia=Zo||(Zo={}))[ia.Solid=0]="Solid",ia[ia.Code0=0]="Code0",ia[ia.Code1=2155905152]="Code1",ia[ia.Code2=4177066232]="Code2",ia[ia.Code3=4292935648]="Code3",ia[ia.Code4=4262526480]="Code4",ia[ia.Code5=3772834016]="Code5",ia[ia.Code6=4169726088]="Code6",ia[ia.Code7=4279828248]="Code7",ia[ia.HiddenLine=3435973836]="HiddenLine",ia[ia.Invisible=1]="Invisible",ia[ia.Invalid=-1]="Invalid",function(t){t[t.None=0]="None",t[t.ByView=1]="ByView",t[t.Always=2]="Always",t[t.Behind=4]="Behind",t[t.Blanking=6]="Blanking",t[t.Background=8]="Background"}(qo||(qo={})),function(t){t[t.Rgba=0]="Rgba",t[t.Rgb=2]="Rgb",t[t.Alpha=5]="Alpha"}(Wo||(Wo={}));class _a{get numBytesPerPixel(){return _a.getNumBytesPerPixel(this.format)}static getNumBytesPerPixel(t){switch(t){case Wo.Alpha:return 1;case Wo.Rgb:return 3;default:return 4}}get height(){return _a.computeHeight(this.data,this.format,this.width)}static create(t,e,i){if(!this.isValidData(t,e,i))throw new Error("The number of bytes supplied for ImageBuffer do not match its width and format.");return new _a(t,e,i)}static isValidData(t,e,i){const s=this.computeHeight(t,e,i);return i>0&&s>0&&Math.floor(i)===i&&Math.floor(s)===s}static computeHeight(t,e,i){return t.length/(i*this.getNumBytesPerPixel(e))}constructor(t,e,i){this.data=t,this.format=e,this.width=i}}!function(t){t[t.Jpeg=0]="Jpeg",t[t.Png=2]="Png",t[t.Svg=3]="Svg"}(Go||(Go={})),function(t){t[t.Opaque=0]="Opaque",t[t.Translucent=1]="Translucent",t[t.Mixed=2]="Mixed"}(Ho||(Ho={})),function(t){t[t.Smooth=0]="Smooth",t[t.Stepped=1]="Stepped",t[t.SteppedWithDelimiter=2]="SteppedWithDelimiter",t[t.IsoLines=3]="IsoLines"}(Jo||(Jo={})),function(t){t[t.SurfaceOnly=0]="SurfaceOnly",t[t.MultiplySurfaceAndGradient=1]="MultiplySurfaceAndGradient"}(Qo||(Qo={})),function(t){t[t.BlueRed=0]="BlueRed",t[t.RedBlue=1]="RedBlue",t[t.Monochrome=2]="Monochrome",t[t.Topographic=3]="Topographic",t[t.SeaMountain=4]="SeaMountain",t[t.Custom=5]="Custom"}(Ko||(Ko={}));class ya{static get margin(){return.001}static get contentRange(){return 1-2*ya.margin}static get contentMax(){return 1-ya.margin}get textureTransparency(){let t=Ho.Opaque;if(Ko.Custom===this.colorScheme){let e=!1,i=!1;for(const t of this.customKeys){const s=t.color.isOpaque;e=e||s,i=i||!s}i&&(t=e?Ho.Mixed:Ho.Translucent)}return t!==Ho.Mixed&&this.marginColor.isOpaque!==(t===Ho.Opaque)&&(t=Ho.Mixed),t}equals(t){return!(this.mode!==t.mode||this.stepCount!==t.stepCount||!this.marginColor.equals(t.marginColor)||this.colorScheme!==t.colorScheme||this.customKeys.length!==t.customKeys.length||this.colorMix!==t.colorMix||this.transparencyMode!==t.transparencyMode)&&this.customKeys.every(((e,i)=>$o.keyColorEquals(e,t.customKeys[i])))}static compare(t,e){let s=0;if(0!==(s=i(t.mode,e.mode)))return s;if(0!==(s=i(t.stepCount,e.stepCount)))return s;if(0!==(s=i(t.marginColor.tbgr,e.marginColor.tbgr)))return s;if(0!==(s=i(t.colorScheme,e.colorScheme)))return s;if(0!==(s=i(t.colorMix,e.colorMix)))return s;if(0!==(s=i(t.customKeys.length,e.customKeys.length)))return s;if(0!==(s=i(t.transparencyMode,e.transparencyMode)))return s;for(let n=0;n<t.customKeys.length;n++)if(0!==(s=i(t.customKeys[n].color.tbgr,e.customKeys[n].color.tbgr)))return s;return s}constructor(t){if(this.customKeys=[],void 0===t)this.mode=Jo.Smooth,this.stepCount=10,this.marginColor=$r.fromJSON(),this.colorScheme=Ko.BlueRed,this.colorMix=0,this.transparencyMode=Qo.SurfaceOnly;else{if(this.mode=void 0!==t.mode&&null!==t.mode?t.mode:Jo.Smooth,(this.mode<Jo.Smooth||this.mode>Jo.IsoLines)&&(this.mode=Jo.Smooth),this.stepCount="number"==typeof t.stepCount?t.stepCount:10,this.stepCount<2&&(this.stepCount=2),this.marginColor=$r.fromJSON(t.marginColor),this.colorScheme=void 0!==t.colorScheme&&null!==t.colorScheme?t.colorScheme:Ko.BlueRed,(this.colorScheme<Ko.BlueRed||this.colorScheme>Ko.Custom)&&(this.colorScheme=Ko.BlueRed),void 0!==t.customKeys&&null!==t.customKeys&&t.customKeys.forEach((t=>this.customKeys.push(new $o.KeyColor(t)))),this.colorScheme===Ko.Custom&&this.customKeys.length<2){this.customKeys=[];for(const t of ya._defaultCustomKeys)this.customKeys.push(new $o.KeyColor({value:t[0],color:$r.computeTbgrFromComponents(t[1],t[3],t[2])}))}this.colorMix=t.colorMix??0,this.transparencyMode=t.transparencyMode??Qo.SurfaceOnly}}static fromJSON(t){return t?new ya(t):this.defaults}toJSON(){const t={};Jo.Smooth!==this.mode&&(t.mode=this.mode),10!==this.stepCount&&(t.stepCount=this.stepCount);const e=this.marginColor.toJSON();return 0!==e&&(t.marginColor=e),Ko.BlueRed!==this.colorScheme&&(t.colorScheme=this.colorScheme),0!==this.colorMix&&(t.colorMix=this.colorMix),Qo.SurfaceOnly!==this.transparencyMode&&(t.transparencyMode=this.transparencyMode),this.customKeys.length>0&&(t.customKeys=this.customKeys.map((t=>({value:t.value,color:t.color.toJSON()})))),t}clone(t){if(void 0===t)return ya.fromJSON(this.toJSON());const e={mode:void 0!==t.mode?t.mode:this.mode,stepCount:void 0!==t.stepCount?t.stepCount:this.stepCount,marginColor:void 0!==t.marginColor?t.marginColor:this.marginColor.tbgr,colorScheme:void 0!==t.colorScheme?t.colorScheme:this.colorScheme,customKeys:void 0!==t.customKeys?t.customKeys:this.customKeys.map((t=>({value:t.value,color:t.color.tbgr}))),colorMix:void 0!==t.colorMix?t.colorMix:this.colorMix,transparencyMode:t.transparencyMode??this.transparencyMode};return ya.fromJSON(e)}}ya.defaults=new ya({}),ya._defaultCustomKeys=[[0,255,255,255],[1,0,0,0]],function(t){t[t.Height=0]="Height",t[t.InverseDistanceWeightedSensors=1]="InverseDistanceWeightedSensors",t[t.Slope=2]="Slope",t[t.HillShade=3]="HillShade"}(jo||(jo={})),function(t){let i,s;!function(t){t[t.None=0]="None",t[t.Invert=1]="Invert",t[t.Outline=2]="Outline"}(i=t.Flags||(t.Flags={})),function(t){t[t.None=0]="None",t[t.Linear=1]="Linear",t[t.Curved=2]="Curved",t[t.Cylindrical=3]="Cylindrical",t[t.Spherical=4]="Spherical",t[t.Hemispherical=5]="Hemispherical",t[t.Thematic=6]="Thematic"}(s=t.Mode||(t.Mode={}));class n{constructor(t){this.value=t.value,this.color=$r.fromJSON(t.color)}}t.KeyColor=n,t.keyColorEquals=function(t,e){return t.value===e.value&&t.color.equals(e.color)};class r{constructor(){this.mode=s.None,this.flags=i.None,this.shift=0,this.keys=[]}static fromJSON(t){const e=new r;return t?(e.mode=t.mode,e.flags=void 0===t.flags?i.None:t.flags,e.angle=t.angle?W.fromJSON(t.angle):void 0,e.tint=t.tint,e.shift=t.shift?t.shift:0,t.keys.forEach((t=>e.keys.push(new n(t)))),e.thematicSettings=void 0===t.thematicSettings?void 0:ya.fromJSON(t.thematicSettings),e):e}static createThematic(i){const o=new r;if(o.mode=s.Thematic,o.thematicSettings=i,i.colorScheme<Ko.Custom)for(const e of t.Symb._fixedSchemeKeys[i.colorScheme])o.keys.push(new n({value:e[0],color:$r.computeTbgrFromComponents(e[1],e[3],e[2])}));else if(e(i.customKeys.length>1,"Custom thematic mode requires at least two keys to be defined"),i.customKeys.length>1)i.customKeys.forEach((t=>o.keys.push(t)));else for(const e of t.Symb._fixedCustomKeys)o.keys.push(new n({value:e[0],color:$r.from(e[1],e[3],e[2]).toJSON()}));return o}toJSON(){return{...this,thematicSettings:this.thematicSettings?.toJSON(),keys:this.keys.map((t=>({value:t.value,color:t.color.toJSON()})))}}clone(){return r.fromJSON(this.toJSON())}equals(t){return 0===r.compareSymb(this,t)}static compareSymb(t,e){if(t===e)return 0;if(t.mode!==e.mode)return t.mode-e.mode;if(t.flags!==e.flags)return void 0===t.flags?-1:void 0===e.flags?1:t.flags-e.flags;if(t.tint!==e.tint)return void 0===t.tint?-1:void 0===e.tint?1:t.tint-e.tint;if(t.shift!==e.shift)return void 0===t.shift?-1:void 0===e.shift?1:t.shift-e.shift;if(void 0===t.angle!=(void 0===e.angle))return void 0===t.angle?-1:1;if(t.angle&&!t.angle.isAlmostEqualNoPeriodShift(e.angle))return t.angle.radians-e.angle.radians;if(t.keys.length!==e.keys.length)return t.keys.length-e.keys.length;for(let i=0;i<t.keys.length;i++){if(t.keys[i].value!==e.keys[i].value)return t.keys[i].value-e.keys[i].value;if(!t.keys[i].color.equals(e.keys[i].color))return t.keys[i].color.tbgr-e.keys[i].color.tbgr}if(t.thematicSettings!==e.thematicSettings){if(void 0===t.thematicSettings)return-1;if(void 0===e.thematicSettings)return 1;{const i=ya.compare(t.thematicSettings,e.thematicSettings);if(0!==i)return i}}return 0}compare(e){return t.Symb.compareSymb(this,e)}roundToByte(t){return 255&Math.min(t+.5,255)}mapColor(t){t<0?t=0:t>1&&(t=1),this.flags&i.Invert&&(t=1-t);let e,s,n,r=0;if(this.keys.length<=2)s=1-t,n=t;else{for(;r<this.keys.length-2&&t>this.keys[r+1].value;)r++;e=this.keys[r+1].value-this.keys[r].value,n=e<1e-4?0:(t-this.keys[r].value)/e,s=1-n}const o=this.keys[r].color,a=this.keys[r+1].color,c=o.colors,l=a.colors,h=s*c.r+n*l.r,d=s*c.g+n*l.g,u=s*c.b+n*l.b,f=s*c.t+n*l.t;return $r.from(this.roundToByte(h),this.roundToByte(d),this.roundToByte(u),this.roundToByte(f))}get hasTranslucency(){for(const t of this.keys)if(!t.color.isOpaque)return!0;return!1}get isOutlined(){return!!(this.flags&i.Outline)}getThematicImageForRenderer(t){e(s.Thematic===this.mode,"getThematicImageForRenderer only is used for thematic display.");let i=this.thematicSettings;void 0===i&&(i=ya.defaults);const n=Math.min(i.stepCount,t),r=Jo.Smooth===i.mode?t:n,o=new Uint8Array(1*r*4);let a=o.length-1;function c(t){o[a--]=t.getAlpha(),o[a--]=t.colors.b,o[a--]=t.colors.g,o[a--]=t.colors.r}switch(i.mode){case Jo.Smooth:for(let t=0;t<r;t++){const e=1-t/r;c(this.mapColor(e))}break;case Jo.SteppedWithDelimiter:case Jo.IsoLines:case Jo.Stepped:e(i.stepCount>1,"Step count must be at least two to generate renderer gradient for thematic display");for(let t=0;t<r;t++){const e=1-t/(r-1);c(this.mapColor(e))}}e(-1===a);const l=_a.create(o,Wo.Rgba,1);return e(void 0!==l),l}getImage(t,e){return this.mode===s.Thematic&&(t=1),this.produceImage({width:t,height:e,includeThematicMargin:!0})}produceImage(t){const{width:i,height:n,includeThematicMargin:r}={...t},o=void 0===this.angle?0:this.angle.radians,a=Math.cos(o),c=Math.sin(o),l=new Uint8Array(i*n*4);let h=l.length-1;const d=Math.min(1,Math.abs(this.shift));switch(this.mode){case s.Linear:case s.Cylindrical:{const t=.5-.25*d*a,e=.5-.25*d*c;let r,o,u=r=0;for(let i=0;i<2;i++)for(let s=0;s<2;s++)o=(s-t)*a+(i-e)*c,o<u&&(u=o),o>r&&(r=o);for(let d=0;d<n;d++){const f=d/n-e;for(let e=0;e<i;e++){let n;o=(e/i-t)*a+f*c,n=this.mode===s.Linear?o>0?.5+.5*o/r:.5-.5*o/u:o>0?Math.sin(Math.PI/2*(1-o/r)):Math.sin(Math.PI/2*(1-o/u));const d=this.mapColor(n);l[h--]=d.getAlpha(),l[h--]=d.colors.b,l[h--]=d.colors.g,l[h--]=d.colors.r}}break}case s.Curved:{const t=.5+.5*c-.25*d*a,e=.5-.5*a-.25*d*c;for(let s=0;s<n;s++){const r=s/n-e;for(let e=0;e<i;e++){const s=e/i-t,n=.8*(s*a+r*c),o=r*a-s*c,d=Math.sin(Math.PI/2*(1-Math.sqrt(n*n+o*o))),u=this.mapColor(d);l[h--]=u.getAlpha(),l[h--]=u.colors.b,l[h--]=u.colors.g,l[h--]=u.colors.r}}break}case s.Spherical:{const t=.5+.125*Math.sin(2*o),e=.5*d*(a+c)*t,s=.5*d*(c-a)*t;for(let r=0;r<n;r++){const o=s+r/n-.5;for(let s=0;s<i;s++){const n=e+s/i-.5,r=Math.sin(Math.PI/2*(1-Math.sqrt(n*n+o*o)/t)),a=this.mapColor(r);l[h--]=a.getAlpha(),l[h--]=a.colors.b,l[h--]=a.colors.g,l[h--]=a.colors.r}}break}case s.Hemispherical:{const t=.5+.5*c-.5*d*a,e=.5-.5*a-.5*d*c;for(let s=0;s<n;s++){const r=s/n-e;for(let e=0;e<i;e++){const s=e/i-t,n=Math.sin(Math.PI/2*(1-Math.sqrt(s*s+r*r))),o=this.mapColor(n);l[h--]=o.getAlpha(),l[h--]=o.colors.b,l[h--]=o.colors.g,l[h--]=o.colors.r}}break}case s.Thematic:{const t=this.thematicSettings??ya.defaults;for(let e=0;e<n;e++){let s,o=1-e/n;if(r&&(o<ya.margin||o>ya.contentMax))s=t.marginColor;else switch(o=(o-ya.margin)/ya.contentRange,t.mode){case Jo.SteppedWithDelimiter:case Jo.IsoLines:case Jo.Stepped:if(t.stepCount>1){const e=Math.floor(o*t.stepCount-1e-5)/(t.stepCount-1);s=this.mapColor(e)}break;case Jo.Smooth:s=this.mapColor(o)}for(let t=0;t<i;t++)l[h--]=s.getAlpha(),l[h--]=s.colors.b,l[h--]=s.colors.g,l[h--]=s.colors.r}}}e(-1===h);const u=_a.create(l,Wo.Rgba,i);return e(void 0!==u),u}}r._fixedSchemeKeys=[[[0,0,255,0],[.25,0,255,255],[.5,0,0,255],[.75,255,0,255],[1,255,0,0]],[[0,255,0,0],[.25,255,0,255],[.5,0,0,255],[.75,0,255,255],[1,0,255,0]],[[0,0,0,0],[1,255,255,255]],[[0,152,148,188],[.5,204,160,204],[1,152,72,128]],[[0,0,255,0],[.2,72,96,160],[.4,152,96,160],[.6,128,32,104],[.7,148,180,128],[1,240,240,240]]],r._fixedCustomKeys=[[0,255,0,0],[1,0,255,0]],t.Symb=r}($o||($o={})),function(t){t[t.Mesh=0]="Mesh",t[t.Polyline=1]="Polyline",t[t.Point=2]="Point"}(ta||(ta={})),function(t){t[t.Unlit=0]="Unlit",t[t.Lit=1]="Lit",t[t.Textured=2]="Textured",t[t.TexturedLit=3]="TexturedLit",t[t.VolumeClassifier=4]="VolumeClassifier"}(ea||(ea={}));class va{constructor(t,i,s,n=0,r=Zo.Solid,o=qo.None,a,c,l=!1,h){this.type=va.Type.Mesh,this.type=t,this.material=a,this.gradient=c,this.lineColor=va.adjustTransparency(i),this.fillColor=va.adjustTransparency(s),this.width=n,this.linePixels=r,this.fillFlags=o,this.ignoreLighting=l,this._textureMapping=h,e(void 0===a||void 0===h)}static createForType(t,e,i,s=!1){const n=va.adjustTransparency(e.lineColor);switch(t){case va.Type.Mesh:{let r;if(void 0!==e.gradient&&void 0!==i){const t=i(e.gradient);void 0!==t&&(r=new xa(t,new xa.Params))}return new va(t,n,va.adjustTransparency(e.fillColor),e.rasterWidth,e.linePixels,e.fillFlags,e.material,e.gradient,s,r)}case va.Type.Linear:return new va(t,n,n,e.rasterWidth,e.linePixels);default:return new va(t,n,n,0,Zo.Solid,qo.Always,void 0,void 0,!0)}}static createForMesh(t,e,i){return va.createForType(va.Type.Mesh,t,i,e)}static createForLinear(t){return va.createForType(va.Type.Linear,t)}static createForText(t){return va.createForType(va.Type.Text,t)}get regionEdgeType(){return this.hasBlankingFill?va.RegionEdgeType.None:void 0!==this.gradient&&void 0!==this.gradient.flags?this.gradient.flags&$o.Flags.Outline||qo.None===(this.fillFlags&qo.Always)?va.RegionEdgeType.Outline:va.RegionEdgeType.None:this.fillColor.equals(this.lineColor)?va.RegionEdgeType.Default:va.RegionEdgeType.Outline}get wantRegionOutline(){return va.RegionEdgeType.Outline===this.regionEdgeType}get hasBlankingFill(){return qo.Blanking===(this.fillFlags&qo.Blanking)}get hasFillTransparency(){return 255!==this.fillColor.getAlpha()}get hasLineTransparency(){return 255!==this.lineColor.getAlpha()}get textureMapping(){return void 0!==this.material?this.material.textureMapping:this._textureMapping}get isTextured(){return void 0!==this.textureMapping}equals(t,e=va.ComparePurpose.Strict){return va.ComparePurpose.Merge===e?0===this.compareForMerge(t):t===this||this.type===t.type&&this.ignoreLighting===t.ignoreLighting&&this.width===t.width&&this.linePixels===t.linePixels&&this.fillFlags===t.fillFlags&&this.wantRegionOutline===t.wantRegionOutline&&this.material===t.material&&this.textureMapping===t.textureMapping&&!!this.fillColor.equals(t.fillColor)&&!!this.lineColor.equals(t.lineColor)}compareForMerge(t){if(t===this)return 0;let e=i(this.type,t.type);return 0===e&&(e=s(this.ignoreLighting,t.ignoreLighting),0===e&&(e=i(this.width,t.width),0===e&&(e=i(this.linePixels,t.linePixels),0===e&&(e=i(this.fillFlags,t.fillFlags),0===e&&(e=s(this.wantRegionOutline,t.wantRegionOutline),0===e&&(e=s(this.hasFillTransparency,t.hasFillTransparency),0===e&&(e=s(this.hasLineTransparency,t.hasLineTransparency),0===e&&(e=function(t,e){return r(((t,e)=>t.compare(e)),t,e)}(this.material,t.material),0===e&&void 0===this.material&&this.isTextured&&(e=function(t,e){return r(((t,e)=>t.compare(e)),t,e)}(this.textureMapping,t.textureMapping)))))))))),e}static adjustTransparency(t){return t.colors.t<va.minTransparency?t.withTransparency(0):t}}va.minTransparency=15,function(t){let e,i,s;!function(t){t[t.Mesh=0]="Mesh",t[t.Linear=1]="Linear",t[t.Text=2]="Text"}(e=t.Type||(t.Type={})),function(t){t[t.None=0]="None",t[t.Default=1]="Default",t[t.Outline=2]="Outline"}(i=t.RegionEdgeType||(t.RegionEdgeType={})),function(t){t[t.Merge=0]="Merge",t[t.Strict=1]="Strict"}(s=t.ComparePurpose||(t.ComparePurpose={}))}(va||(va={}));const Pa=new Uint16Array(1);function Aa(t){return Ia(.5+255*(.5*function(t){return t<-1?-1:t>1?1:t}(t)+.5))}function Ia(t){return Pa[0]=t,Pa[0]}function Sa(t){return t<0?-1:1}class wa{constructor(t){this.value=Ia(t)}static encode(t){return this.encodeXYZ(t.x,t.y,t.z)}static encodeXYZ(t,e,i){const s=Math.abs(t)+Math.abs(e)+Math.abs(i);let n=t/s,r=e/s;if(i<0){const t=n,e=r;n=(1-Math.abs(e))*Sa(t),r=(1-Math.abs(t))*Sa(e)}return Aa(r)<<8|Aa(n)}static fromVector(t){return new wa(this.encode(t))}decode(){return wa.decodeValue(this.value)}static decodeValue(t,e){let i=255&t,s=t>>8;i=i/255*2-1,s=s/255*2-1;const n=1-(Math.abs(i)+Math.abs(s));let r;if(void 0===e?r=new $(i,s,n):(r=e,r.x=i,r.y=s,r.z=n),r.z<0){const t=r.x,e=r.y;r.x=(1-Math.abs(e))*Sa(t),r.y=(1-Math.abs(t))*Sa(e)}return r.normalizeInPlace(),r}}function Ca(t,i,s,n){const r=Math.ceil(t*i)+s;if(r<=n)return{width:r,height:1};let o=Math.ceil(Math.sqrt(r));const a=o%i;0!==a&&(o+=i-a);const c=Math.ceil(r/o);return e(c<=n),e(o<=n),e(o*c>=r),e(Math.floor(c)===c),e(Math.floor(o)===o),e(0==o%i),{width:o,height:c}}class Ta{constructor(t){this.name=t.name,this.inputs=t.inputs,this.indices=t.indices}toJSON(){return{name:this.name,inputs:this.inputs,indices:this.indices}}}class Fa extends Ta{constructor(t){super(t),this.qOrigin=Float32Array.from(t.qOrigin),this.qScale=Float32Array.from(t.qScale)}toJSON(){return{...super.toJSON(),qOrigin:Array.from(this.qOrigin),qScale:Array.from(this.qScale)}}}class ka extends Ta{constructor(t){super(t),this.qOrigin=t.qOrigin[0],this.qScale=t.qScale[0]}toJSON(){return{...super.toJSON(),qOrigin:[this.qOrigin],qScale:[this.qScale]}}}class Ma{constructor(t,e,i,s){this.data=t.data,this.width=t.width,this.height=t.height,this.numVertices=t.count,this.numBytesPerVertex=t.numBytesPerVertex,this.displacements=e,this.normals=i,this.params=s}static fromJSON(t){let e,i,s;if(void 0!==t.displacements&&0<t.displacements.length){e=[];for(const i of t.displacements)e.push(new Fa(i))}if(void 0!==t.normals&&0<t.normals.length){i=[];for(const e of t.normals)i.push(new Ta(e))}if(void 0!==t.params&&0<t.params.length){s=[];for(const e of t.params)s.push(new ka(e))}return void 0!==e||void 0!==i||void 0!==s?new Ma(t,e,i,s):void 0}toJSON(){return{data:this.data,width:this.width,height:this.height,count:this.numVertices,numBytesPerVertex:this.numBytesPerVertex,displacements:this.displacements?.map((t=>t.toJSON())),normals:this.normals?.map((t=>t.toJSON())),params:this.params?.map((t=>t.toJSON()))}}static fromChannels(t,e,i){return Ea.buildAuxChannelTable(t,e,i)}}function ba(t){return 0!==t&&(t=1/t),t}class Ea{constructor(t,e){this._props=t,this._numBytesPerVertex=e,this._view=new DataView(t.data.buffer)}static buildAuxChannelTable(t,i,s){const n=t.reduce(((t,e)=>t+Ra(e)),0);if(!n)return;const r=Math.floor((n+3)/4),o=4*r-n;let a;e(0===o||2===o),a=0!==o?Ca(Math.floor((i+1)/2),n/2,0,s):Ca(i,r,0,s);const c={data:new Uint8Array(a.width*a.height*4),width:a.width,height:a.height,count:i,numBytesPerVertex:n};return new Ea(c,n).build(t),Ma.fromJSON(c)}build(t){let e=0;for(const i of t)F.Normal===i.dataType?this.addNormals(i,e):F.Vector===i.dataType?this.addDisplacements(i,e):this.addParams(i,e),e+=Ra(i)}addNormals(t,e){const i=[],s=[],n=new $;for(let r=0;r<t.data.length;r++){let o=e+2*r;s.push(o/2);const a=t.data[r];i.push(a.input);for(let t=0;t<a.values.length;t+=3){n.x=a.values[t],n.y=a.values[t+1],n.z=a.values[t+2],n.normalizeInPlace();const e=wa.encode(n);this._view.setUint16(o,e,!0),o+=this._numBytesPerVertex}}(this._props.normals??(this._props.normals=[])).push({name:t.name??"",inputs:i,indices:s})}addParams(t,e){const i=[],s=[],n=ft.createNull();for(const e of t.data)i.push(e.input),n.extendArray(e.values);const r=Oo.computeScale(n.high-n.low);for(let i=0;i<t.data.length;i++){let o=e+2*i;s.push(o/2);for(const e of t.data[i].values){const t=Oo.quantize(e,n.low,r);this._view.setUint16(o,t,!0),o+=this._numBytesPerVertex}}(this._props.params??(this._props.params=[])).push({inputs:i,indices:s,name:t.name??"",qOrigin:[n.low],qScale:[ba(r)]})}addDisplacements(t,e){const i=[],s=[],n=new j,r=ut.createNull();for(const e of t.data){i.push(e.input);for(let t=0;t<e.values.length;t+=3)n.set(e.values[t],e.values[t+1],e.values[t+2]),r.extend(n)}const o=fa.fromRange(r),a=new ga;for(let i=0;i<t.data.length;i++){let r=e+6*i;s.push(r/2);const c=t.data[i];for(let t=0;t<c.values.length;t+=3)n.set(c.values[t],c.values[t+1],c.values[t+2]),a.init(n,o),this._view.setUint16(r+0,a.x,!0),this._view.setUint16(r+2,a.y,!0),this._view.setUint16(r+4,a.z,!0),r+=this._numBytesPerVertex}(this._props.displacements??(this._props.displacements=[])).push({inputs:i,indices:s,name:t.name??"",qOrigin:o.origin.toArray(),qScale:o.scale.toArray().map((t=>ba(t)))})}}function Ra(t){const e=t.data.length;switch(t.dataType){case F.Vector:return 6*e;case F.Normal:case F.Distance:case F.Scalar:return 2*e}}class Da{constructor(t,e){this._constructor=t,this._data=new t(e?.initialCapacity??0),this.growthFactor=Math.max(1,e?.growthFactor??1.5),this._length=0}get length(){return this._length}get capacity(){return this._data.length}at(t){t<0&&(t=this.length-t);const i=this._data[t];return e(void 0!==i,"index out of bounds"),i}ensureCapacity(t){if(this.capacity>=t)return this.capacity;e(this.growthFactor>=1),t=Math.ceil(t*this.growthFactor);const i=this._data;return this._data=new this._constructor(t),this._data.set(i,0),e(this.capacity===t),this.capacity}push(t){this.ensureCapacity(this.length+1),this._data[this.length]=t,++this._length}append(t){const e=this.length+t.length;this.ensureCapacity(e),this._data.set(t,this.length),this._length=e}toTypedArray(t=!1){if(t)return this._data;const i=this._data.subarray(0,this.length);return e(i instanceof this._constructor),e(i.buffer===this._data.buffer),i}}class Xa extends Da{constructor(t){super(Uint8Array,t)}}class za extends Da{constructor(t){super(Uint32Array,t)}toUint8Array(t=!1){return t?new Uint8Array(this._data.buffer):new Uint8Array(this._data.buffer,0,4*this.length)}}function Na(t,e,i){let s=Math.ceil(1.5*t+2.5*e);const n=6*t;let r=0,o=s,a=1;if(s>=i){o=Math.ceil(Math.sqrt(s));const i=o%15;0!==i&&(o+=15-i),e>0&&t>0&&(r=(60-n%60)%10,s+=Math.ceil(r/4)),a=Math.ceil(s/o),o*a<s&&a++}return{width:o,height:a,silhouettePadding:r,silhouetteStartByteIndex:n}}class Oa{constructor(t){this.data=t,e(0==this.data.length%3)}get length(){return this.data.length/3}static fromArray(t){const e=new Uint8Array(3*t.length);for(let i=0;i<t.length;i++)this.encodeIndex(t[i],e,3*i);return new Oa(e)}static encodeIndex(t,i,s){e(s+2<i.length),i[s+0]=255&t,i[s+1]=(65280&t)>>8,i[s+2]=(16711680&t)>>16}setNthIndex(t,e){Oa.encodeIndex(e,this.data,3*t)}decodeIndex(t){e(t<this.length);const i=3*t;return this.data[i]|this.data[i+1]<<8|this.data[i+2]<<16}decodeIndices(){const t=[];for(let e=0;e<this.length;e++)t.push(this.decodeIndex(e));return t}[Symbol.iterator](){return function*(t){for(let e=0;e<t.length;e++)yield t.decodeIndex(e)}(this)}}class Ya{constructor(t=3){this._index32=new Uint32Array(1),this._index8=new Uint8Array(this._index32.buffer,0,3),this._builder=new Xa({initialCapacity:3*t})}get numIndices(){return e(this._builder.length%3==0),this._builder.length/3}push(t){this._index32[0]=t,this._builder.append(this._index8)}toVertexIndices(){return new Oa(this._builder.toTypedArray())}}class Ba{constructor(t){this._source=t,this._builder=new za({initialCapacity:3*t.numRgbaPerVertex})}get length(){return e(this._builder.length%this.vertexSize==0),this._builder.length/this.vertexSize}get vertexSize(){return this._source.numRgbaPerVertex}push(t){e(t.length===this.vertexSize),this._builder.append(t)}buildVertexTable(t,i,s){const n=this._source;e(void 0!==(i=i??n.uniformColor));const r=i instanceof Uint32Array?i.length:0,o=s instanceof Uint32Array?s.length:0,a=Ca(this.length,this.vertexSize,r+o,t);let c=this._builder.toTypedArray();if(a.width*a.height>c.length){const t=c;c=new Uint32Array(a.width*a.height),c.set(t,0)}let l=this.vertexSize*this.length;return i instanceof Uint32Array&&(c.set(i,l),l+=i.length),s instanceof Uint32Array&&c.set(s,l),{data:new Uint8Array(c.buffer,c.byteOffset,c.byteLength),usesUnquantizedPositions:n.usesUnquantizedPositions,qparams:n.qparams,width:a.width,height:a.height,hasTranslucency:n.hasTranslucency,uniformColor:i instanceof $r?i:void 0,featureIndexType:n.featureIndexType,uniformFeatureID:n.uniformFeatureID,numVertices:this.length,numRgbaPerVertex:n.numRgbaPerVertex,uvParams:n.uvParams}}}class Va{constructor(t){this._remappedIndices=new Map,this.colors=[],this._32=new Uint32Array(1),this._16=new Uint16Array(this._32.buffer),this._colorTable=t}remap(t,e){const i=e?4:1,s=e?0:1;this._32[0]=t[i];const n=this._16[s];let r=this._remappedIndices.get(n);if(void 0===r){r=this.colors.length,this._remappedIndices.set(n,r);const t=this._colorTable[n];this.colors.push(t)}this._16[s]=r,t[i]=this._32[0]}buildColorTable(){return e(this.colors.length>0),this.colors.length>1?new Uint32Array(this.colors):$r.fromAbgr(this.colors[0])}}class La{constructor(t,e){this._remappedIndices=new Map,this.materials=[],this._32=new Uint32Array(1),this._8=new Uint8Array(this._32.buffer),this._atlasTable=t,this._createMaterial=e}remap(t,e){const i=e?3:2;this._32[0]=t[i];const s=this._8[3];let n=this._remappedIndices.get(s);if(void 0===n){n=this.materials.length/4,this._remappedIndices.set(s,n);let t=4*s;this.materials.push(this._atlasTable[t++]),this.materials.push(this._atlasTable[t++]),this.materials.push(this._atlasTable[t++]),this.materials.push(this._atlasTable[t])}this._8[3]=n,t[i]=this._32[0]}unpackFloat(t){this._32[0]=t;const e=this._32[0],i=(e>>>24)/2;let s=Math.floor(i),n=2*(i-s);return n=-(2*n-1),s-=38,n*(16777215&e)/16777216*Math.pow(10,s)}materialFromAtlasEntry(t){const e=!!(16777216&t[1]),i={alpha:33554432&t[1]?(t[0]>>>24)/255:void 0,diffuse:{color:e?$r.fromTbgr(16777215&t[0]):void 0,weight:(t[1]>>>8&255)/255},specular:{color:$r.fromTbgr(t[2]),weight:(t[1]>>>16&255)/255,exponent:this.unpackFloat(t[3])}};return void 0===(s=this._createMaterial(i))?void 0:{isAtlas:!1,material:s};var s}buildAtlasTable(){e(this.materials.length>0);const t=new Uint32Array(this.materials);return this.materials.length>4?t:this.materialFromAtlasEntry(t)}}class Ua{constructor(t,e){if(this.remappedIndices=new Map,this.indices=new Ya,this.vertices=new Ba(t),void 0===t.uniformColor&&(this.colors=new Va(new Uint32Array(t.data.buffer,t.data.byteOffset+4*t.numVertices*t.numRgbaPerVertex))),e){const i=4*(t.numVertices*t.numRgbaPerVertex+e.offset);this.atlas=new La(new Uint32Array(t.data.buffer,t.data.byteOffset+i),e.createMaterial)}this.usesUnquantizedPositions=t.usesUnquantizedPositions}addVertex(t,e){let i=this.remappedIndices.get(t);void 0===i&&(i=this.vertices.length,this.remappedIndices.set(t,i),this.colors?.remap(e,this.usesUnquantizedPositions),this.atlas?.remap(e,this.usesUnquantizedPositions),this.vertices.push(e)),this.indices.push(i)}buildOutput(t,e){const i=this.atlas?.buildAtlasTable();let s;if(i instanceof Uint32Array){const t=void 0!==this.colors?.colors.length&&this.colors?.colors.length>1?this.colors?.colors.length:0;s={isAtlas:!0,hasTranslucency:(e?.isAtlas&&e?.hasTranslucency)??!1,overridesAlpha:(e?.isAtlas&&e?.overridesAlpha)??!1,vertexTableOffset:t,numMaterials:i.length/4}}else s=i;return{indices:this.indices.toVertexIndices(),vertices:this.vertices.buildVertexTable(t,this.colors?.buildColorTable(),i),material:s}}}class Za{constructor(t,e){this._nodes=new Map,this._input=t,this._computeNodeId=e}static split(t,e){const i=new Za(t,e);return i.split(),i._nodes}split(){const t={featureIndex:-1,node:void 0},e=this._input.vertices.numRgbaPerVertex,i=new Uint32Array(e),s=new Uint32Array(this._input.vertices.data.buffer,this._input.vertices.data.byteOffset,this._input.vertices.numVertices*e);let n;if(this._input.vertices.usesUnquantizedPositions){const t=new Uint8Array(i.buffer);n=()=>t[3]|t[7]<<8|t[11]<<16}else n=()=>16777215&i[2];for(const r of this._input.indices){const o=r*e;for(let t=0;t<i.length;t++)i[t]=s[o+t];const a=n();if(t.featureIndex!==a){t.featureIndex=a;const e=this._computeNodeId(a);let i=this._nodes.get(e);void 0===i&&this._nodes.set(e,i=new Ua(this._input.vertices,this._input.atlasInfo)),t.node=i}t.node.addVertex(r,i)}}}function qa(t){const e=Za.split({indices:t.params.indices,vertices:t.params.vertices,featureTable:t.featureTable},t.computeNodeId),i=new Map;for(const[s,n]of e){const{vertices:e,indices:r}=n.buildOutput(t.maxDimension);i.set(s,{vertices:e,indices:r,weight:t.params.weight})}return i}class Wa{constructor(){this.indices=new Ya,this.prevIndices=new Ya,this.nextIndicesAndParams=new za}}function Ga(t,i,s){for(const[e,n]of s){const s=n.remappedIndices.get(i);if(void 0!==s)return t.index=s,t.node=n,t.id=e,!0}return e(!1),!1}function Ha(t,i,s,n){const r=i[t];if(!r)return;const o=new Uint32Array(r.endPointAndQuadIndices.buffer,r.endPointAndQuadIndices.byteOffset,r.endPointAndQuadIndices.length/4);let a;"silhouettes"===t&&(e(void 0!==i.silhouettes),a=new Uint32Array(i.silhouettes.normalPairs.buffer,i.silhouettes.normalPairs.byteOffset,i.silhouettes.normalPairs.length/4));let c=0;const l={};for(const i of r.indices){if(Ga(l,i,s)){let i=o[c];const s=(16777215&i)>>>0,r=l.node.remappedIndices.get(s);e(void 0!==r),i=4278190080&i|r;let h=n.get(l.id);h||n.set(l.id,h={}),a?(h.silhouettes||(h.silhouettes={indices:new Ya,endPointAndQuadIndices:new za,normalPairs:new za}),h.silhouettes.normalPairs.push(a[c])):h.segments||(h.segments={indices:new Ya,endPointAndQuadIndices:new za});const d=h[t];e(void 0!==d),d.indices.push(l.index),d.endPointAndQuadIndices.push(i)}++c}}function Ja(t){const i=new Map,s=t.params.surface.material,n=void 0!==s&&s.isAtlas?s.vertexTableOffset:void 0,r=void 0!==n?{offset:n,createMaterial:t.createMaterial}:void 0,o=Za.split({indices:t.params.surface.indices,vertices:t.params.vertices,featureTable:t.featureTable,atlasInfo:r},t.computeNodeId),a=t.params.edges?function(t,i,s){const n=new Map;Ha("segments",t,i,n),Ha("silhouettes",t,i,n),t.polylines&&function(t,i,s){const n=new Uint32Array(t.nextIndicesAndParams.buffer,t.nextIndicesAndParams.byteOffset,t.nextIndicesAndParams.length/4),r=t.prevIndices[Symbol.iterator]();let o=0;const a={};for(const c of t.indices){if(Ga(a,c,i)){const t=r.next().value;e(void 0!==t);const i=a.node.remappedIndices.get(t);e(void 0!==i);let c=n[o];const l=(16777215&c)>>>0,h=a.node.remappedIndices.get(l);e(void 0!==h),c=4278190080&c|h;let d=s.get(a.id);d||s.set(a.id,d={}),d.polylines||(d.polylines=new Wa),d.polylines.indices.push(a.index),d.polylines.prevIndices.push(i),d.polylines.nextIndicesAndParams.push(c)}++o}}(t.polylines,i,n),t.indexed&&function(t,i,s){const n=t.edges.data,r=t.edges.numSegments,o=6*r+t.edges.silhouettePadding;function a(t){return[n[t+0]|n[t+1]<<8|n[t+2]<<16,n[t+3]|n[t+4]<<8|n[t+5]<<16]}function c(t){return[n[t+0]|n[t+1]<<8|n[t+2]<<16,n[t+3]|n[t+4]<<8|n[t+5]<<16,n[t+6]|n[t+7]<<8,n[t+8]|n[t+9]<<8]}function l(t,e,i,s,n){t.silhouettes.push(255&e),t.silhouettes.push((65280&e)>>>8),t.silhouettes.push((16711680&e)>>>16),t.silhouettes.push(255&i),t.silhouettes.push((65280&i)>>>8),t.silhouettes.push((16711680&i)>>>16),t.silhouettes.push(255&s),t.silhouettes.push((65280&s)>>>8),t.silhouettes.push(255&n),t.silhouettes.push((65280&n)>>>8)}let h=0;for(const e of t.indices)h=Math.max(e,h);const d={};let u=0,f=0,g=0,p=0;for(let t=0,n=0;t<=h;++t)if(t<r?([u,f]=a(n),n+=6):(n=o+10*(t-r),[u,f,g,p]=c(n)),Ga(d,u,i)){let i=s.get(d.id);if(i||s.set(d.id,i={}),i.indexed||(i.indexed={edges:new Xa,silhouettes:new Xa}),t<r){const t=d.node.remappedIndices.get(u);e(void 0!==t);const s=d.node.remappedIndices.get(f);e(void 0!==s),x=t,_=s,(m=i.indexed).edges.push(255&x),m.edges.push((65280&x)>>>8),m.edges.push((16711680&x)>>>16),m.edges.push(255&_),m.edges.push((65280&_)>>>8),m.edges.push((16711680&_)>>>16)}else{const t=d.node.remappedIndices.get(u);e(void 0!==t);const s=d.node.remappedIndices.get(f);e(void 0!==s),l(i.indexed,t,s,g,p)}}var m,x,_}(t.indexed,i,n);const r=new Map;for(const[e,i]of n){if(!i.segments&&!i.silhouettes&&!i.indexed)continue;let n={},o={};if(i.indexed){const t=i.indexed.edges.length/6,e=i.indexed.silhouettes.length/10,{width:r,height:a,silhouettePadding:c,silhouetteStartByteIndex:l}=Na(t,e,s),h=new Uint8Array(r*a*4);h.set(i.indexed.edges.toTypedArray(),0),e>0&&h.set(i.indexed.silhouettes.toTypedArray(),l+c);const d=t+e;o=new Oa(new Uint8Array(6*d*3));for(let t=0;t<d;t++)for(let e=0;e<6;e++)o.setNthIndex(6*t+e,t);n={data:h,width:r,height:a,numSegments:t,silhouettePadding:c}}r.set(e,{weight:t.weight,linePixels:t.linePixels,segments:i.segments?{indices:i.segments.indices.toVertexIndices(),endPointAndQuadIndices:i.segments.endPointAndQuadIndices.toUint8Array()}:void 0,silhouettes:i.silhouettes?{indices:i.silhouettes.indices.toVertexIndices(),endPointAndQuadIndices:i.silhouettes.endPointAndQuadIndices.toUint8Array(),normalPairs:i.silhouettes.normalPairs.toUint8Array()}:void 0,polylines:i.polylines?{indices:i.polylines.indices.toVertexIndices(),prevIndices:i.polylines.prevIndices.toVertexIndices(),nextIndicesAndParams:i.polylines.nextIndicesAndParams.toUint8Array()}:void 0,indexed:i.indexed?{indices:o,edges:n}:void 0})}return r}(t.params.edges,o,t.maxDimension):void 0;for(const[e,s]of o){const{vertices:n,indices:r,material:o}=s.buildOutput(t.maxDimension,t.params.surface.material),c={vertices:n,surface:{type:t.params.surface.type,indices:r,fillFlags:t.params.surface.fillFlags,hasBakedLighting:t.params.surface.hasBakedLighting,textureMapping:t.params.surface.textureMapping,material:void 0!==o?o:t.params.surface.material},edges:a?.get(e),isPlanar:t.params.isPlanar,auxChannels:t.params.auxChannels};i.set(e,c)}return i}function Qa(t){const i=Za.split({indices:t.params.polyline.indices,vertices:t.params.vertices,featureTable:t.featureTable},t.computeNodeId),s=t.params.polyline,n=new Uint32Array(s.nextIndicesAndParams.buffer,s.nextIndicesAndParams.byteOffset,s.nextIndicesAndParams.length/4);let r=0;const o={};for(const t of s.prevIndices){if(Ga(o,t,i)){const t=o.node;t.prevIndices?e(void 0!==t.nextIndicesAndParams):(e(void 0===t.nextIndicesAndParams),t.prevIndices=new Ya(t.indices.numIndices),t.nextIndicesAndParams=new za({initialCapacity:t.indices.numIndices})),t.prevIndices.push(o.index);let i=n[r];const s=(16777215&i)>>>0,a=o.node.remappedIndices.get(s);e(void 0!==a),i=4278190080&i|a,t.nextIndicesAndParams.push(i)}++r}const a=new Map;for(const[s,n]of i){e(void 0!==n.prevIndices&&void 0!==n.nextIndicesAndParams);const{vertices:i,indices:r}=n.buildOutput(t.maxDimension),o={...t.params,vertices:i,polyline:{indices:r,prevIndices:n.prevIndices.toVertexIndices(),nextIndicesAndParams:n.nextIndicesAndParams.toUint8Array()}};a.set(s,o)}return a}var Ka,ja;function $a(t,e,i){t[e+0]=255&i,t[e+1]=(65280&i)>>>8,t[e+2]=(16711680&i)>>>16}!function(t){t[t.Untransformed=4294967295]="Untransformed"}(Ka||(Ka={})),function(t){t[t.Hidden=0]="Hidden",t[t.Silhouette=1]="Silhouette",t[t.Visible=2]="Visible"}(ja||(ja={}));class tc extends aa{get isValid(){return Ro.Gltf===this.format}constructor(t){super(t),this.scenePosition=0,this.sceneStrLength=0,this.binaryPosition=0,this.gltfLength=t.readUint32(),this.sceneStrLength=t.readUint32();const e=t.readUint32();if(this.version===zo.Version2&&e===zo.Gltf1SceneFormat&&(this.version=zo.Version1),this.version===zo.Version1){const i=e;if(zo.Gltf1SceneFormat!==i)return void this.invalidate();this.scenePosition=t.curPos,this.binaryPosition=t.curPos+this.sceneStrLength}else if(this.version===zo.Version2){const i=e;this.scenePosition=t.curPos,t.curPos=t.curPos+this.sceneStrLength;const s=t.readUint32(),n=t.readUint32();if(No.JSON!==i||No.Binary!==n||0===s)return void this.invalidate();this.binaryPosition=t.curPos}else this.invalidate()}}const ec=/Node_(.*)/;function ic(t){const i=t.match(ec);if(e(!!i&&2===i.length),!i||2!==i.length)return 0;const s=Number.parseInt(i[1],10);return e(!Number.isNaN(s)),Number.isNaN(s)?0:s}class sc extends la{constructor(t){super(t)}dispose(){}get bytesUsed(){return 0}}class nc extends sc{constructor(t,e){super(e),this._name=t}toImdl(){return this._name}}class rc extends sc{constructor(t){super(la.Type.Normal),this._gradient=t}toImdl(){return this._gradient}}class oc extends ha{toImdl(){return{isAtlas:!1,material:this.key??this.materialParams}}constructor(t,e){super(t),this.materialParams=e??{alpha:t.alpha,diffuse:{color:t.diffuseColor?.toJSON(),weight:t.diffuse},specular:{color:t.specularColor?.toJSON(),weight:t.specular,exponent:t.specularExponent}}}static create(t){const e=new ha.Params;return e.alpha=t.alpha,t.diffuse&&(void 0!==t.diffuse.weight&&(e.diffuse=t.diffuse?.weight),t.diffuse?.color&&(e.diffuseColor=t.diffuse.color instanceof $r?t.diffuse.color:to.fromJSON(t.diffuse.color).toColorDef())),t.specular&&(void 0!==t.specular.weight&&(e.specular=t.specular.weight),void 0!==t.specular.exponent&&(e.specularExponent=t.specular.exponent),t.specular.color&&(e.specularColor=t.specular.color instanceof $r?t.specular.color:to.fromJSON(t.specular.color).toColorDef())),new oc(e)}}function ac(t){return{...t,uniformColor:void 0!==t.uniformColor?$r.fromJSON(t.uniformColor):void 0,qparams:fa.fromJSON(t.qparams),uvParams:t.uvParams?da.fromJSON(t.uvParams):void 0}}function cc(t){return{...t,uniformColor:t.uniformColor?.toJSON(),qparams:t.qparams.toJSON(),uvParams:t.uvParams?.toJSON()}}function lc(t){return{...t,segments:t.segments?{...t.segments,indices:t.segments.indices.data}:void 0,silhouettes:t.silhouettes?{...t.silhouettes,indices:t.silhouettes.indices.data}:void 0,polylines:t.polylines?{...t.polylines,indices:t.polylines.indices.data,prevIndices:t.polylines.prevIndices.data}:void 0,indexed:t.indexed?{indices:t.indexed.indices.data,edges:t.indexed.edges}:void 0}}class hc{constructor(t,e,i,s,n){this._patterns=new Map,this._document=t,this._binaryData=e,this._options=i,this._featureTableInfo=s,this._stream=n,this._timeline=i.timeline}parse(){const t=this.parseFeatureTable();if(!t)return Do.InvalidFeatureTable;const e=this._document.rtcCenter?{x:this._document.rtcCenter[0]??0,y:this._document.rtcCenter[1]??0,z:this._document.rtcCenter[2]??0}:void 0,i=this.parseNodes(t);return{featureTable:t,nodes:this.groupPrimitiveNodes(i,t),rtcCenter:e,binaryData:this._binaryData,json:this._document,patterns:this._patterns}}parseFeatureTable(){this._stream.curPos=this._featureTableInfo.startPos;const t=ma.readFrom(this._stream);if(!t||0!=t.length%4)return;const e=(t.length-ma.sizeInBytes)/4,i=new Uint32Array(this._stream.nextUint32s(e));if(this._stream.isPastTheEnd)return;let s;if(this._featureTableInfo.multiModel)s={multiModel:!0,data:i,numFeatures:t.count,numSubCategories:t.numSubCategories};else{let e;const n=this._document.animationNodes;if(void 0!==n){const t=Eo.asInt(n.bytesPerId),i=Eo.asString(n.bufferView),s=this._document.bufferViews[i];if(void 0!==s){const i=Eo.asInt(s.byteOffset),n=Eo.asInt(s.byteLength),r=this._binaryData.subarray(i,i+n);switch(t){case 1:e=new Uint8Array(r);break;case 2:e=Uint16Array.from(new Uint16Array(r.buffer,r.byteOffset,r.byteLength/2));break;case 4:e=Uint32Array.from(new Uint32Array(r.buffer,r.byteOffset,r.byteLength/4))}}}s={multiModel:!1,data:i,numFeatures:t.count,animationNodeIds:e}}return this._stream.curPos=this._featureTableInfo.startPos+t.length,s}parseNodes(t){const i=[],s=this._document.nodes,n=this._document.meshes;if(void 0===s.Node_Root)return i;for(const r of Object.keys(s)){const s=this._document.nodes[r];e(void 0!==s);const o=n[s],a=o?.primitives;if(!a)continue;const c=o.layer;"Node_Root"===r?this._timeline?this.parseAnimationBranches(i,o,t,this._timeline):this._options.createUntransformedRootNode?i.push({animationNodeId:Ka.Untransformed,primitives:this.parseNodePrimitives(a)}):i.push({primitives:this.parseNodePrimitives(a)}):void 0===c?i.push({animationNodeId:ic(r),animationId:`${this._options.batchModelId}_${r}`,primitives:this.parseNodePrimitives(a)}):i.push({layerId:c,primitives:this.parseNodePrimitives(a)})}return i}parseAnimationBranches(t,i,s,n){const r=i.primitives;if(!r)return;const o=r.map((t=>this.parseNodePrimitive(t))).filter((t=>void 0!==t));if(0===o.length)return;const a=new Map;e(void 0===s.animationNodeIds);const c=dc(s,this._options.batchModelId);c.populateAnimationNodeIds((t=>n.getBatchIdForFeature(t)),n.maxBatchId),s.animationNodeIds=c.animationNodeIds;const l=n.discreteBatchIds;this.splitPrimitives(o,c,(t=>{const e=c.getAnimationNodeId(t);return 0!==e&&l.has(e)?e:0}),(e=>{e=e??Ka.Untransformed;let i=a.get(e);return i||(i={animationNodeId:e,animationId:`${this._options.batchModelId}_Node_${e}`,primitives:[]},a.set(e,i),t.push(i)),i}))}splitPrimitives(t,i,s,n){const r={maxDimension:this._options.maxVertexTableSize,computeNodeId:s,featureTable:i},o=t=>{if(!t)return;if(t.isAtlas)return t;const e="string"==typeof t.material?this.materialFromJson(t.material):oc.create(function(t){const e={alpha:t.alpha};return t.diffuse&&(e.diffuse={weight:t.diffuse.weight,color:void 0!==t.diffuse.color?$r.fromJSON(t.diffuse.color):void 0}),t.specular&&(e.specular={weight:t.specular.weight,exponent:t.specular.exponent,color:void 0!==t.specular.color?$r.fromJSON(t.specular.color):void 0}),e}(t.material));return e?{isAtlas:!1,material:e}:void 0};for(const i of t)switch(i.type){case"pattern":n(void 0).primitives.push(i);break;case"mesh":{const t=i.params,s=t.surface.textureMapping,c={vertices:ac(i.params.vertices),surface:{...i.params.surface,indices:new Oa(i.params.surface.indices),material:o(t.surface.material),textureMapping:s?{alwaysDisplayed:s.alwaysDisplayed,texture:"string"==typeof s.texture?new nc(s.texture,la.Type.Normal):new rc(s.texture)}:void 0},edges:i.params.edges?(a=i.params.edges,{...a,segments:a.segments?{...a.segments,indices:new Oa(a.segments.indices)}:void 0,silhouettes:a.silhouettes?{...a.silhouettes,indices:new Oa(a.silhouettes.indices)}:void 0,polylines:a.polylines?{...a.polylines,indices:new Oa(a.polylines.indices),prevIndices:new Oa(a.polylines.prevIndices)}:void 0,indexed:a.indexed?{indices:new Oa(a.indexed.indices),edges:a.indexed.edges}:void 0}):void 0,isPlanar:i.params.isPlanar,auxChannels:i.params.auxChannels?Ma.fromJSON(i.params.auxChannels):void 0},l=Ja({...r,params:c,createMaterial:t=>oc.create(t)});for(const[t,s]of l){let r;s.surface.material&&(s.surface.material.isAtlas?r=s.surface.material:(e(s.surface.material.material instanceof oc),r=s.surface.material.material.toImdl())),e(void 0===s.surface.textureMapping||s.surface.textureMapping.texture instanceof sc),n(t).primitives.push({type:"mesh",modifier:i.modifier,params:{vertices:cc(s.vertices),surface:{...s.surface,indices:s.surface.indices.data,material:r,textureMapping:s.surface.textureMapping?.texture instanceof sc?{texture:s.surface.textureMapping.texture.toImdl(),alwaysDisplayed:s.surface.textureMapping.alwaysDisplayed}:void 0},edges:s.edges?lc(s.edges):void 0,isPlanar:s.isPlanar,auxChannels:s.auxChannels?.toJSON()}})}break}case"point":{const t={vertices:ac(i.params.vertices),indices:new Oa(i.params.indices),weight:i.params.weight},e=qa({...r,params:t});for(const[t,s]of e)n(t).primitives.push({type:"point",modifier:i.modifier,params:{vertices:cc(s.vertices),indices:s.indices.data,weight:s.weight}});break}case"polyline":{const t={...i.params,vertices:ac(i.params.vertices),polyline:{indices:new Oa(i.params.polyline.indices),prevIndices:new Oa(i.params.polyline.prevIndices),nextIndicesAndParams:i.params.polyline.nextIndicesAndParams}},e=Qa({...r,params:t});for(const[t,s]of e)n(t).primitives.push({type:"polyline",modifier:i.modifier,params:{...s,vertices:cc(s.vertices),polyline:{indices:s.polyline.indices.data,prevIndices:s.polyline.prevIndices.data,nextIndicesAndParams:s.polyline.nextIndicesAndParams}}});break}}var a}groupPrimitiveNodes(t,i){const s=this._options.modelGroups;if(!s?.length)return t;const n=[];let r;const o=t=>{if(e(t<=s.length),t===s.length)return r??(r={groupId:t,nodes:[]});let i=n[t];return i||(n[t]=i={groupId:t,nodes:[]}),i},a=dc(i,this._options.batchModelId),c={lower:0,upper:0},l=t=>{a.getModelIdPair(t,c);const e=h.fromUint32PairObject(c);for(let t=0;t<s.length;t++)if(s[t].has(e))return t;return s.length};for(const e of t){const t=[],i=i=>{if(i=i??s.length,!t[i]){const s=t[i]={...e,primitives:[]};o(i).nodes.push(s)}return t[i]};this.splitPrimitives(e.primitives,a,l,i)}return n.filter((t=>void 0!==t))}parseTesselatedPolyline(t){const e=this.findBuffer(t.indices),i=this.findBuffer(t.prevIndices),s=this.findBuffer(t.nextIndicesAndParams);return e&&i&&s?{indices:e,prevIndices:i,nextIndicesAndParams:s}:void 0}parseSegmentEdges(t){const e=this.findBuffer(t.indices),i=this.findBuffer(t.endPointAndQuadIndices);return e&&i?{indices:e,endPointAndQuadIndices:i}:void 0}parseSilhouetteEdges(t){const e=this.parseSegmentEdges(t),i=this.findBuffer(t.normalPairs);return e&&i?{...e,normalPairs:i}:void 0}parseIndexedEdges(t){const e=this.findBuffer(t.indices),i=this.findBuffer(t.edges);if(e&&i)return{indices:e,edges:{data:i,width:t.width,height:t.height,silhouettePadding:t.silhouettePadding,numSegments:t.numSegments}}}parseCompactEdges(t,i){const s=this.findBuffer(t.visibility);if(!s)return;const n=void 0!==t.normalPairs?this.findBuffer(t.normalPairs):void 0;return function(t){const i=t.normalPairs?.length??0,s=t.numVisibleEdges+i;if(s<=0)return;const n=new Oa(new Uint8Array(6*s*3));for(let t=0;t<s;t++)for(let e=0;e<6;e++)n.setNthIndex(6*t+e,t);const{width:r,height:o,silhouettePadding:a,silhouetteStartByteIndex:c}=Na(t.numVisibleEdges,i,t.maxEdgeTableDimension),l=new Uint8Array(r*o*4);let h=0,d=0;for(const i of function*(t,i,s){let n=0,r=0,o=0;const a={index0:0,index1:1};for(let c=0;c<i.length;c++){const l=t[r]>>n&3;n+=2,8===n&&(n=0,r++),ja.Hidden!==l&&(a.index0=i.decodeIndex(c),a.index1=i.decodeIndex(c%3==2?c-2:c+1),ja.Silhouette===l?(e(void 0!==s),a.normals=s[o++]):a.normals=void 0,yield a)}}(t.visibility,t.vertexIndices,t.normalPairs))if(void 0===i.normals){const t=6*h++;$a(l,t,i.index0),$a(l,t+3,i.index1)}else{const t=c+a+10*d++;$a(l,t,i.index0),$a(l,t+3,i.index1),l[t+6]=255&i.normals,l[t+7]=(65280&i.normals)>>>8,l[t+8]=(16711680&i.normals)>>>16,l[t+9]=(4278190080&i.normals)>>>24}return{indices:n.data,edges:{data:l,width:r,height:o,numSegments:t.numVisibleEdges,silhouettePadding:a}}}({numVisibleEdges:t.numVisible,visibility:s,vertexIndices:i,normalPairs:n?new Uint32Array(n.buffer,n.byteOffset,n.byteLength/4):void 0,maxEdgeTableDimension:this._options.maxVertexTableSize})}parseEdges(t,e,i){if(!t)return;const s=t.segments?this.parseSegmentEdges(t.segments):void 0,n=t.silhouettes?this.parseSilhouetteEdges(t.silhouettes):void 0,r=t.polylines?this.parseTesselatedPolyline(t.polylines):void 0;let o=t.indexed?this.parseIndexedEdges(t.indexed):void 0;return!o&&t.compact&&(o=this.parseCompactEdges(t.compact,new Oa(i))),s||n||o||r?{segments:s,silhouettes:n,polylines:r,indexed:o,weight:e.width,linePixels:e.linePixels}:void 0}getPattern(t){let e=this._patterns.get(t);if(!e){const i=this._document.patternSymbols[t];e=i?this.parsePrimitives(i.primitives):[],this._patterns.set(t,e)}return e.length>0?e:void 0}parseAreaPattern(t){const e=this.getPattern(t.symbolName);if(!e||0===e.length)return;const i=this.findBuffer(t.xyOffsets);return i?{type:"pattern",params:{...t,xyOffsets:new Float32Array(i.buffer,i.byteOffset,i.byteLength/4)}}:void 0}parseNodePrimitives(t){const e=[];for(const i of t){const t=this.parseNodePrimitive(i);t&&e.push(t)}return e}parseNodePrimitive(t){return"areaPattern"===t.type?this.parseAreaPattern(t):this.parsePrimitive(t)}parsePrimitives(t){const e=[];for(const i of t){const t=this.parsePrimitive(i);t&&e.push(t)}return e}parsePrimitive(t){let e=this.parseInstances(t);if(!e&&t.viewIndependentOrigin){const i=j.fromJSON(t.viewIndependentOrigin);e={type:"viewIndependentOrigin",origin:{x:i.x,y:i.y,z:i.z}}}const i=t.material??"",s=i.length?Eo.asObject(this._document.materials[i]):void 0,n=s?this.parseDisplayParams(s):void 0;if(!n)return;const r=this.parseVertexTable(t);if(!r)return;let o;const a=!this._options.is3d||Eo.asBool(t.isPlanar);switch(t.type){case ta.Mesh:{const e=this.parseSurface(t,n);e&&(o={type:"mesh",params:{vertices:r,surface:e,isPlanar:a,auxChannels:this.parseAuxChannelTable(t),edges:this.parseEdges(t.edges,n,e.indices)}});break}case ta.Polyline:{const e=this.parseTesselatedPolyline(t);if(e){let t=Uo.Normal;va.RegionEdgeType.Outline===n.regionEdgeType&&(t=!n.gradient||n.gradient.isOutlined?Uo.Edge:Uo.Outline),o={type:"polyline",params:{vertices:r,polyline:e,isPlanar:a,type:t,weight:n.width,linePixels:n.linePixels}}}break}case ta.Point:{const e=this.findBuffer(t.indices),i=n.width;e&&(o={type:"point",params:{vertices:r,indices:e,weight:i}});break}}return o&&(o.modifier=e),o}parseSurface(t,i){const s=t.surface;if(!s)return;const n=this.findBuffer(s.indices);if(!n)return;const r=s.type;if(!function(t){switch(t){case ea.Unlit:case ea.Lit:case ea.Textured:case ea.TexturedLit:case ea.VolumeClassifier:return!0;default:return!1}}(r))return;const o=i.textureMapping?.texture;let a;const c=t.vertices.materialAtlas,l=t.vertices.numColors;let h;return c&&void 0!==l?a={isAtlas:!0,hasTranslucency:Eo.asBool(c.hasTranslucency),overridesAlpha:Eo.asBool(c.overridesAlpha,!1),vertexTableOffset:Eo.asInt(l),numMaterials:Eo.asInt(c.numMaterials)}:i.material&&(e(i.material instanceof oc),a=i.material.toImdl()),o&&(e(o instanceof sc),h={texture:o.toImdl(),alwaysDisplayed:Eo.asBool(s.alwaysDisplayTexture)}),{type:r,indices:n,fillFlags:i.fillFlags,hasBakedLighting:!1,material:a,textureMapping:h}}parseAuxChannelTable(t){const e=t.auxChannels;if(void 0===e)return;const i=this.findBuffer(Eo.asString(e.bufferView));return void 0!==i?{data:i,width:e.width,height:e.height,count:e.count,numBytesPerVertex:e.numBytesPerVertex,displacements:e.displacements,normals:e.normals,params:e.params}:void 0}parseVertexTable(t){const e=t.vertices;if(!e)return;const i=this.findBuffer(Eo.asString(e.bufferView));if(!i)return;const s=void 0!==e.featureID?Eo.asInt(e.featureID):void 0,n=Eo.asArray(e.params.decodedMin),r=Eo.asArray(e.params.decodedMax);if(void 0===n||void 0===r)return;const o=fa.fromRange(ut.create(j.create(n[0],n[1],n[2]),j.create(r[0],r[1],r[2]))),a=void 0!==e.uniformColor?$r.fromJSON(e.uniformColor):void 0;let c;if(ta.Mesh===t.type&&t.surface&&t.surface.uvParams){const e=t.surface.uvParams.decodedMin,i=t.surface.uvParams.decodedMax,s=new gt(e[0],e[1],i[0],i[1]);c=da.fromRange(s)}return{data:i,usesUnquantizedPositions:!0===e.usesUnquantizedPositions,qparams:o.toJSON(),width:e.width,height:e.height,hasTranslucency:e.hasTranslucency,uniformColor:a?.toJSON(),featureIndexType:e.featureIndexType,uniformFeatureID:s,numVertices:e.count,numRgbaPerVertex:e.numRgbaPerVertex,uvParams:c?.toJSON()}}parseInstances(t){const i=t.instances;if(!i)return;const s=Eo.asInt(i.count,0);if(s<=0)return;const n=Eo.asArray(i.transformCenter);if(void 0===n||3!==n.length)return;const r=j.create(n[0],n[1],n[2]),o=this.findBuffer(Eo.asString(i.featureIds));if(void 0===o)return;const a=this.findBuffer(Eo.asString(i.transforms));if(void 0===a)return;const c=a.byteLength/4;e(Math.floor(c)===c),e(0==c%12);const l=new Float32Array(a.buffer,a.byteOffset,c);let h;return void 0!==i.symbologyOverrides&&(h=this.findBuffer(Eo.asString(i.symbologyOverrides))),{type:"instances",count:s,transforms:l,transformCenter:r,featureIds:o,symbologyOverrides:h}}findBuffer(t){if("string"!=typeof t||0===t.length)return;const e=this._document.bufferViews[t];if(void 0===e)return;const i=Eo.asInt(e.byteOffset),s=Eo.asInt(e.byteLength);return 0!==s?this._binaryData.subarray(i,i+s):void 0}colorDefFromMaterialJson(t){return void 0!==t?$r.from(255*t[0]+.5,255*t[1]+.5,255*t[2]+.5):void 0}materialFromJson(t){const e=this._document.renderMaterials[t];if(!e)return;const i=new ha.Params(t);return i.diffuseColor=this.colorDefFromMaterialJson(e.diffuseColor),void 0!==e.diffuse&&(i.diffuse=Eo.asDouble(e.diffuse)),i.specularColor=this.colorDefFromMaterialJson(e.specularColor),void 0!==e.specular&&(i.specular=Eo.asDouble(e.specular)),i.reflectColor=this.colorDefFromMaterialJson(e.reflectColor),void 0!==e.reflect&&(i.reflect=Eo.asDouble(e.reflect)),void 0!==e.specularExponent&&(i.specularExponent=e.specularExponent),void 0!==e.transparency&&(i.alpha=1-e.transparency),i.refract=Eo.asDouble(e.refract),i.shadows=Eo.asBool(e.shadows),i.ambient=Eo.asDouble(e.ambient),void 0!==e.textureMapping&&(i.textureMapping=this.textureMappingFromJson(e.textureMapping.texture)),new oc(i)}parseNamedTexture(t,e){const i=Eo.asBool(t.isGlyph)?la.Type.Glyph:Eo.asBool(t.isTileSection)?la.Type.TileSection:la.Type.Normal;return new nc(e,i)}parseConstantLodProps(t){if(void 0!==t)return{repetitions:Eo.asDouble(t.repetitions,1),offset:{x:t.offset?Eo.asDouble(t.offset[0]):0,y:t.offset?Eo.asDouble(t.offset[1]):0},minDistClamp:Eo.asDouble(t.minDistClamp,1),maxDistClamp:Eo.asDouble(t.maxDistClamp,4294967296)}}textureMappingFromJson(t){if(!t)return;const e=Eo.asString(t.name),i=0!==e.length?this._document.namedTextures[e]:void 0,s=i?this.parseNamedTexture(i,e):void 0;if(!s)return;const n=t.params,r=n.transform,o={textureMat2x3:new xa.Trans2x3(r[0][0],r[0][1],r[0][2],r[1][0],r[1][1],r[1][2]),textureWeight:Eo.asDouble(n.weight,1),mapMode:Eo.asInt(n.mode),worldMapping:Eo.asBool(n.worldMapping),useConstantLod:Eo.asBool(n.useConstantLod),constantLodProps:this.parseConstantLodProps(n.constantLodParams)},a=new xa(s,new xa.Params(o)),c=t.normalMapParams;if(c){const t=Eo.asString(c.textureName),e=t.length>0?this._document.namedTextures[t]:void 0,i=e?this.parseNamedTexture(e,t):void 0;i&&(a.normalMapParams={normalMap:i,greenUp:Eo.asBool(c.greenUp),scale:Eo.asDouble(c.scale,1),useConstantLod:Eo.asBool(c.useConstantLod)})}return a}parseDisplayParams(t){const i=Eo.asInt(t.type,va.Type.Mesh),s=$r.create(Eo.asInt(t.lineColor)),n=$r.create(Eo.asInt(t.fillColor)),r=Eo.asInt(t.lineWidth),o=Eo.asInt(t.linePixels,Zo.Solid),a=Eo.asInt(t.fillFlags,qo.None),c=Eo.asBool(t.ignoreLighting),l=t.materialId,h=void 0!==l?this.materialFromJson(l):void 0;let d,u;if(!h){const i=t.texture;if(d=void 0!==i?this.textureMappingFromJson(i):void 0,void 0===d){const i=t.gradient;if(u=void 0!==i?$o.Symb.fromJSON(i):void 0,u){e(void 0!==i);const t=new rc(i);d=new xa(t,new xa.Params({textureMat2x3:new xa.Trans2x3(0,1,0,1,0,0)}))}}}return new va(i,s,n,r,o,a,h,u,c,d)}}function dc(t,e){const i=t.multiModel?xo.create(t.data,e,t.numFeatures,co.Primary,t.numSubCategories):new go(t.data,e,t.numFeatures,co.Primary);return i.animationNodeIds=t.animationNodeIds,i}let uc;var fc;fc={parse:t=>{const e=function(t){const e=oa.fromUint8Array(t.data),i=new pa(e);if(!i.isValid)return Do.InvalidHeader;if(!i.isReadableVersion)return Do.NewerMajorVersion;const s=e.curPos,n=ma.readFrom(e);if(!n)return Do.InvalidFeatureTable;e.curPos=s+n.length;const r=new tc(e);if(!r.isValid)return Do.InvalidTileData;e.curPos=r.scenePosition;const o=(a=e.nextBytes(r.sceneStrLength),new TextDecoder("utf-8").decode(a));var a;if(!o)return Do.InvalidScene;try{const n=JSON.parse(o),a={scene:Eo.asString(n.scene),scenes:Eo.asArray(n.scenes),animationNodes:Eo.asObject(n.animationNodes),bufferViews:Eo.asObject(n.bufferViews)??{},meshes:Eo.asObject(n.meshes),nodes:Eo.asObject(n.nodes)??{},materials:Eo.asObject(n.materials)??{},renderMaterials:Eo.asObject(n.renderMaterials)??{},namedTextures:Eo.asObject(n.namedTextures)??{},patternSymbols:Eo.asObject(n.patternSymbols)??{},rtcCenter:Eo.asArray(n.rtcCenter)};if(!a.meshes)return Do.InvalidTileData;const c=new Uint8Array(e.arrayBuffer,r.binaryPosition),l={startPos:s,multiModel:!!(i.flags&Vo.MultiModelFeatureTable)};return new hc(a,c,t,l,e).parse()}catch{return Do.InvalidTileData}}({...t,data:t.data,timeline:uc});return"number"==typeof e?e:{result:e,transfer:ra(e)}},setTimeline:t=>{e(void 0===uc,"setTimeline must be called only once"),uc=Array.isArray(t)?bo.Script.fromJSON(t):bo.ModelTimeline.fromJSON(t)}},onmessage=async t=>{const i=t.data,s=i.msgId;try{e("object"==typeof i&&"operation"in i&&"payload"in i&&"msgId"in i);const t=fc[i.operation];e("function"==typeof t);let n=t(i.payload);n instanceof Promise&&(n=await n),"object"==typeof n&&"transfer"in n?postMessage({result:n.result,msgId:s},{transfer:n.transfer}):postMessage({result:n,msgId:s})}catch(t){const e=t instanceof Error?t:new Error("Unknown worker error");postMessage({error:e,msgId:s})}}})();